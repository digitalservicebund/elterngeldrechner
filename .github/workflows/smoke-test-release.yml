name: Smoke Test Release

on:
  schedule:
    - cron: "0 6-18 * * *" # Run every hour between 7 AM and 7 PM (Berlin time)

jobs:
  smoke-test:
    runs-on: ubuntu-latest

    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch current production release version
        id: fetch-production-version
        uses: ./.github/actions/fetch-version-hash
        with:
          url: ${{ vars.PRODUCTION_URL }}

      - name: Restore cache for tested version
        id: cache-tested-version
        uses: actions/cache/restore@v4
        with:
          key: tested-version-${{ steps.fetch-production-version.outputs.version-hash }}
          path: /tmp/tested-version-${{ steps.fetch-production-version.outputs.version-hash }}

      - name: Git checkout deployed release
        if: steps.cache-tested-version.outputs.cache-hit != 'true'
        run: git checkout ${{ steps.fetch-production-version.outputs.version-hash }}

      - name: Restore the .github directory to enable modifications to actions
        if: steps.cache-tested-version.outputs.cache-hit != 'true'
        run: git checkout ${{ github.sha }} -- .github playwright.config.ts

      - uses: ./.github/actions/cached-node-install
        if: steps.cache-tested-version.outputs.cache-hit != 'true'

      - uses: ./.github/actions/cached-playwright-setup
        if: steps.cache-tested-version.outputs.cache-hit != 'true'

      - name: Run playwright smoke test
        if: steps.cache-tested-version.outputs.cache-hit != 'true'
        run: npm run test-e2e -- tests/cases/smokeTest.spec.ts
        env:
          PLAYWRIGHT_REPORTER: html
          PLAYWRIGHT_SKIP_SERVER: true
          PLAYWRIGHT_URL: ${{ vars.PRODUCTION_URL }}
          PLAYWRIGHT_PORT: 80

      - name: Create empty cache directory
        if: steps.cache-tested-version.outputs.cache-hit != 'true'
        run: mkdir -p /tmp/tested-version-${{ steps.fetch-production-version.outputs.version-hash }}

      - name: Update cache with tested version
        if: steps.cache-tested-version.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          key: tested-version-${{ steps.fetch-production-version.outputs.version-hash }}
          path: /tmp/tested-version-${{ steps.fetch-production-version.outputs.version-hash }}

      - name: Upload Playwright report
        if: always() && steps.cache-tested-version.outputs.cache-hit != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report
          retention-days: 1

      - name: Get tag for the release
        if: success() && steps.cache-tested-version.outputs.cache-hit != 'true'
        id: get-tag
        run: |
          TAG=$(git describe --tags --exact-match ${{ steps.fetch-production-version.outputs.version-hash }})
          echo "tag=$TAG" >> $GITHUB_ENV

      - name: Send release message to slack
        uses: slackapi/slack-github-action@37ebaef184d7626c5f204ab8d3baff4262dd30f0
        if: success() && steps.cache-tested-version.outputs.cache-hit != 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
        with:
          payload: '{ "text": "Release ${{ env.tag }} is live and has successfully passed the initial test. :rocket:" }'

      - name: Create metabase release event
        if: success() && steps.cache-tested-version.outputs.cache-hit != 'true'
        env:
          METABASE_API_KEY: ${{ secrets.EGR_METABASE_API_KEY }}
          METABASE_DOMAIN: ${{ secrets.EGR_METABASE_DOMAIN }}
        run: |
          # Get the current timestamp in the required format (ISO 8601 with timezone)
          TIMESTAMP=$(date --utc +"%Y-%m-%dT%H:%M:%S.000+00:00")

          curl -X POST "https://${METABASE_DOMAIN}/api/timeline-event/" \
            -H "x-api-key: $METABASE_API_KEY" \
            -H "Content-Type: application/json" \
            -d '{
                  "name": "Release",
                  "description": null,
                  "timestamp": "'"$TIMESTAMP"'",
                  "timeline_id": 1,
                  "icon": "cloud",
                  "timezone": "Europe/Berlin",
                  "time_matters": false,
                  "archived": false,
                  "source": "collections"
                }'

      - name: Restore cache for failure notification
        if: failure() && steps.cache-tested-version.outputs.cache-hit != 'true'
        id: cache-failure-notification
        uses: actions/cache/restore@v4
        with:
          key: tested-version-${{ steps.fetch-production-version.outputs.version-hash }}-notification
          path: /tmp/tested-version-${{ steps.fetch-production-version.outputs.version-hash }}-notification

      - name: Send failure to Slack
        uses: digitalservicebund/notify-on-failure-gha@66c485757701f8d5dbee32f24df38d904ca693ba
        if: failure() && steps.cache-tested-version.outputs.cache-hit != 'true' && steps.cache-failure-notification.outputs.cache-hit != 'true'
        with:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create empty cache directory for failure notification
        if: failure() && steps.cache-tested-version.outputs.cache-hit != 'true' && steps.cache-failure-notification.outputs.cache-hit != 'true'
        run: mkdir -p /tmp/tested-version-${{ steps.fetch-production-version.outputs.version-hash }}-notification

      - name: Update cache with tested version
        if: failure() && steps.cache-tested-version.outputs.cache-hit != 'true' && steps.cache-failure-notification.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          key: tested-version-${{ steps.fetch-production-version.outputs.version-hash }}-notification
          path: /tmp/tested-version-${{ steps.fetch-production-version.outputs.version-hash }}-notification
