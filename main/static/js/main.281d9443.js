/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2932:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  gM: () => (/* reexport */ AriaLogProvider),
  ye: () => (/* reexport */ AriaMessage),
  zx: () => (/* reexport */ Button),
  dk: () => (/* reexport */ Description),
  pQ: () => (/* reexport */ FootNoteNumber),
  ly: () => (/* reexport */ MonatsplanerMonth),
  FI: () => (/* reexport */ NotificationBEGHintMin),
  yi: () => (/* reexport */ NotificationBEGHintMinMax),
  Ev: () => (/* reexport */ NotificationBEGMax),
  C: () => (/* reexport */ NotificationBEGResultWasRecalculated),
  dx: () => (/* reexport */ NotificationMaxElterngeld),
  dR: () => (/* reexport */ NotificationNoFurtherMonthAvailable),
  tp: () => (/* reexport */ NotificationPSBAutomaticallySelection),
  yp: () => (/* reexport */ NotificationPSBChangeOtherElternteil),
  ov: () => (/* reexport */ NotificationPSBNotDeselectable),
  ag: () => (/* reexport */ NotificationValidationMonatsplaner),
  g3: () => (/* reexport */ PrintButton),
  $j: () => (/* reexport */ Spinner),
  JE: () => (/* reexport */ SplitItem),
  FN: () => (/* reexport */ Toast)
});

// UNUSED EXPORTS: LabelCounter, VisualCounter

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(2791);
// EXTERNAL MODULE: ./src/globals/js/namespace.js + 1 modules
var namespace = __webpack_require__(9242);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(184);
;// CONCATENATED MODULE: ./src/components/atoms/aria-message/AriaLogProvider.tsx
const AriaLogContext=/*#__PURE__*/(0,react.createContext)(undefined);/**
 * Provides access to the ARIA-logs. By adding a message to the log the message can be read by a screen reader.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/log_role
 */function AriaLogProvider(_ref){let{children}=_ref;const[messages,setMessages]=(0,react.useState)([]);const addMessage=(0,react.useCallback)(message=>{setMessages(existing=>[message,...existing]);return()=>setMessages(existing=>existing.filter(otherMessage=>otherMessage!==message));},[]);const context=(0,react.useMemo)(()=>({addMessage}),[addMessage]);return/*#__PURE__*/(0,jsx_runtime.jsxs)(AriaLogContext.Provider,{value:context,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{role:"log",className:(0,namespace/* default */.Z)("aria-log"),children:messages.map(message=>/*#__PURE__*/(0,jsx_runtime.jsx)("p",{children:message},message))}),children]});}const useAriaLog=()=>{const context=(0,react.useContext)(AriaLogContext);if(!context){throw new Error("Missing context for 'useAriaLog' hook.");}return context;};
;// CONCATENATED MODULE: ./src/components/atoms/aria-message/AriaMessage.tsx
function AriaMessage(_ref){let{children:message}=_ref;const{addMessage}=useAriaLog();(0,react.useEffect)(()=>addMessage(message),[addMessage,message]);return null;}
;// CONCATENATED MODULE: ./src/components/atoms/aria-message/index.ts

// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(1418);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
;// CONCATENATED MODULE: ./src/components/atoms/button/Button.tsx
function Button(_ref){let{className,buttonStyle="primary",label,iconBefore,iconAfter,onClick,disabled=false,ariaLabel,ariaControls,isSubmitButton=false}=_ref;return/*#__PURE__*/(0,jsx_runtime.jsxs)("button",{className:classnames_default()((0,namespace/* default */.Z)("button"),buttonStyle==="primary"&&(0,namespace/* default */.Z)("button--primary"),buttonStyle==="secondary"&&(0,namespace/* default */.Z)("button--secondary"),buttonStyle==="link"&&(0,namespace/* default */.Z)("button--link"),disabled&&(0,namespace/* default */.Z)("button--disabled"),className),type:isSubmitButton?"submit":"button",onClick:onClick,disabled:disabled,"aria-label":ariaLabel,"aria-controls":ariaControls,children:[!!iconBefore&&iconBefore,!!iconBefore&&/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:"\xA0"}),/*#__PURE__*/(0,jsx_runtime.jsx)("span",{children:label}),!!iconAfter&&/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:"\xA0"}),!!iconAfter&&iconAfter]});}
;// CONCATENATED MODULE: ./src/components/atoms/button/index.ts

;// CONCATENATED MODULE: ./src/components/atoms/label-counter/LabelCounter.tsx
function LabelCounter(_ref){let{label,count,maxCount}=_ref;return/*#__PURE__*/_jsxs("div",{className:nsp("label-counter"),children:[/*#__PURE__*/_jsx("p",{className:nsp("label-counter__label"),children:label}),/*#__PURE__*/_jsxs("p",{children:[count,"/",maxCount]})]});}
;// CONCATENATED MODULE: ./src/components/atoms/label-counter/index.ts

;// CONCATENATED MODULE: ./src/components/atoms/description/Description.tsx
function Description(_ref){let{id,error=false,children}=_ref;return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:classnames_default()((0,namespace/* default */.Z)("info-text"),error&&(0,namespace/* default */.Z)("info-text--error")),id:id,children:children});}
;// CONCATENATED MODULE: ./src/components/atoms/description/index.ts

;// CONCATENATED MODULE: ./src/components/atoms/foot-note-number/FootNoteNumber.tsx
function FootNoteNumber(_ref){let{type,number,prefix,className}=_ref;const formatted_prefix=prefix?"".concat(prefix,"-"):"";const id="footnote_".concat(formatted_prefix).concat(number,"_").concat(Date.now());const allClassNames=classnames_default()((0,namespace/* default */.Z)("foot-note-number"),className);switch(type){case"note":return/*#__PURE__*/(0,jsx_runtime.jsx)("span",{id:id,className:allClassNames,children:number});case"anchor":return/*#__PURE__*/(0,jsx_runtime.jsx)("a",{href:"#".concat(id),className:allClassNames,children:number});default:throw new Error("Unknown FootNoteType: "+type);}}
;// CONCATENATED MODULE: ./src/components/atoms/foot-note-number/index.ts

// EXTERNAL MODULE: ./src/components/molecules/info-dialog/index.ts + 1 modules
var info_dialog = __webpack_require__(6436);
;// CONCATENATED MODULE: ./src/components/atoms/monatsplaner-month/MonatsplanerMonth.tsx
function MonatsplanerMonth(_ref){let{isSelected,isMutterschutzMonth,isElternteilOne,isHighlighted,label,elterngeldType,onToggle,onDragOver,onMouseOver,onMouseLeave,children}=_ref;const handleMouseDown=()=>{onToggle();};const handleClick=e=>{e.preventDefault();};const handleMouseOver=e=>{if(e.buttons!==0){onDragOver();}onMouseOver&&onMouseOver();};function onFocus(event){onMouseOver&&onMouseOver();}return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:classnames_default()((0,namespace/* default */.Z)("monatsplaner-month"),isSelected&&(0,namespace/* default */.Z)("monatsplaner-month--selected"),isHighlighted&&(0,namespace/* default */.Z)("monatsplaner-month--highlighted"),elterngeldType==="BEG"&&(0,namespace/* default */.Z)("monatsplaner-month--beg"),elterngeldType==="EG+"&&(0,namespace/* default */.Z)("monatsplaner-month--egplus"),elterngeldType==="PSB"&&(0,namespace/* default */.Z)("monatsplaner-month--psb")),"data-testid":label,children:isMutterschutzMonth?/*#__PURE__*/(0,jsx_runtime.jsx)(info_dialog/* InfoDialog */.c,{isMonatsplanner:true,isElternteilOne:isElternteilOne,info:info_dialog/* infoTexts */.E.monatsplannerMutterschaftsleistungen}):/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:/*#__PURE__*/(0,jsx_runtime.jsx)("button",{type:"button","aria-label":label,onMouseDown:handleMouseDown,onClick:handleClick,onMouseOver:handleMouseOver,onFocus:onFocus,onBlur:onMouseLeave,onMouseLeave:onMouseLeave,children:children})})});}
;// CONCATENATED MODULE: ./src/components/atoms/monatsplaner-month/index.ts

;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationBEGHintMinMax.tsx
function NotificationBEGHintMinMax(){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Jeder Elternteil muss mindestens 2 und darf maximal 12 Monate Elterngeld beantragen."});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationBEGHintMin.tsx
function NotificationBEGHintMin(){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Sie m\xFCssen mindestens zwei Monate Elterngeld beantragen."});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationNoFurtherMonthAvailable.tsx
const getTargetTypeName=targetType=>{if(targetType==="BEG"){return"Basiselterngeld";}if(targetType==="BEGAndEG+"){return"Basiselterngeld- und ElterngeldPlus";}};function NotificationNoFurtherMonthAvailable(_ref){let{targetType}=_ref;return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:["Ihre verf\xFCgbaren ",getTargetTypeName(targetType),"-Monate sind aufgebraucht."]});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationPSBAutomaticallySelection.tsx
function NotificationPSBAutomaticallySelection(_ref){let{label}=_ref;return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Auch Monat ".concat(label," wurde automatisch ausgew\xE4hlt, weil Sie Partnerschaftsbonus mindestens 2 Monate nehmen m\xFCssen.")});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationPSBNotDeselectable.tsx
function NotificationPSBNotDeselectable(){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Dieser Monat kann nicht abgew\xE4hlt werden. Der Partnerschaftsbonus muss am St\xFCck genommen werden."});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationPSBChangeOtherElternteil.tsx
function NotificationPSBChangeOtherElternteil(){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Der Partnerschaftsbonus \xE4ndert sich immer auch beim anderen Elternteil."});}
// EXTERNAL MODULE: ./src/globals/js/calculations/model/index.ts + 15 modules
var model = __webpack_require__(3444);
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationBEGResultWasRecalculated.tsx
function NotificationBEGResultWasRecalculated(_ref){let{elternteilName,alleinerziehend}=_ref;return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:alleinerziehend!==model/* YesNo */.l.YES?"Das Ergebnis der Berechnung f\xFCr ".concat(elternteilName," hat sich ver\xE4ndert, da Sie Angaben im Formular ge\xE4ndert haben."):"Das Ergebnis der Berechnung hat sich verändert, da Sie Angaben im Formular geändert haben."});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationValidationMonatsplaner.tsx
function NotificationValidationMonatsplaner(_ref){let{errorCodes}=_ref;const messages=errorCodes.map(code=>{switch(code){case"HasNoSelection":return"Mindestens ein Elternteil muss Elterngeld beantragen.";// already excluded with Frontend implementation
case"HasTakenMoreThanTheAvailableBEGMonths":return"Reduzieren Sie auf die verfügbare Anzahl von Basiselterngeld-Monaten.";// already excluded with Frontend implementation
case"DoesNotHaveTheMinimumAmountOfEGMonthsOrNoneAtAll":return"Nur 1 Monat Elterngeld für ein Elternteil ist nicht zulässig.";case"DoesNotHaveContinuousEGAfterBEGAnspruch":return"Elterngeld muss ab dem 15. Monat durchgängig genommen werden.";case"HasTakenBEGAfterBEGAnspruch":return"Basiselterngeld kann nicht nach dem 15. Monat genommen werden";// already excluded with Frontend implementation
default:return"";}});return/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:messages.map(message=>/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:message},message))});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationMaxElterngeld.tsx
function NotificationMaxElterngeld(){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Von Ihrem Netto Einkommen werden h\xF6chstens 2770 Euro f\xFCr die Festlegung des Elterngelds ber\xFCcksichtigt. In den Lebensmonaten, in denen Sie kein Einkommen haben, bekommen Sie den Elterngeld-H\xF6chstbetrag von 1800 Euro (ohne Geschwisterbonus). In den Lebensmonaten, in denen Sie Einkommen haben, wird Ihr Elterngeld berechnet aus dem Unterschied zwischen 2770 Euro und Ihrem Einkommen nach der Geburt."});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/NotificationBEGMax.tsx
function NotificationBEGMax(){return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{children:"Ein Elternteil darf maximal 12 Monate Basiselterngeld beantragen."});}
;// CONCATENATED MODULE: ./src/components/atoms/notification/index.ts

;// CONCATENATED MODULE: ./src/components/atoms/spinner/Spinner.tsx
function Spinner(){const[show,setShow]=(0,react.useState)(false);(0,react.useEffect)(()=>{const timeout=setTimeout(()=>setShow(true),500);return()=>{clearTimeout(timeout);};},[]);return/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:!!show&&/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:(0,namespace/* default */.Z)("spinner")})});}
;// CONCATENATED MODULE: ./src/components/atoms/spinner/index.ts

;// CONCATENATED MODULE: ./src/components/atoms/split-item/SplitItem.tsx
function SplitItem(_ref){let{hasDivider,children}=_ref;return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:classnames_default()((0,namespace/* default */.Z)("split-item"),hasDivider&&(0,namespace/* default */.Z)("split-item--has-divider")),children:children});}
;// CONCATENATED MODULE: ./src/components/atoms/split-item/index.ts

// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(4164);
;// CONCATENATED MODULE: ./src/components/atoms/toast/toast.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const toast = ({});
;// CONCATENATED MODULE: ./src/components/atoms/toast/Toast.tsx
function ToastContent(_ref){let{messages,active}=_ref;return/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"".concat((0,namespace/* default */.Z)("toast")," ").concat(active?(0,namespace/* default */.Z)("toast--active"):""),children:messages!==null&&messages.map((message,index)=>/*#__PURE__*/(0,jsx_runtime.jsx)(react.Fragment,{children:message},index))});}const Toast=_ref2=>{let{messages,active,onUnMount,timeout}=_ref2;(0,react.useEffect)(()=>{let timerId;if(messages!==null&&messages.length>0){timerId=setTimeout(()=>{onUnMount();},timeout);}return()=>clearTimeout(timerId);},[messages,onUnMount,timeout]);return/*#__PURE__*/react_dom.createPortal(/*#__PURE__*/(0,jsx_runtime.jsx)(ToastContent,{messages:messages,active:active}),document.getElementById("egr-toast"));};
;// CONCATENATED MODULE: ./src/components/atoms/toast/index.ts

;// CONCATENATED MODULE: ./src/components/atoms/visual-counter/VisualCounter.tsx
function VisualCounter(_ref){let{countBasis,maxCountBasis,countPlus,maxCountPlus,countBonus,maxCountBonus}=_ref;const arrayOf=maxCount=>{const numbers=[];for(let i=1;i<=maxCount;i++){numbers.push(i);}return numbers;};const classNameOf=(classNamePart,index,count)=>{let className="visual-counter__".concat(classNamePart,"block");if(index>count){className+="--used";}return nsp(className);};const bonusAvailable=maxCountBonus!==0;return/*#__PURE__*/_jsxs("div",{className:nsp("visual-counter"),children:[/*#__PURE__*/_jsxs("div",{className:nsp("visual-counter__basisplus"),children:[/*#__PURE__*/_jsx("div",{className:nsp("visual-counter__basis"),children:arrayOf(maxCountBasis).map(index=>/*#__PURE__*/_jsx("div",{className:classNameOf("basis",index,countBasis)},index))}),/*#__PURE__*/_jsx("div",{className:nsp("visual-counter__plus"),children:arrayOf(maxCountPlus).map(index=>/*#__PURE__*/_jsx("div",{className:classNameOf("plus",index,countPlus)},index))})]}),!!bonusAvailable&&/*#__PURE__*/_jsx("div",{className:nsp("visual-counter__bonus"),children:arrayOf(maxCountBonus).map(index=>/*#__PURE__*/_jsx("div",{className:classNameOf("bonus",index,countBonus)},index))})]});}
;// CONCATENATED MODULE: ./src/components/atoms/visual-counter/index.ts

// EXTERNAL MODULE: ./node_modules/@digitalservicebund/icons/SaveAlt.js
var SaveAlt = __webpack_require__(4606);
var SaveAlt_default = /*#__PURE__*/__webpack_require__.n(SaveAlt);
;// CONCATENATED MODULE: ./src/components/atoms/print-button/PrintButton.tsx
function PrintButton(){const handlePrint=()=>{window.print();};return/*#__PURE__*/(0,jsx_runtime.jsx)(Button,{buttonStyle:"link",label:"Download der Planung",iconBefore:/*#__PURE__*/(0,jsx_runtime.jsx)((SaveAlt_default()),{}),onClick:handlePrint});}
;// CONCATENATED MODULE: ./src/components/atoms/print-button/index.ts

;// CONCATENATED MODULE: ./src/components/atoms/index.ts


/***/ }),

/***/ 2184:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ InfoDialog)
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1418);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2791);
/* harmony import */ var _digitalservicebund_icons_InfoOutlined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3228);
/* harmony import */ var _digitalservicebund_icons_InfoOutlined__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_digitalservicebund_icons_InfoOutlined__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _digitalservicebund_icons_Close__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9602);
/* harmony import */ var _digitalservicebund_icons_Close__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_digitalservicebund_icons_Close__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9242);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(184);
function InfoDialog(_ref){let{info,isLarge,isMonatsplanner,isElternteilOne}=_ref;const[isModalOpen,setIsModalOpen]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);return/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div",{className:classnames__WEBPACK_IMPORTED_MODULE_0___default()((0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog"),isLarge&&(0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog--large"),isMonatsplanner&&(0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog--monatsplanner")),children:[/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("button",{className:classnames__WEBPACK_IMPORTED_MODULE_0___default()((0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog__button"),isMonatsplanner&&(0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog__button--monatsplanner")),type:"button",onClick:()=>setIsModalOpen(true),"aria-label":"Zugeh\xF6rige Information zeigen",children:/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)((_digitalservicebund_icons_InfoOutlined__WEBPACK_IMPORTED_MODULE_2___default()),{})}),!!isModalOpen&&/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div",{className:classnames__WEBPACK_IMPORTED_MODULE_0___default()((0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog-box"),isElternteilOne&&(0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog-box--monatsplanner-et-one")),role:"dialog","aria-describedby":info.id,children:[/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("button",{className:(0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog-box__button"),type:"button",onClick:()=>setIsModalOpen(false),"aria-label":"Information schlie\xDFen",children:/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)((_digitalservicebund_icons_Close__WEBPACK_IMPORTED_MODULE_3___default()),{})}),/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div",{id:info.id,className:(0,_globals_js_namespace__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)("info-dialog-box__text"),children:typeof info.text==="string"?/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("p",{className:"whitespace-pre-line",children:info.text}):info.text})]})]});}

/***/ }),

/***/ 6436:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  c: () => (/* reexport */ InfoDialog/* InfoDialog */.c),
  E: () => (/* reexport */ infoTexts)
});

// EXTERNAL MODULE: ./src/components/molecules/info-dialog/InfoDialog.tsx
var InfoDialog = __webpack_require__(2184);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(184);
;// CONCATENATED MODULE: ./src/components/molecules/info-dialog/infoTexts.tsx
const infoTexts={erwerbstaetigkeitNichtSelbststaendig:{id:"info-1",text:"z.B. Lohn, Gehalt (auch aus einem Minijob)"},erwerbstaetigkeitGewinneinkuenfte:{id:"info-2",text:"Einkünfte aus einem Gewerbebetrieb (auch z.B. aus dem Betrieb einer Fotovoltaik-Anlage), Einkünfte aus selbständiger Arbeit (auch z.B. aus einem Nebenberuf), Einkünfte aus Land- und Forstwirtschaft"},erwerbstaetigkeitNichtSelbststaendigGewinneinkuenfte:{id:"info-2",text:"Einkünfte aus nichtselbständiger Arbeit: z.B. Lohn Gehalt (auch aus einem Minijob) oder Gewinneinkünfte: Einkünfte aus einem Gewerbebetrieb (auch z.B. aus dem Betrieb einer Fotovoltaik-Anlage), Einkünfte aus selbständiger Arbeit (auch z.B. aus einem Nebenberuf), Einkünfte aus Land- und Forstwirtschaft"},einkommenNichtSelbststaendig:{id:"info-3",text:"Als Einkommen werden alle Einkünfte aus Ihrer nicht-selbständigen Tätigkeit im Bemessungszeitraum berücksichtigt. Nicht berücksichtigt werden sonstige Bezüge, z.B. Abfindungen, Leistungsprämien, Provisionen, 13. Monatsgehälter. Steuerfreie Einnahmen werden ebenfalls nicht berücksichtigt, z.B. Trinkgelder, steuerfreie Zuschläge, Krankengeld, Kurzarbeitergeld, ALG II"},einkommenGewinneinkuenfte:{id:"info-4",text:"Dies ergibt sich aus Ihrem letzten oder vorletzten Steuerbescheid oder Sie können schätzen"},einkommenSteuerklasse:{id:"info-5",text:"Das Faktorverfahren in der Steuerklassenkombination IV/IV wird in der vorliegenden Berechnung nicht berücksichtigt. Der Standardwert 1,0 ist festgelegt. Sollte Ihr Faktor kleiner als 1,0 sein, wirkt sich dies entsprechend auf die Höhe des Elterngeldes aus. Sie erhalten dann mehr Elterngeld (im unteren zweistelligen Bereich)"},minijobsMaxZahl:{id:"info-6",text:"geringfügige Beschäftigung bis max. 520 Euro monatlich, vor dem 01.10.2022: bis max. 450 Euro monatlich"},monatsplannerMutterschaftsleistungen:{id:"info-10",text:"In den ersten zwei oder drei Lebensmonaten bekommt die leibliche Mutter meistens Mutterschaftsleistungen. Dann gelten diese Monate bei ihr automatisch als Monate mit Basiselterngeld"},kindGeburtsdatum:{id:"info-11",text:/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("p",{children:"Wenn Ihr Kind zu fr\xFCh zur Welt kommt, k\xF6nnen Sie l\xE4nger Elterngeld bekommen. Dabei kommt es auf den errechneten Geburtstermin an:"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("dl",{children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"mb-8",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("dt",{children:"mindestens 6 Wochen zu fr\xFCh:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("dd",{className:"ml-0",children:"1 zus\xE4tzlicher Monat Basiselterngeld"})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"mb-8",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("dt",{children:"mindestens 8 Wochen zu fr\xFCh:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("dd",{className:"ml-0",children:"2 zus\xE4tzliche Monate Basiselterngeld"})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"mb-8",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("dt",{children:"mindestens 12 Wochen zu fr\xFCh:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("dd",{className:"ml-0",children:"3 zus\xE4tzliche Monate Basiselterngeld"})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("dt",{children:"mindestens 16 Wochen zu fr\xFCh:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("dd",{className:"ml-0",children:"4 zus\xE4tzliche Monate Basiselterngeld"})]})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{children:"Wie sonst auch, k\xF6nnen Sie jeden dieser Monate mit Basiselterngeld tauschen in jeweils 2 Monate mit ElterngeldPlus."}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{children:"F\xFCr die vorliegende Berechnung werden diese zus\xE4tzlichen Monate nicht ber\xFCcksichtigt."})]})},alleinerziehend:{id:"info-12",text:"Als alleinerziehend gelten Sie, wenn der andere Elternteil weder mit Ihnen noch mit dem Kind zusammen wohnt und Sie steuerrechtlich als alleinerziehend gelten."},einkommenLimitÜberschritten:{id:"info-13",text:"Wenn Sie besonders viel Einkommen haben, können Sie kein Elterngeld bekommen. Elterngeld ist ausgeschlossen ab einem zu versteuernden Jahreseinkommen von mehr als 200.000 Euro bei Alleinerziehenden, Paaren und getrennt Erziehenden. Diese Angabe finden Sie beispielsweise auf Ihrem Steuerbescheid. Wenn Sie Ihr Kind alleine erziehen, geben Sie nur Ihr eigenes Einkommen an. Als Paar oder getrennt erziehende Eltern rechnen Sie das Einkommen beider Elternteile zusammen."},mutterschaftsleistungen:{id:"info-14",text:/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("p",{children:"W\xE4hrend des Mutterschutzes erhalten Sie Mutterschaftsleistungen, zum Beispiel:"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("ul",{className:"list-disc pl-24",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"das Mutterschaftsgeld der gesetzlichen Krankenkassen"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"der Arbeitgeber-Zuschuss zum Mutterschaftsgeld"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"die Bez\xFCge f\xFCr Beamtinnen w\xE4hrend des Mutterschutzes"})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{children:"Diese werden \u2013 wenn ein Anspruch darauf besteht \u2013 normalerweise in den ersten acht Wochen nach der Geburt gezahlt."})]})}};
;// CONCATENATED MODULE: ./src/components/molecules/info-dialog/index.ts


/***/ }),

/***/ 2995:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  T: () => (/* reexport */ Page)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(2791);
var react_namespaceObject = /*#__PURE__*/__webpack_require__.t(react, 2);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(1418);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./src/components/atoms/index.ts + 35 modules
var atoms = __webpack_require__(2932);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(4164);
var react_dom_namespaceObject = /*#__PURE__*/__webpack_require__.t(react_dom, 2);
// EXTERNAL MODULE: ./node_modules/react-router/dist/index.js
var dist = __webpack_require__(7689);
// EXTERNAL MODULE: ./node_modules/@remix-run/router/dist/router.js
var router = __webpack_require__(8278);
;// CONCATENATED MODULE: ./node_modules/react-router-dom/dist/index.js
/**
 * React Router DOM v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */





function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
const defaultMethod = "get";
const defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (
  // Ignore everything but left clicks
  !target || target === "_self") &&
  // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event) // Ignore clicks with modifier keys
  ;
}
/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    // Use `defaultSearchParams.forEach(...)` here instead of iterating of
    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to
    // web extensions. Relevant Bugzilla tickets:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984
    defaultSearchParams.forEach((_, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach(value => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
// One-time check for submitter support
let _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(document.createElement("form"),
      // @ts-expect-error if FormData supports the submitter parameter, this will throw
      0);
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
const supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
     false ? 0 : void 0;
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    // When grabbing the action from the element, it will have had the basename
    // prefixed to ensure non-JS scenarios work, so strip it since we'll
    // re-prefix in the router
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
    }
    // <button>/<input type="submit"> may override attributes of <form>
    // When grabbing the action from the element, it will have had the basename
    // prefixed to ensure non-JS scenarios work, so strip it since we'll
    // re-prefix in the router
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    // Build a FormData object populated from a form and submitter
    formData = new FormData(form, target);
    // If this browser doesn't support the `FormData(el, submitter)` format,
    // then tack on the submitter value at the end.  This is a lightweight
    // solution that is not 100% spec compliant.  For complete support in older
    // browsers, consider using the `formdata-submitter-polyfill` package
    if (!isFormDataSubmitterSupported()) {
      let {
        name,
        type,
        value
      } = target;
      if (type === "image") {
        let prefix = name ? name + "." : "";
        formData.append(prefix + "x", "0");
        formData.append(prefix + "y", "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  // Send body for <Form encType="text/plain" so we encode it into text
  if (formData && encType === "text/plain") {
    body = formData;
    formData = undefined;
  }
  return {
    action,
    method: method.toLowerCase(),
    encType,
    formData,
    body
  };
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"],
  _excluded2 = (/* unused pure expression or super */ null && (["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"])),
  _excluded3 = (/* unused pure expression or super */ null && (["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"]));
// HEY YOU! DON'T TOUCH THIS VARIABLE!
//
// It is replaced with the proper version at build time via a babel plugin in
// the rollup config.
//
// Export a global property onto the window for React Router detection by the
// Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`
// to detect and properly classify live websites as being built with React Router:
// https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e) {
  // no-op
}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: _extends({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createBrowserHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes,
    mapRouteProperties: UNSAFE_mapRouteProperties,
    window: opts == null ? void 0 : opts.window
  }).initialize();
}
function createHashRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: _extends({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createHashHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes,
    mapRouteProperties: UNSAFE_mapRouteProperties,
    window: opts == null ? void 0 : opts.window
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = _extends({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    // Hey you!  If you change this, please change the corresponding logic in
    // serializeErrors in react-router-dom/server.tsx :)
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            // @ts-expect-error
            let error = new ErrorConstructor(val.message);
            // Wipe away the client-side stack trace.  Nothing to fill it in with
            // because we don't serialize SSR stack traces for security reasons
            error.stack = "";
            serialized[key] = error;
          } catch (e) {
            // no-op - fall through and create a normal Error
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        // Wipe away the client-side stack trace.  Nothing to fill it in with
        // because we don't serialize SSR stack traces for security reasons
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
const ViewTransitionContext = /*#__PURE__*/react.createContext({
  isTransitioning: false
});
if (false) {}
const FetchersContext = /*#__PURE__*/react.createContext(new Map());
if (false) {}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Components
////////////////////////////////////////////////////////////////////////////////
/**
  Webpack + React 17 fails to compile on any of the following because webpack
  complains that `startTransition` doesn't exist in `React`:
  * import { startTransition } from "react"
  * import * as React from from "react";
    "startTransition" in React ? React.startTransition(() => setState()) : setState()
  * import * as React from from "react";
    "startTransition" in React ? React["startTransition"](() => setState()) : setState()

  Moving it to a constant such as the following solves the Webpack/React 17 issue:
  * import * as React from from "react";
    const START_TRANSITION = "startTransition";
    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()

  However, that introduces webpack/terser minification issues in production builds
  in React 18 where minification/obfuscation ends up removing the call of
  React.startTransition entirely from the first half of the ternary.  Grabbing
  this exported reference once up front resolves that issue.

  See https://github.com/remix-run/react-router/issues/10579
*/
const START_TRANSITION = "startTransition";
const startTransitionImpl = react_namespaceObject[START_TRANSITION];
const FLUSH_SYNC = "flushSync";
const flushSyncImpl = react_dom_namespaceObject[FLUSH_SYNC];
const USE_ID = "useId";
const useIdImpl = react_namespaceObject[USE_ID];
function startTransitionSafe(cb) {
  if (startTransitionImpl) {
    startTransitionImpl(cb);
  } else {
    cb();
  }
}
function flushSyncSafe(cb) {
  if (flushSyncImpl) {
    flushSyncImpl(cb);
  } else {
    cb();
  }
}
class Deferred {
  constructor() {
    this.status = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolve = value => {
        if (this.status === "pending") {
          this.status = "resolved";
          resolve(value);
        }
      };
      this.reject = reason => {
        if (this.status === "pending") {
          this.status = "rejected";
          reject(reason);
        }
      };
    });
  }
}
/**
 * Given a Remix Router instance, render the appropriate UI
 */
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router,
    future
  } = _ref;
  let [state, setStateImpl] = React.useState(router.state);
  let [pendingState, setPendingState] = React.useState();
  let [vtContext, setVtContext] = React.useState({
    isTransitioning: false
  });
  let [renderDfd, setRenderDfd] = React.useState();
  let [transition, setTransition] = React.useState();
  let [interruption, setInterruption] = React.useState();
  let fetcherData = React.useRef(new Map());
  let {
    v7_startTransition
  } = future || {};
  let optInStartTransition = React.useCallback(cb => {
    if (v7_startTransition) {
      startTransitionSafe(cb);
    } else {
      cb();
    }
  }, [v7_startTransition]);
  let setState = React.useCallback((newState, _ref2) => {
    let {
      deletedFetchers,
      unstable_flushSync: flushSync,
      unstable_viewTransitionOpts: viewTransitionOpts
    } = _ref2;
    deletedFetchers.forEach(key => fetcherData.current.delete(key));
    newState.fetchers.forEach((fetcher, key) => {
      if (fetcher.data !== undefined) {
        fetcherData.current.set(key, fetcher.data);
      }
    });
    let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== "function";
    // If this isn't a view transition or it's not available in this browser,
    // just update and be done with it
    if (!viewTransitionOpts || isViewTransitionUnavailable) {
      if (flushSync) {
        flushSyncSafe(() => setStateImpl(newState));
      } else {
        optInStartTransition(() => setStateImpl(newState));
      }
      return;
    }
    // flushSync + startViewTransition
    if (flushSync) {
      // Flush through the context to mark DOM elements as transition=ing
      flushSyncSafe(() => {
        // Cancel any pending transitions
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
        }
        setVtContext({
          isTransitioning: true,
          flushSync: true,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      });
      // Update the DOM
      let t = router.window.document.startViewTransition(() => {
        flushSyncSafe(() => setStateImpl(newState));
      });
      // Clean up after the animation completes
      t.finished.finally(() => {
        flushSyncSafe(() => {
          setRenderDfd(undefined);
          setTransition(undefined);
          setPendingState(undefined);
          setVtContext({
            isTransitioning: false
          });
        });
      });
      flushSyncSafe(() => setTransition(t));
      return;
    }
    // startTransition + startViewTransition
    if (transition) {
      // Interrupting an in-progress transition, cancel and let everything flush
      // out, and then kick off a new transition from the interruption state
      renderDfd && renderDfd.resolve();
      transition.skipTransition();
      setInterruption({
        state: newState,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    } else {
      // Completed navigation update with opted-in view transitions, let 'er rip
      setPendingState(newState);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    }
  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);
  // Need to use a layout effect here so we are subscribed early enough to
  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)
  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  // When we start a view transition, create a Deferred we can use for the
  // eventual "completed" render
  React.useEffect(() => {
    if (vtContext.isTransitioning && !vtContext.flushSync) {
      setRenderDfd(new Deferred());
    }
  }, [vtContext]);
  // Once the deferred is created, kick off startViewTransition() to update the
  // DOM and then wait on the Deferred to resolve (indicating the DOM update has
  // happened)
  React.useEffect(() => {
    if (renderDfd && pendingState && router.window) {
      let newState = pendingState;
      let renderPromise = renderDfd.promise;
      let transition = router.window.document.startViewTransition(async () => {
        optInStartTransition(() => setStateImpl(newState));
        await renderPromise;
      });
      transition.finished.finally(() => {
        setRenderDfd(undefined);
        setTransition(undefined);
        setPendingState(undefined);
        setVtContext({
          isTransitioning: false
        });
      });
      setTransition(transition);
    }
  }, [optInStartTransition, pendingState, renderDfd, router.window]);
  // When the new location finally renders and is committed to the DOM, this
  // effect will run to resolve the transition
  React.useEffect(() => {
    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
      renderDfd.resolve();
    }
  }, [renderDfd, transition, state.location, pendingState]);
  // If we get interrupted with a new navigation during a transition, we skip
  // the active transition, let it cleanup, then kick it off again here
  React.useEffect(() => {
    if (!vtContext.isTransitioning && interruption) {
      setPendingState(interruption.state);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: interruption.currentLocation,
        nextLocation: interruption.nextLocation
      });
      setInterruption(undefined);
    }
  }, [vtContext.isTransitioning, interruption]);
  React.useEffect(() => {
     false ? 0 : void 0;
    // Only log this once on initial mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  let navigator = React.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state, opts) => router.navigate(to, {
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state, opts) => router.navigate(to, {
        replace: true,
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = React.useMemo(() => ({
    router,
    navigator,
    static: false,
    basename
  }), [router, navigator, basename]);
  // The fragment and {null} here are important!  We need them to keep React 18's
  // useId happy when we are server-rendering since we may have a <script> here
  // containing the hydrated server-side staticContext (from StaticRouterProvider).
  // useId relies on the component tree structure to generate deterministic id's
  // so we need to ensure it remains the same on the client even though
  // we don't need the <script> tag
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {
    value: dataRouterContext
  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {
    value: state
  }, /*#__PURE__*/React.createElement(FetchersContext.Provider, {
    value: fetcherData.current
  }, /*#__PURE__*/React.createElement(ViewTransitionContext.Provider, {
    value: vtContext
  }, /*#__PURE__*/React.createElement(Router, {
    basename: basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator,
    future: {
      v7_relativeSplatPath: router.future.v7_relativeSplatPath
    }
  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/React.createElement(DataRoutes, {
    routes: router.routes,
    future: router.future,
    state: state
  }) : fallbackElement))))), null);
}
function DataRoutes(_ref3) {
  let {
    routes,
    future,
    state
  } = _ref3;
  return UNSAFE_useRoutesImpl(routes, undefined, state, future);
}
/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window
  } = _ref4;
  let historyRef = React.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = React.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /*#__PURE__*/React.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future
  });
}
/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */
function HashRouter(_ref5) {
  let {
    basename,
    children,
    future,
    window
  } = _ref5;
  let historyRef = React.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = React.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /*#__PURE__*/React.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future
  });
}
/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */
function HistoryRouter(_ref6) {
  let {
    basename,
    children,
    future,
    history
  } = _ref6;
  let [state, setStateImpl] = React.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /*#__PURE__*/React.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future
  });
}
if (false) {}
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
/**
 * The public API for rendering a history-aware `<a>`.
 */
const Link = /*#__PURE__*/react.forwardRef(function LinkWithRef(_ref7, ref) {
  let {
      onClick,
      relative,
      reloadDocument,
      replace,
      state,
      target,
      to,
      preventScrollReset,
      unstable_viewTransition
    } = _ref7,
    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);
  let {
    basename
  } = react.useContext(dist/* UNSAFE_NavigationContext */.Us);
  // Rendered into <a href> for absolute URLs
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    // Render the absolute href server- and client-side
    absoluteHref = to;
    // Only check for external origins client-side
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = (0,router/* stripBasename */.Zn)(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          // Strip the protocol/origin/basename for same-origin absolute URLs
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e) {
        // We can't do external URL detection without a valid URL
         false ? 0 : void 0;
      }
    }
  }
  // Rendered into <a href> for relative URLs
  let href = (0,dist/* useHref */.oQ)(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative,
    unstable_viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return /*#__PURE__*/(
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    react.createElement("a", _extends({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref: ref,
      target: target
    }))
  );
});
if (false) {}
/**
 * A `<Link>` wrapper that knows if it's "active" or not.
 */
const NavLink = /*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef(function NavLinkWithRef(_ref8, ref) {
  let {
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      unstable_viewTransition,
      children
    } = _ref8,
    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = React.useContext(UNSAFE_DataRouterStateContext);
  let {
    navigator,
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  let isTransitioning = routerState != null &&
  // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(path) && unstable_viewTransition === true;
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename) {
    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
  }
  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,
  // we're looking for a slash _after_ what's in `to`.  For example:
  //
  // <NavLink to="/users"> and <NavLink to="/users/">
  // both want to look for a / at index 6 to match URL `/users/matt`
  const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let renderProps = {
    isActive,
    isPending,
    isTransitioning
  };
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps);
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to,
    unstable_viewTransition: unstable_viewTransition
  }), typeof children === "function" ? children(renderProps) : children);
})));
if (false) {}
/**
 * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
 * that the interaction with the server is with `fetch` instead of new document
 * requests, allowing components to add nicer UX to the page as the form is
 * submitted and returns with data.
 */
const Form = /*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef((_ref9, forwardedRef) => {
  let {
      fetcherKey,
      navigate,
      reloadDocument,
      replace,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      unstable_viewTransition
    } = _ref9,
    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);
  let submit = useSubmit();
  let formAction = useFormAction(action, {
    relative
  });
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let submitHandler = event => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      fetcherKey,
      method: submitMethod,
      navigate,
      replace,
      state,
      relative,
      preventScrollReset,
      unstable_viewTransition
    });
  };
  return /*#__PURE__*/React.createElement("form", _extends({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
})));
if (false) {}
/**
 * This component will emulate the browser's scroll restoration on location
 * changes.
 */
function ScrollRestoration(_ref10) {
  let {
    getKey,
    storageKey
  } = _ref10;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (false) {}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Hooks
////////////////////////////////////////////////////////////////////////////////
var DataRouterHook;
(function (DataRouterHook) {
  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook["UseSubmit"] = "useSubmit";
  DataRouterHook["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook["UseFetcher"] = "useFetcher";
  DataRouterHook["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function (DataRouterStateHook) {
  DataRouterStateHook["UseFetcher"] = "useFetcher";
  DataRouterStateHook["UseFetchers"] = "useFetchers";
  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
// Internal hooks
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = React.useContext(UNSAFE_DataRouterContext);
  !ctx ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = React.useContext(UNSAFE_DataRouterStateContext);
  !state ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  return state;
}
// External hooks
/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    unstable_viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = (0,dist/* useNavigate */.s0)();
  let location = (0,dist/* useLocation */.TH)();
  let path = (0,dist/* useResolvedPath */.WU)(to, {
    relative
  });
  return react.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here unless the replace prop is explicitly set
      let replace = replaceProp !== undefined ? replaceProp : (0,router/* createPath */.Ep)(location) === (0,router/* createPath */.Ep)(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative,
        unstable_viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */
function useSearchParams(defaultInit) {
   false ? 0 : void 0;
  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = React.useRef(false);
  let location = useLocation();
  let searchParams = React.useMemo(() =>
  // Only merge in the defaults if we haven't yet called setSearchParams.
  // Once we call that we want those to take precedence, otherwise you can't
  // remove a param with setSearchParams({}) if it has an initial value
  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
function validateClientSideSubmission() {
  if (typeof document === "undefined") {
    throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
  }
}
let fetcherId = 0;
let getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";
/**
 * Returns a function that may be used to programmatically submit a form (or
 * some arbitrary data) to the server.
 */
function useSubmit() {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseSubmit);
  let {
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  let currentRouteId = UNSAFE_useRouteId();
  return React.useCallback(function (target, options) {
    if (options === void 0) {
      options = {};
    }
    validateClientSideSubmission();
    let {
      action,
      method,
      encType,
      formData,
      body
    } = getFormSubmissionInfo(target, basename);
    if (options.navigate === false) {
      let key = options.fetcherKey || getUniqueFetcherId();
      router.fetch(key, currentRouteId, options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        unstable_flushSync: options.unstable_flushSync
      });
    } else {
      router.navigate(options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        replace: options.replace,
        state: options.state,
        fromRouteId: currentRouteId,
        unstable_flushSync: options.unstable_flushSync,
        unstable_viewTransition: options.unstable_viewTransition
      });
    }
  }, [router, basename, currentRouteId]);
}
// v7: Eventually we should deprecate this entirely in favor of using the
// router method directly?
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  let routeContext = React.useContext(UNSAFE_RouteContext);
  !routeContext ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  let [match] = routeContext.matches.slice(-1);
  // Shallow clone path so we can modify it below, otherwise we modify the
  // object referenced by useMemo inside useResolvedPath
  let path = _extends({}, useResolvedPath(action ? action : ".", {
    relative
  }));
  // If no action was specified, browsers will persist current search params
  // when determining the path, so match that behavior
  // https://github.com/remix-run/remix/issues/927
  let location = useLocation();
  if (action == null) {
    // Safe to write to this directly here since if action was undefined, we
    // would have called useResolvedPath(".") which will never include a search
    path.search = location.search;
    // When grabbing search params from the URL, remove any included ?index param
    // since it might not apply to our contextual route.  We add it back based
    // on match.route.index below
    let params = new URLSearchParams(path.search);
    if (params.has("index") && params.get("index") === "") {
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  // If we're operating within a basename, prepend it to the pathname prior
  // to creating the form action.  If this is a root navigation, then just use
  // the raw basename which allows the basename to have full control over the
  // presence of a trailing slash on root actions
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`
/**
 * Interacts with route loaders and actions without causing a navigation. Great
 * for any interaction that stays on the same page.
 */
function useFetcher(_temp3) {
  var _route$matches;
  let {
    key
  } = _temp3 === void 0 ? {} : _temp3;
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseFetcher);
  let state = useDataRouterState(DataRouterStateHook.UseFetcher);
  let fetcherData = React.useContext(FetchersContext);
  let route = React.useContext(UNSAFE_RouteContext);
  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
  !fetcherData ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  !route ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  !(routeId != null) ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  // Fetcher key handling
  // OK to call conditionally to feature detect `useId`
  // eslint-disable-next-line react-hooks/rules-of-hooks
  let defaultKey = useIdImpl ? useIdImpl() : "";
  let [fetcherKey, setFetcherKey] = React.useState(key || defaultKey);
  if (key && key !== fetcherKey) {
    setFetcherKey(key);
  } else if (!fetcherKey) {
    // We will only fall through here when `useId` is not available
    setFetcherKey(getUniqueFetcherId());
  }
  // Registration/cleanup
  React.useEffect(() => {
    router.getFetcher(fetcherKey);
    return () => {
      // Tell the router we've unmounted - if v7_fetcherPersist is enabled this
      // will not delete immediately but instead queue up a delete after the
      // fetcher returns to an `idle` state
      router.deleteFetcher(fetcherKey);
    };
  }, [router, fetcherKey]);
  // Fetcher additions
  let load = React.useCallback((href, opts) => {
    !routeId ?  false ? 0 : UNSAFE_invariant(false) : void 0;
    router.fetch(fetcherKey, routeId, href, opts);
  }, [fetcherKey, routeId, router]);
  let submitImpl = useSubmit();
  let submit = React.useCallback((target, opts) => {
    submitImpl(target, _extends({}, opts, {
      navigate: false,
      fetcherKey
    }));
  }, [fetcherKey, submitImpl]);
  let FetcherForm = React.useMemo(() => {
    let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {
      return /*#__PURE__*/React.createElement(Form, _extends({}, props, {
        navigate: false,
        fetcherKey: fetcherKey,
        ref: ref
      }));
    });
    if (false) {}
    return FetcherForm;
  }, [fetcherKey]);
  // Exposed FetcherWithComponents
  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;
  let data = fetcherData.get(fetcherKey);
  let fetcherWithComponents = React.useMemo(() => _extends({
    Form: FetcherForm,
    submit,
    load
  }, fetcher, {
    data
  }), [FetcherForm, submit, load, fetcher, data]);
  return fetcherWithComponents;
}
/**
 * Provides all fetchers currently on the page. Useful for layouts and parent
 * routes that need to provide pending/optimistic UI regarding the fetch.
 */
function useFetchers() {
  let state = useDataRouterState(DataRouterStateHook.UseFetchers);
  return Array.from(state.fetchers.entries()).map(_ref11 => {
    let [key, fetcher] = _ref11;
    return _extends({}, fetcher, {
      key
    });
  });
}
const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
let savedScrollPositions = {};
/**
 * When rendered inside a RouterProvider, will restore scroll positions on navigations
 */
function useScrollRestoration(_temp4) {
  let {
    getKey,
    storageKey
  } = _temp4 === void 0 ? {} : _temp4;
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);
  let {
    basename
  } = React.useContext(UNSAFE_NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  // Trigger manual scroll restoration while we're active
  React.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  // Save positions on pagehide
  usePageHide(React.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    try {
      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    } catch (error) {
       false ? 0 : void 0;
    }
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches]));
  // Read in any saved scroll locations
  if (typeof document !== "undefined") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {
        // no-op, use default empty object
      }
    }, [storageKey]);
    // Enable scroll restoration in the router
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useLayoutEffect(() => {
      let getKeyWithoutBasename = getKey && basename !== "/" ? (location, matches) => getKey(
      // Strip the basename to match useLocation()
      _extends({}, location, {
        pathname: stripBasename(location.pathname, basename) || location.pathname
      }), matches) : getKey;
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, basename, getKey]);
    // Restore scrolling when state.restoreScrollPosition changes
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useLayoutEffect(() => {
      // Explicit false means don't do anything (used for submissions)
      if (restoreScrollPosition === false) {
        return;
      }
      // been here before, scroll to it
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      // try to scroll to the hash
      if (location.hash) {
        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      // Don't reset if this navigation opted out
      if (preventScrollReset === true) {
        return;
      }
      // otherwise go to the top on new locations
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
/**
 * Setup a callback to be fired on the window's `beforeunload` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */
function useBeforeUnload(callback, options) {
  let {
    capture
  } = options || {};
  React.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : undefined;
    window.addEventListener("beforeunload", callback, opts);
    return () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
/**
 * Setup a callback to be fired on the window's `pagehide` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.  This event is better supported than beforeunload across browsers.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */
function usePageHide(callback, options) {
  let {
    capture
  } = options || {};
  React.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : undefined;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
/**
 * Wrapper around useBlocker to show a window.confirm prompt to users instead
 * of building a custom UI with useBlocker.
 *
 * Warning: This has *a lot of rough edges* and behaves very differently (and
 * very incorrectly in some cases) across browsers if user click addition
 * back/forward navigations while the confirm is open.  Use at your own risk.
 */
function usePrompt(_ref12) {
  let {
    when,
    message
  } = _ref12;
  let blocker = useBlocker(when);
  React.useEffect(() => {
    if (blocker.state === "blocked") {
      let proceed = window.confirm(message);
      if (proceed) {
        // This timeout is needed to avoid a weird "race" on POP navigations
        // between the `window.history` revert navigation and the result of
        // `window.confirm`
        setTimeout(blocker.proceed, 0);
      } else {
        blocker.reset();
      }
    }
  }, [blocker, message]);
  React.useEffect(() => {
    if (blocker.state === "blocked" && !when) {
      blocker.reset();
    }
  }, [blocker, when]);
}
/**
 * Return a boolean indicating if there is an active view transition to the
 * given href.  You can use this value to render CSS classes or viewTransitionName
 * styles onto your elements
 *
 * @param href The destination href
 * @param [opts.relative] Relative routing type ("route" | "path")
 */
function useViewTransitionState(to, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let vtContext = React.useContext(ViewTransitionContext);
  !(vtContext != null) ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  let {
    basename
  } = useDataRouterContext(DataRouterHook.useViewTransitionState);
  let path = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  // Transition is active if we're going to or coming from the indicated
  // destination.  This ensures that other PUSH navigations that reverse
  // an indicated transition apply.  I.e., on the list view you have:
  //
  //   <NavLink to="/details/1" unstable_viewTransition>
  //
  // If you click the breadcrumb back to the list view:
  //
  //   <NavLink to="/list" unstable_viewTransition>
  //
  // We should apply the transition because it's indicated as active going
  // from /list -> /details/1 and therefore should be active on the reverse
  // (even though this isn't strictly a POP reverse)
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
//#endregion


// EXTERNAL MODULE: ./node_modules/@digitalservicebund/icons/ExpandLess.js
var ExpandLess = __webpack_require__(8096);
var ExpandLess_default = /*#__PURE__*/__webpack_require__.n(ExpandLess);
// EXTERNAL MODULE: ./node_modules/@digitalservicebund/icons/ExpandMore.js
var ExpandMore = __webpack_require__(9068);
var ExpandMore_default = /*#__PURE__*/__webpack_require__.n(ExpandMore);
// EXTERNAL MODULE: ./src/globals/js/namespace.js + 1 modules
var namespace = __webpack_require__(9242);
// EXTERNAL MODULE: ./src/utils/formSteps.ts
var formSteps = __webpack_require__(8137);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(184);
;// CONCATENATED MODULE: ./src/components/organisms/sidebar/Sidebar.tsx
function Sidebar(_ref){let{currentStep}=_ref;const[isOpen,setIsOpen]=(0,react.useState)(false);const currentStepIndex=Object.values(formSteps/* formSteps */.w).findIndex(step=>step===currentStep);const stepsTotal=Object.entries(formSteps/* formSteps */.w).length;const stepLabel="".concat(currentStepIndex+1,"/").concat(stepsTotal);const buttonLabel=/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:stepLabel}),currentStep.text]});return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:classnames_default()((0,namespace/* default */.Z)("sidebar")),children:[/*#__PURE__*/(0,jsx_runtime.jsx)(atoms/* Button */.zx,{className:(0,namespace/* default */.Z)("sidebar__collapse-btn"),onClick:()=>setIsOpen(!isOpen),label:buttonLabel,iconAfter:isOpen?/*#__PURE__*/(0,jsx_runtime.jsx)((ExpandLess_default()),{}):/*#__PURE__*/(0,jsx_runtime.jsx)((ExpandMore_default()),{})}),/*#__PURE__*/(0,jsx_runtime.jsx)("ol",{className:classnames_default()((0,namespace/* default */.Z)("sidebar-list"),isOpen&&(0,namespace/* default */.Z)("sidebar-list--open")),children:Object.values(formSteps/* formSteps */.w).map((step,index)=>/*#__PURE__*/(0,jsx_runtime.jsx)("li",{className:classnames_default()((0,namespace/* default */.Z)("sidebar-list__step"),index<currentStepIndex&&(0,namespace/* default */.Z)("sidebar-list__step--done"),step===currentStep&&(0,namespace/* default */.Z)("sidebar-list__step--current")),children:/*#__PURE__*/(0,jsx_runtime.jsx)(Link,{to:step.route,children:step.text})},index))})]});}
;// CONCATENATED MODULE: ./src/components/organisms/sidebar/index.ts

;// CONCATENATED MODULE: ./src/components/organisms/page/Page.tsx
function Page(_ref){let{step,children}=_ref;// scroll to top on page navigation
(0,react.useEffect)(()=>{window.scrollTo({top:0,behavior:"smooth"});},[]);return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:(0,namespace/* default */.Z)("page"),children:[/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:(0,namespace/* default */.Z)("page__sidebar"),children:/*#__PURE__*/(0,jsx_runtime.jsx)(Sidebar,{currentStep:step})}),/*#__PURE__*/(0,jsx_runtime.jsx)(atoms/* AriaMessage */.ye,{children:step.text}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:classnames_default()((0,namespace/* default */.Z)("page__content"),"relative"),id:step.text,children:children})]});}
;// CONCATENATED MODULE: ./src/components/organisms/page/index.ts


/***/ }),

/***/ 417:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ KindUtil)
/* harmony export */ });
/**
 * {@link Kind} utility functions and constants.
 */let KindUtil;(function(_KindUtil){function findLastBornChild(kindList){if(kindList.length===0){return undefined;}// wenn nur ein Kind enthalten ist, dann brauchen wir nicht zu sortieren
if(kindList.length===1){return kindList[0];}const cleanKindList=sortByGeburtsdatumExcludesFutureChildren(kindList);return cleanKindList[cleanKindList.length-1];}_KindUtil.findLastBornChild=findLastBornChild;function findSecondLastBornChild(kindList){if(kindList.length<2){return undefined;}const cleanKindList=sortByGeburtsdatumExcludesFutureChildren(kindList);return cleanKindList[cleanKindList.length-2];}_KindUtil.findSecondLastBornChild=findSecondLastBornChild;const sortByGeburtsdatum=kindList=>{return kindList.sort((a,b)=>{var _a$geburtsdatum,_b$geburtsdatum;if(a.geburtsdatum===undefined){if(b.geburtsdatum===undefined){return 0;}return-1;}if(b.geburtsdatum===undefined){return 1;}return((_a$geburtsdatum=a.geburtsdatum)===null||_a$geburtsdatum===void 0?void 0:_a$geburtsdatum.valueOf())-((_b$geburtsdatum=b.geburtsdatum)===null||_b$geburtsdatum===void 0?void 0:_b$geburtsdatum.valueOf());});};const excludesFutureChildren=_KindUtil.excludesFutureChildren=kindList=>kindList.filter(value=>value.geburtsdatum!==undefined);const sortByGeburtsdatumExcludesFutureChildren=kindList=>sortByGeburtsdatum(excludesFutureChildren(kindList));})(KindUtil||(KindUtil={}));

/***/ }),

/***/ 7895:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ MathUtil)
/* harmony export */ });
/* harmony import */ var big_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8113);
/**
 * Math utility functions and constants.
 */let MathUtil;(function(_MathUtil){const BIG_ZERO=_MathUtil.BIG_ZERO=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(0);const BIG_ONE=_MathUtil.BIG_ONE=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(1);const BIG_100=_MathUtil.BIG_100=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(100);function round(value){let scale=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2;return value.round(scale,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.roundHalfUp);}_MathUtil.round=round;function floor(b){if(b.lt(BIG_ZERO)){return b.round(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.roundUp);}else{return b.round(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.roundDown);}}_MathUtil.floor=floor;function fMin(a,b){return a.lte(b)?a:b;}_MathUtil.fMin=fMin;function fMax(a,b){return a.gte(b)?a:b;}_MathUtil.fMax=fMax;function isEqual(a,b){return a.eq(b);}_MathUtil.isEqual=isEqual;function greater(a,b){return a.gt(b);}_MathUtil.greater=greater;function lessOrEqual(a,b){return a.lte(b);}_MathUtil.lessOrEqual=lessOrEqual;})(MathUtil||(MathUtil={}));

/***/ }),

/***/ 4223:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ EgrBerechnungParamId)
/* harmony export */ });
/* harmony import */ var big_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8113);
/**
 * Constants for Elterngeld calculation.
 *
 * Why a namespace? In Java it was an enum. IMHO are constants with namespace a good replacement.
 */let EgrBerechnungParamId;(function(_EgrBerechnungParamId){const F_FAKTOR=_EgrBerechnungParamId.F_FAKTOR=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(0.7509);const SATZ_KVPV_BEEG=_EgrBerechnungParamId.SATZ_KVPV_BEEG=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(0.09);const SATZ_RV_BEEG=_EgrBerechnungParamId.SATZ_RV_BEEG=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(0.1);const SATZ_ALV_BEEG=_EgrBerechnungParamId.SATZ_ALV_BEEG=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(0.02);const BETRAG_MEHRLINGSZUSCHLAG=_EgrBerechnungParamId.BETRAG_MEHRLINGSZUSCHLAG=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(300);const MIN_GESCHWISTERBONUS=_EgrBerechnungParamId.MIN_GESCHWISTERBONUS=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(75);const RATE_BONUS=_EgrBerechnungParamId.RATE_BONUS=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(0.1);const ERSATZRATE1=_EgrBerechnungParamId.ERSATZRATE1=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(0.67);const ERSATZRATE2=_EgrBerechnungParamId.ERSATZRATE2=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(0.65);const HOECHSTSATZ=_EgrBerechnungParamId.HOECHSTSATZ=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(1800);const MINDESTSATZ=_EgrBerechnungParamId.MINDESTSATZ=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(300);const GRENZE1=_EgrBerechnungParamId.GRENZE1=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(1240);const GRENZE2=_EgrBerechnungParamId.GRENZE2=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(1200);const GRENZE3=_EgrBerechnungParamId.GRENZE3=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(1000);const HOECHST_ET=_EgrBerechnungParamId.HOECHST_ET=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(2770);const GRENZE_MINI_MIDI=_EgrBerechnungParamId.GRENZE_MINI_MIDI=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(520);const GRENZE_MIDI_MAX=_EgrBerechnungParamId.GRENZE_MIDI_MAX=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(1300);const PAUSCH=_EgrBerechnungParamId.PAUSCH=(0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(1000).div((0,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(12)).prec(big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.DP,big_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z.RM);const MAX_EINKOMMEN_ALLEIN=_EgrBerechnungParamId.MAX_EINKOMMEN_ALLEIN=200000;const MAX_EINKOMMEN_BEIDE=_EgrBerechnungParamId.MAX_EINKOMMEN_BEIDE=200000;})(EgrBerechnungParamId||(EgrBerechnungParamId={}));

/***/ }),

/***/ 3444:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  kd: () => (/* reexport */ egr_berechnung_param_id/* EgrBerechnungParamId */.k),
  $J: () => (/* reexport */ Einkommen),
  Tc: () => (/* reexport */ ElternGeldArt),
  eK: () => (/* reexport */ ElternGeldKategorie),
  $h: () => (/* reexport */ ErwerbsArt),
  uA: () => (/* reexport */ ErwerbsTaetigkeit),
  dq: () => (/* reexport */ ErwerbsZeitraumLebensMonat),
  Bf: () => (/* reexport */ FinanzDaten),
  TN: () => (/* reexport */ KassenArt),
  uy: () => (/* reexport */ KinderFreiBetrag),
  u4: () => (/* reexport */ MischEkTaetigkeit),
  "do": () => (/* reexport */ MutterschaftsLeistung),
  Ev: () => (/* reexport */ PLANUNG_ANZAHL_MONATE),
  J4: () => (/* reexport */ PersoenlicheDaten),
  y7: () => (/* reexport */ PlanungsDaten),
  d0: () => (/* reexport */ RentenArt),
  nf: () => (/* reexport */ SteuerKlasse),
  l: () => (/* reexport */ YesNo),
  uk: () => (/* reexport */ finanzDatenOf),
  W9: () => (/* reexport */ kinderFreiBetragToNumber),
  Wm: () => (/* reexport */ mutterschaftsLeistungInMonaten),
  G0: () => (/* reexport */ persoenlicheDatenOf),
  Dj: () => (/* reexport */ steuerklasseToNumber),
  fc: () => (/* reexport */ zaehleMonateErwerbsTaetigkeit)
});

// UNUSED EXPORTS: createMischEkTaetigkeitOf, kinderFreiBetragOfNumber, steuerklasseOfNumber

;// CONCATENATED MODULE: ./src/globals/js/calculations/model/yes-no.ts
let YesNo=/*#__PURE__*/function(YesNo){YesNo["YES"]="YES";YesNo["NO"]="NO";return YesNo;}({});
// EXTERNAL MODULE: ./src/globals/js/calculations/common/math-util.ts
var math_util = __webpack_require__(7895);
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/misch-ek-taetigkeit.ts
/**
 * Enthält die Daten zu einer Tätigkeit bei Mischeinkommen.
 */let ErwerbsTaetigkeit=/*#__PURE__*/function(ErwerbsTaetigkeit){ErwerbsTaetigkeit["SELBSTSTAENDIG"]="SELBSTSTAENDIG";ErwerbsTaetigkeit["NICHT_SELBSTSTAENDIG"]="NICHT_SELBSTSTAENDIG";ErwerbsTaetigkeit["MINIJOB"]="MINIJOB";return ErwerbsTaetigkeit;}({});const ANZAHL_MONATE_PRO_JAHR=12;class MischEkTaetigkeit{constructor(){let falseOrTrue=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.erwerbsTaetigkeit=ErwerbsTaetigkeit.NICHT_SELBSTSTAENDIG;this.bruttoEinkommenDurchschnitt=math_util/* MathUtil */.k.BIG_ZERO;this.bruttoEinkommenDurchschnittMidi=math_util/* MathUtil */.k.BIG_ZERO;this.bemessungsZeitraumMonate=[];this.rentenVersicherungsPflichtig=YesNo.YES;this.krankenVersicherungsPflichtig=YesNo.YES;this.arbeitslosenVersicherungsPflichtig=YesNo.YES;this.bemessungsZeitraumMonate=new Array(ANZAHL_MONATE_PRO_JAHR).fill(falseOrTrue);}getAnzahlBemessungsZeitraumMonate(){return this.bemessungsZeitraumMonate.filter(value=>value).length;}}const createMischEkTaetigkeitOf=(erwerbsTaetigkeit,bruttoEinkommenDurchschnitt,bemessungsZeitraumMonate,rentenVersicherungsPflichtig,krankenVersicherungsPflichtig,arbeitslosenVersicherungsPflichtig)=>{const m=new MischEkTaetigkeit(false);m.erwerbsTaetigkeit=erwerbsTaetigkeit;m.bruttoEinkommenDurchschnitt=bruttoEinkommenDurchschnitt;m.bemessungsZeitraumMonate=bemessungsZeitraumMonate;m.rentenVersicherungsPflichtig=rentenVersicherungsPflichtig;m.krankenVersicherungsPflichtig=krankenVersicherungsPflichtig;m.arbeitslosenVersicherungsPflichtig=arbeitslosenVersicherungsPflichtig;return m;};
// EXTERNAL MODULE: ./src/globals/js/calculations/model/egr-berechnung-param-id.ts
var egr_berechnung_param_id = __webpack_require__(4223);
// EXTERNAL MODULE: ./node_modules/big.js/big.mjs
var big = __webpack_require__(8113);
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/einkommen.ts
/**
 * Einkommen with correct precision fraction 2.
 */class Einkommen{constructor(value){this._value=(0,big/* default */.Z)(0);this.value=value;}set value(value){this._value=(0,big/* default */.Z)(value).round(2,big/* default */.Z.roundHalfUp);}get value(){return this._value;}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/eltern-geld-art.ts
/**
 * Enumeration von ElterngeldArten
 */let ElternGeldArt=/*#__PURE__*/function(ElternGeldArt){ElternGeldArt["KEIN_BEZUG"]="KEIN_BEZUG";ElternGeldArt["BASIS_ELTERNGELD"]="BASIS_ELTERNGELD";ElternGeldArt["ELTERNGELD_PLUS"]="ELTERNGELD_PLUS";ElternGeldArt["PARTNERSCHAFTS_BONUS"]="PARTNERSCHAFTS_BONUS";return ElternGeldArt;}({});
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/eltern-geld-kategorie.ts
let ElternGeldKategorie=/*#__PURE__*/function(ElternGeldKategorie){ElternGeldKategorie[ElternGeldKategorie["KEIN_ELTERN_GELD"]=0]="KEIN_ELTERN_GELD";ElternGeldKategorie[ElternGeldKategorie["BASIS_ELTERN_GELD"]=1]="BASIS_ELTERN_GELD";ElternGeldKategorie[ElternGeldKategorie["BASIS_ELTERN_GELD_MIT_ERWERBS_TAETIGKEIT"]=2]="BASIS_ELTERN_GELD_MIT_ERWERBS_TAETIGKEIT";ElternGeldKategorie[ElternGeldKategorie["ELTERN_GELD_PLUS_OHNE_ERWERBS_TAETIGKEIT"]=3]="ELTERN_GELD_PLUS_OHNE_ERWERBS_TAETIGKEIT";ElternGeldKategorie[ElternGeldKategorie["ELTERN_GELD_PLUS_MIT_ERWERBS_TAETIGKEIT"]=4]="ELTERN_GELD_PLUS_MIT_ERWERBS_TAETIGKEIT";return ElternGeldKategorie;}({});
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/erwerbs-art.ts
let ErwerbsArt=/*#__PURE__*/function(ErwerbsArt){ErwerbsArt["NEIN"]="NEIN";ErwerbsArt["JA_SELBSTSTAENDIG"]="JA_SELBSTSTAENDIG";ErwerbsArt["JA_NICHT_SELBST_MIT_SOZI"]="JA_NICHT_SELBST_MIT_SOZI";ErwerbsArt["JA_NICHT_SELBST_MINI"]="JA_NICHT_SELBST_MINI";ErwerbsArt["JA_NICHT_SELBST_OHNE_SOZI"]="JA_NICHT_SELBST_OHNE_SOZI";ErwerbsArt["JA_MISCHEINKOMMEN"]="JA_MISCHEINKOMMEN";return ErwerbsArt;}({});
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/planungs-daten.ts
/**
 * Anzahl der Lebensmonate, die im Planer dargestellt werden.
 */const PLANUNG_ANZAHL_MONATE=32;class PlanungsDaten{constructor(alleinerziehend,erwerbsStatus,partnerBonus,mutterschaftsLeistung){/**
   * Gibt an, ob der Partner alleinerziehend ist.
   */this.alleinerziehend=void 0;/**
   * Gibt an, ob der Partner vor der Geburt erwerbstätig ist.
   */this.erwerbsStatus=void 0;/**
   * Gibt an, ob der Partner die Voraussetzungen für den Partnerbonus erfällt.
   */this.partnerBonus=void 0;/**
   * Gibt an, ob und wie lange Mutterschafstleistungen bezogen werden.
   */this.mutterschaftsLeistung=void 0;/**
   * Liste der Elterngeldmonate für die Planung (unveränderliche Länge: Anzahl der Monate, die im Planer dargestellt
   * werden
   */this.planung=void 0;this.alleinerziehend=alleinerziehend;this.erwerbsStatus=erwerbsStatus;this.partnerBonus=partnerBonus;this.mutterschaftsLeistung=mutterschaftsLeistung;this.planung=PlanungsDaten.createEmptyPlanung();}// public isAlleinerziehendJN(): boolean {
//   return this.getAlleinerziehend() === de.init.anton.plugins.egr.fwl.YesNo.YES;
// }
//
// public isErwerbstaetigJN(): boolean {
//   return this.getErwerbstatus() === de.init.anton.plugins.egr.fwl.YesNo.YES;
// }
//
// public isEmptyPlanung(): boolean {
//   for (let index = 0; index < this.planung.length; index++) {
//     let monat = this.planung[index];
//     {
//       if (monat.getElterngeldArt() !== de.init.anton.plugins.egr.fwl.ElterngeldArt.KEIN_BEZUG) {
//         return false;
//       }
//     }
//   }
//   return true;
// }
//
// public hasPartnerbonusJN(): boolean {
//   return this.partnerbonus === de.init.anton.plugins.egr.fwl.YesNo.YES;
// }
//
// public getPlanungIntList(): Array<number> {
//   const intList: Array<number> = <any>([]);
//   for (let index = 0; index < this.planung.length; index++) {
//     let monat = this.planung[index];
//     {
//       /* add */
//       (intList.push(de.init.anton.plugins.egr.fwl.ElterngeldArt["_$wrappers"][monat.getElterngeldArt()].getIndex()) > 0);
//     }
//   }
//   return intList;
// }
//
// /**
//  * Planungswerte als String, Javascript FunktionalitÃ¤t greift hierauf zu.
//  *
//  * @return
//  * @return {string}
//  */
// public getPlanungValues(): string {
//   if (this.planung == null || /* isEmpty */(this.planung.length == 0)) {
//     return this.createEmptyPlanung();
//   }
//   const sb: { str: string, toString: Function } = {
//     str: "", toString: function () {
//       return this.str;
//     }
//   };
//   for (let index = 0; index < this.planung.length; index++) {
//     let monat = this.planung[index];
//     {
//       /* append */
//       (sb => {
//         sb.str += <any>de.init.anton.plugins.egr.fwl.ElterngeldArt["_$wrappers"][monat.getElterngeldArt()].getIndex();
//         return sb;
//       })(sb);
//       /* append */
//       (sb => {
//         sb.str += <any>",";
//         return sb;
//       })(sb);
//     }
//   }
//   return this.cutLastComma(/* toString */sb.str);
// }
//
// /*private*/
// cutLastComma(values: string): string {
//   if (values == null) {
//     values = "";
//   }
//   if (/* endsWith */((str, searchString) => {
//     let pos = str.length - searchString.length;
//     let lastIndex = str.indexOf(searchString, pos);
//     return lastIndex !== -1 && lastIndex === pos;
//   })(values, ",") && values.length >= 2) {
//     values = values.substring(0, values.length - 1);
//   } else {
//     values = /* replace */values.split(",").join("");
//   }
//   return values;
// }
//
// public setPlanungValues$java_util_List(listPlanungIdx: Array<number>) {
//   if (listPlanungIdx != null && !/* isEmpty */(listPlanungIdx.length == 0)) {
//     let lebensMonat: number = 0;
//     for (let index = 0; index < listPlanungIdx.length; index++) {
//       let idx = listPlanungIdx[index];
//       {
//         if (idx >= 0 && idx <= 3) {
//           this.set(++lebensMonat, /* Enum.values */function () {
//             let result: de.init.anton.plugins.egr.fwl.ElterngeldArt[] = [];
//             for (let val in de.init.anton.plugins.egr.fwl.ElterngeldArt) {
//               if (!isNaN(<any>val)) {
//                 result.push(parseInt(val, 10));
//               }
//             }
//             return result;
//           }()[idx]);
//         } else {
//         }
//       }
//     }
//   }
// }
//
// public setPlanungValues$java_lang_String(planungValues: string) {
//   this.setPlanungValues$java_lang_String$java_lang_String(planungValues, ",");
// }
//
// public setPlanungValues$java_lang_String$java_lang_String(planungValues: string, splitRegEx: string) {
//   const planungValuesArray: string[] = planungValues.split(splitRegEx);
//   if (planungValuesArray.length !== Planungsdaten.ANZAHL_MONATE) {
//   }
//   let lebensMonat: number = 0;
//   for (let index = 0; index < planungValuesArray.length; index++) {
//     let value = planungValuesArray[index];
//     {
//       const elterngeldIndex: number = /* parseInt */parseInt(value);
//       if (elterngeldIndex >= 0 && elterngeldIndex <= 3) {
//         this.set(++lebensMonat, /* Enum.values */function () {
//           let result: de.init.anton.plugins.egr.fwl.ElterngeldArt[] = [];
//           for (let val in de.init.anton.plugins.egr.fwl.ElterngeldArt) {
//             if (!isNaN(<any>val)) {
//               result.push(parseInt(val, 10));
//             }
//           }
//           return result;
//         }()[elterngeldIndex]);
//       } else {
//       }
//     }
//   }
// }
//
// public setPlanungValues(planungValues?: any, splitRegEx?: any) {
//   if (((typeof planungValues === 'string') || planungValues === null) && ((typeof splitRegEx === 'string') || splitRegEx === null)) {
//     return <any>this.setPlanungValues$java_lang_String$java_lang_String(planungValues, splitRegEx);
//   } else if (((planungValues != null && (planungValues instanceof Array)) || planungValues === null) && splitRegEx === undefined) {
//     return <any>this.setPlanungValues$java_util_List(planungValues);
//   } else if (((typeof planungValues === 'string') || planungValues === null) && splitRegEx === undefined) {
//     return <any>this.setPlanungValues$java_lang_String(planungValues);
//   } else throw new Error('invalid overload');
// }
//
// /*private*/
// createEmptyPlanung(): string {
//   const sb: { str: string, toString: Function } = {
//     str: "", toString: function () {
//       return this.str;
//     }
//   };
//   for (let i: number = 1; i <= Planungsdaten.ANZAHL_MONATE; i++) {
//     {
//       /* append */
//       (sb => {
//         sb.str += <any>"0,";
//         return sb;
//       })(sb);
//     }
//     ;
//   }
//   const result: string = /* toString */sb.str.substring(0, /* toString */sb.str.length - 2);
//   return result;
// }
//
/**
   * Gibt die Elterngeldart für einen anhand des Index spezifizierten Monats zurück.
   *
   * @param {number} lebensMonat Lebensmonat des Kindes (nicht Index!!!)
   * @return {ElternGeldArt} ElterngeldArt des abgefragten Monats
   */get(lebensMonat){const index=lebensMonat-1;if(lebensMonat>PLANUNG_ANZAHL_MONATE){return ElternGeldArt.KEIN_BEZUG;}return this.planung[index];}// public getPlanungBezugsarten(): Array<de.init.anton.plugins.egr.fwl.ElterngeldArt> {
//   const result: Array<de.init.anton.plugins.egr.fwl.ElterngeldArt> = <any>([]);
//   {
//     let array = this.getPlanung();
//     for (let index = 0; index < array.length; index++) {
//       let monat = array[index];
//       {
//         /* add */
//         (result.push(monat.getElterngeldArt()) > 0);
//       }
//     }
//   }
//   return result;
// }
static createEmptyPlanung(){const planungList=[];for(let i=0;i<PLANUNG_ANZAHL_MONATE;i++){planungList[i]=ElternGeldArt.KEIN_BEZUG;}return planungList;}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/erwerbs-zeitraum-lebens-monat.ts
/**
 * Erwerbszeitraum für Einkommen NACH der Geburt.
 */class ErwerbsZeitraumLebensMonat{constructor(){this.vonLebensMonat=0;this.bisLebensMonat=0;this.bruttoProMonat=new Einkommen(0);}// TODO TW prüfen, ob die Felder noch benötigt werden.
// nettoProMonat: NettoEinkommen = new Einkommen(0);
// endeEGPeriode: number | null = null;
// anfangEGPeriode: number | null = null;
getAnzahlMonate(){if(!this.isVonEqualOrLessBis()||this.isLMTooHigh()||this.isLMTooSmall()){return 0;}return this.bisLebensMonat-this.vonLebensMonat+1;}getLebensMonateList(){if(!this.isVonEqualOrLessBis()||this.isLMTooHigh()||this.isLMTooSmall()){return[];}const lebensMonate=[];for(let lebensMonat=this.vonLebensMonat;lebensMonat<=this.bisLebensMonat;lebensMonat++){lebensMonate.push(lebensMonat);}return lebensMonate;}isVonEqualOrLessBis(){return this.vonLebensMonat<=this.bisLebensMonat;}isLMTooHigh(){return this.vonLebensMonat>PLANUNG_ANZAHL_MONATE||this.bisLebensMonat>PLANUNG_ANZAHL_MONATE;}isLMTooSmall(){return this.vonLebensMonat<=0||this.bisLebensMonat<=0;}}/**
 * Ermittelt aus einer Liste von Erwerbszeiträumen, die Gesamtzahl der Monate.
 *
 * @param {ErwerbsZeitraumLebensMonat[]} erwerbsZeitraeume
 * @return {number}
 */function zaehleMonateErwerbsTaetigkeit(erwerbsZeitraeume){let anzahlMonate=0;if(erwerbsZeitraeume==null||erwerbsZeitraeume.length===0||erwerbsZeitraeume[0].vonLebensMonat==null){return 0;}for(let index=0;index<erwerbsZeitraeume.length;index++){let curr=erwerbsZeitraeume[index];anzahlMonate+=curr.getAnzahlMonate();}return anzahlMonate;}
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/kassen-art.ts
let KassenArt=/*#__PURE__*/function(KassenArt){KassenArt["GESETZLICH_PFLICHTVERSICHERT"]="GESETZLICH_PFLICHTVERSICHERT";KassenArt["NICHT_GESETZLICH_PFLICHTVERSICHERT"]="NICHT_GESETZLICH_PFLICHTVERSICHERT";return KassenArt;}({});
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/kinder-frei-betrag.ts
let KinderFreiBetrag=/*#__PURE__*/function(KinderFreiBetrag){KinderFreiBetrag["ZKF0"]="0";KinderFreiBetrag["ZKF0_5"]="0,5";KinderFreiBetrag["ZKF1"]="1";KinderFreiBetrag["ZKF1_5"]="1,5";KinderFreiBetrag["ZKF2"]="2";KinderFreiBetrag["ZKF2_5"]="2,5";KinderFreiBetrag["ZKF3"]="3";KinderFreiBetrag["ZKF3_5"]="3,5";KinderFreiBetrag["ZKF4"]="4";KinderFreiBetrag["ZKF4_5"]="4,5";KinderFreiBetrag["ZKF5"]="5";return KinderFreiBetrag;}({});/**
 * Returns number of Kinderfreibetrag enum.
 *
 * @param kinderFreiBetrag Kinderfreibetrag as enum.
 *
 * @return kinderFreiBetrag Kinderfreibetrag as number.
 */function kinderFreiBetragToNumber(kinderFreiBetrag){return Number.parseFloat(kinderFreiBetrag.valueOf().replace(",","."));}/**
 * Returns enum of Kinderfreibetrag number.
 *
 * @param kinderFreiBetrag Kinderfreibetrag as number.
 *
 * @return kinderFreiBetrag Kinderfreibetrag as enum.
 */function kinderFreiBetragOfNumber(kinderFreiBetrag){switch(kinderFreiBetrag){case 0:return KinderFreiBetrag.ZKF0;case 0.5:return KinderFreiBetrag.ZKF0_5;case 1:return KinderFreiBetrag.ZKF1;case 1.5:return KinderFreiBetrag.ZKF1_5;case 2:return KinderFreiBetrag.ZKF2;case 2.5:return KinderFreiBetrag.ZKF2_5;case 3:return KinderFreiBetrag.ZKF3;case 3.5:return KinderFreiBetrag.ZKF3_5;case 4:return KinderFreiBetrag.ZKF4;case 4.5:return KinderFreiBetrag.ZKF4_5;case 5:return KinderFreiBetrag.ZKF5;default:return undefined;}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/steuer-klasse.ts
let SteuerKlasse=/*#__PURE__*/function(SteuerKlasse){SteuerKlasse["SKL_UNBEKANNT"]="UNBEKANNT";SteuerKlasse["SKL1"]="1";SteuerKlasse["SKL2"]="2";SteuerKlasse["SKL3"]="3";SteuerKlasse["SKL4"]="4";SteuerKlasse["SKL4_FAKTOR"]="4 mit Faktor";SteuerKlasse["SKL5"]="5";SteuerKlasse["SKL6"]="6";return SteuerKlasse;}({});/**
 * Returns number of Steuerklasse enum.
 *
 * @param steuerKlasse Steuerklasse as enum.
 *
 * @return Steuerklasse as number. Returns undefined, if Steuerklasse is SKL_UNBEKANNT.
 */function steuerklasseToNumber(steuerKlasse){switch(steuerKlasse){case SteuerKlasse.SKL1:return 1;case SteuerKlasse.SKL2:return 2;case SteuerKlasse.SKL3:return 3;case SteuerKlasse.SKL4:case SteuerKlasse.SKL4_FAKTOR:return 4;case SteuerKlasse.SKL5:return 5;case SteuerKlasse.SKL6:return 6;default:return undefined;}}/**
 * Returns Steuerklasse enum of number.
 *
 * @param steuerKlasse Steuerklasse as number.
 *
 * @return steuerKlasse Steuerklasse as enum. Returns SKL_UNBEKANNT, if Steuerklasse is unknown.
 */function steuerklasseOfNumber(steuerKlasse){switch(steuerKlasse){case 1:return SteuerKlasse.SKL1;case 2:return SteuerKlasse.SKL2;case 3:return SteuerKlasse.SKL3;case 4:return SteuerKlasse.SKL4;case 5:return SteuerKlasse.SKL5;case 6:return SteuerKlasse.SKL6;default:return SteuerKlasse.SKL_UNBEKANNT;}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/renten-art.ts
let RentenArt=/*#__PURE__*/function(RentenArt){RentenArt["GESETZLICHE_RENTEN_VERSICHERUNG"]="GESETZLICHE_RENTEN_VERSICHERUNG";RentenArt["KEINE_GESETZLICHE_RENTEN_VERSICHERUNG"]="KEINE_GESETZLICHE_RENTEN_VERSICHERUNG";return RentenArt;}({});
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/finanz-daten.ts
/**
 * Angaben zum Einkommen für die Berechnung des Elterngeldes.
 */class FinanzDaten{constructor(){this.bruttoEinkommen=new Einkommen(0);this.zahlenSieKirchenSteuer=YesNo.NO;this.kinderFreiBetrag=KinderFreiBetrag.ZKF0;this.steuerKlasse=SteuerKlasse.SKL_UNBEKANNT;this.kassenArt=KassenArt.GESETZLICH_PFLICHTVERSICHERT;this.rentenVersicherung=RentenArt.GESETZLICHE_RENTEN_VERSICHERUNG;this.splittingFaktor=1.0;this.mischEinkommenTaetigkeiten=[];this.erwerbsZeitraumLebensMonatList=[];}/**
   * Zeigt an ob Daten für Mischeinkünfte vorliegen.
   * Wichtig: wenn keine Mischeinkommen berechnet werden soll, dann dürfen auch keine Werte da sein. Es reicht nicht,
   * die {@link PersoenlicheDaten#etVorGeburt} auf einen Wert anders als {@link ErwerbsArt#JA_MISCHEINKOMMEN} zu setzen
   *
   * @return true, wenn Daten für Mischeinkommen vorhanden sind.
   */isMischeinkommen(){return this.mischEinkommenTaetigkeiten.length>0;}bruttoLeistungsMonate(){// Im FIT Algorithmus sind die indizes immer Monats-basiert, d.h. der Index 0 bleibt leer.
const bruttoLM=new Array(PLANUNG_ANZAHL_MONATE+1).fill(math_util/* MathUtil */.k.BIG_ZERO);for(let index=0;index<this.erwerbsZeitraumLebensMonatList.length;index++){let erwerbszeitraum=this.erwerbsZeitraumLebensMonatList[index];for(let lm=erwerbszeitraum.vonLebensMonat;lm<=erwerbszeitraum.bisLebensMonat;lm++){const bruttoProMonat=erwerbszeitraum.bruttoProMonat.value;if(math_util/* MathUtil */.k.greater(bruttoProMonat,math_util/* MathUtil */.k.BIG_ZERO)){bruttoLM[lm]=bruttoProMonat;}}}return bruttoLM;}bruttoLeistungsMonateWithPlanung(isPlus,planungsdaten){const bruttoLM=new Array(PLANUNG_ANZAHL_MONATE+1).fill(math_util/* MathUtil */.k.BIG_ZERO);for(let index=0;index<this.erwerbsZeitraumLebensMonatList.length;index++){let erwerbszeitraum=this.erwerbsZeitraumLebensMonatList[index];for(let lm=erwerbszeitraum.vonLebensMonat;lm<=erwerbszeitraum.bisLebensMonat;lm++){// TODO simplify after java code migration and with new tests for this case
const bruttoProMonat=erwerbszeitraum.bruttoProMonat.value;if(math_util/* MathUtil */.k.greater(bruttoProMonat,math_util/* MathUtil */.k.BIG_ZERO)){const elterngeldArt=planungsdaten.planung[lm-1];if(isPlus){if(elterngeldArt===ElternGeldArt.PARTNERSCHAFTS_BONUS||elterngeldArt===ElternGeldArt.ELTERNGELD_PLUS){bruttoLM[lm]=bruttoProMonat;}}else{if(elterngeldArt===ElternGeldArt.BASIS_ELTERNGELD){bruttoLM[lm]=bruttoProMonat;}}}}}return bruttoLM;}}/**
 * Angaben zum Einkommen für die Berechnung des Elterngeldes.
 * Die Felder stammen aus der Java-Klasse FinanzDaten.
 */function finanzDatenOf(source){const copy=new FinanzDaten();Object.assign(copy,source);return copy;}
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/mutterschafts-leistung.ts
let MutterschaftsLeistung=/*#__PURE__*/function(MutterschaftsLeistung){MutterschaftsLeistung["MUTTERSCHAFTS_LEISTUNG_NEIN"]="MUTTERSCHAFTS_LEISTUNG_NEIN";MutterschaftsLeistung["MUTTERSCHAFTS_LEISTUNG_8_WOCHEN"]="MUTTERSCHAFTS_LEISTUNG_8_WOCHEN";MutterschaftsLeistung["MUTTERSCHAFTS_LEISTUNG_12_WOCHEN"]="MUTTERSCHAFTS_LEISTUNG_12_WOCHEN";return MutterschaftsLeistung;}({});function mutterschaftsLeistungInWochen(mutterschaftsLeistung){switch(mutterschaftsLeistung){case MutterschaftsLeistung.MUTTERSCHAFTS_LEISTUNG_NEIN:return 0;case MutterschaftsLeistung.MUTTERSCHAFTS_LEISTUNG_8_WOCHEN:return 8;case MutterschaftsLeistung.MUTTERSCHAFTS_LEISTUNG_12_WOCHEN:return 12;}}function mutterschaftsLeistungInMonaten(mutterschaftsLeistung){return mutterschaftsLeistungInWochen(mutterschaftsLeistung)/4;}
// EXTERNAL MODULE: ./src/globals/js/calculations/common/kind-util.ts
var kind_util = __webpack_require__(417);
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/persoenliche-daten.ts
/**
 * Persönliche Angaben für die Berechnung des Elterngeldes.
 */class PersoenlicheDaten{constructor(wahrscheinlichesGeburtsDatum){this.anzahlKuenftigerKinder=void 0;this.wahrscheinlichesGeburtsDatum=void 0;this.sindSieAlleinerziehend=void 0;this.etVorGeburt=void 0;this.etNachGeburt=void 0;this.anfangLM=void 0;this.endeLM=void 0;this.kinder=void 0;this.wahrscheinlichesGeburtsDatum=wahrscheinlichesGeburtsDatum;this.sindSieAlleinerziehend=YesNo.NO;this.etVorGeburt=ErwerbsArt.JA_NICHT_SELBST_MIT_SOZI;this.etNachGeburt=YesNo.NO;this.anfangLM=[];this.endeLM=[];this.anzahlKuenftigerKinder=1;this.kinder=[{nummer:1,geburtsdatum:undefined,istBehindert:false}];}isETNachGeburt(){return this.etNachGeburt===YesNo.YES;}isETVorGeburt(){return this.etVorGeburt!==ErwerbsArt.NEIN;}isAlleinerziehend(){return this.sindSieAlleinerziehend===YesNo.YES;}isGeschwisterVorhanden(){return this.getAnzahlGeschwister()>0;}getAnzahlGeschwister(){return kind_util/* KindUtil */.L.excludesFutureChildren(this.kinder).length;}}function persoenlicheDatenOf(source){const copy=new PersoenlicheDaten(source.wahrscheinlichesGeburtsDatum);Object.assign(copy,source);return copy;}
;// CONCATENATED MODULE: ./src/globals/js/calculations/model/index.ts


/***/ }),

/***/ 1648:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ createDefaultElternteileSettings),
/* harmony export */   r: () => (/* binding */ numberOfMutterschutzMonths)
/* harmony export */ });
/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9779);
let NumberOfMutterschutzMonths;(function(_NumberOfMutterschutzMonths){const oneChild=_NumberOfMutterschutzMonths.oneChild=2;const moreThanOneChild=_NumberOfMutterschutzMonths.moreThanOneChild=3;})(NumberOfMutterschutzMonths||(NumberOfMutterschutzMonths={}));const numberOfMutterschutzMonths=(anzahlKuenftigerKinder,hasMutterschutz)=>{if(hasMutterschutz==="YES"){return anzahlKuenftigerKinder===1?NumberOfMutterschutzMonths.oneChild:NumberOfMutterschutzMonths.moreThanOneChild;}else{return 0;}};const createDefaultElternteileSettings=(mehrlinge,behindertesGeschwisterkind,isoGeburtstag,mutterschutzElternteil,numberOfMutterschutzMonths,partnerMonate,alleinerziehend)=>{const geburtstag={geburt:isoGeburtstag,errechnet:isoGeburtstag};let settings={mehrlinge,behindertesGeschwisterkind,geburtstag,partnerMonate,alleinerziehend};if(numberOfMutterschutzMonths){const mutterschutz={elternteil:mutterschutzElternteil,endDate:luxon__WEBPACK_IMPORTED_MODULE_0__/* .DateTime */ .ou.fromISO(isoGeburtstag).plus({month:numberOfMutterschutzMonths})// Due to ed-monatsplaner-app API substract one day
// for each Mutterschafts Monat - explanation:
// In ElternGeld Digital taking on day of Mutterschafszeit
// should set the whole month as Mutterschafszeit. Therefore
// calculating the amount of Mutterschafs Monate Math.ceil is used.
// But the used luxon lib takes 30 day as a month.
// For the EGR use case this yields to wrong results.
// The EGR should set two or three month of Mutterschafts Monate.
// Pragmatic fix: substract one day of each Mutterschafts Month (just for calculation purpose)
.plus({days:numberOfMutterschutzMonths*-1}).toUTC().toISO({suppressMilliseconds:true})};settings={...settings,mutterschutz};}return settings;};

/***/ }),

/***/ 9242:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ namespace)
});

;// CONCATENATED MODULE: ./src/projectNamespace.js
// Do NOT suffixed with `-` here
const PROJECT_NAMESPACE="egr";/* harmony default export */ const projectNamespace = (PROJECT_NAMESPACE);
;// CONCATENATED MODULE: ./src/globals/js/namespace.js
/**
 * Add project namespace to classNames.
 *
 * Example:
 * ```
 * projectNamespace = "prefix"
 * nsp("class") -> "prefix-class"
 * nsp("A", "B") -> "prefix-A prefix-B"
 * nsp("A B") -> "prefix-A prefix-B"
 * ```
 *
 * @param  {...string} classNames List of classNames to prefix with namespace
 * @returns {string} joined className string
 */const nsp=function(){for(var _len=arguments.length,classNames=new Array(_len),_key=0;_key<_len;_key++){classNames[_key]=arguments[_key];}return classNames.map(classList=>classList.split(/\s/).filter(Boolean)).flat().map(className=>"".concat(projectNamespace,"-").concat(className)).join(" ");};/* harmony default export */ const namespace = (nsp);

/***/ }),

/***/ 7079:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CT: () => (/* binding */ numberOfLebensmonate),
/* harmony export */   IP: () => (/* binding */ minNumberOfElterngeld),
/* harmony export */   br: () => (/* binding */ maxNumberOfPartnerschaftbonus),
/* harmony export */   r9: () => (/* binding */ maxNumberOfSimultaneousBEGMonths)
/* harmony export */ });
const numberOfLebensmonate=32;const maxNumberOfPartnerschaftbonus=4;const minNumberOfElterngeld=2;const maxNumberOfSimultaneousBEGMonths=1;

/***/ }),

/***/ 1207:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ getBEGAnspruch)
/* harmony export */ });
/* harmony import */ var _fruehchen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2505);
const getBEGAnspruch=geburtstag=>{if(!geburtstag){return 12;}switch((0,_fruehchen__WEBPACK_IMPORTED_MODULE_0__/* .getFruehchen */ .t)(geburtstag)){case"16Weeks":return 16;case"12Weeks":return 15;case"8Weeks":return 14;case"6Weeks":return 13;case"NotAFruehchen":return 12;}};

/***/ }),

/***/ 2444:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ME: () => (/* binding */ canNotChangeBEGDueToLimitReachedPerParent),
  il: () => (/* binding */ canNotChangeBEGDueToSimultaneousMonthRules),
  XP: () => (/* binding */ canNotChangeEGPDueToLimitReachedPerParent),
  ZP: () => (/* binding */ change_month),
  QK: () => (/* binding */ isExceptionToSimulatenousMonthRestrictions),
  Yt: () => (/* binding */ reachedLimitOfSimultaneousBEGMonths)
});

;// CONCATENATED MODULE: ./src/monatsplaner/elternteile/modifiable-psb-month.ts
const getModifiablePSBMonthIndices=(months,remainingMonthsPSB)=>{const currentPSBIndices=months.flatMap((month,index)=>month.type==="PSB"?[index]:[]);//no PSB selected, all months are selectable
if(currentPSBIndices.length===0){return{selectableIndices:months.map((_,index)=>index),deselectableIndices:[]};}const lowestIndex=currentPSBIndices[0];const highestIndex=currentPSBIndices[currentPSBIndices.length-1];if(remainingMonthsPSB>0){// some PSB month are selected, only adjacent month are selectable and only outermost months can be deselected
return{selectableIndices:[lowestIndex-1,highestIndex+1],deselectableIndices:[lowestIndex,highestIndex]};}else{// all PSB months are selected, nothing is selectable and only outermost months can be deselected
return{selectableIndices:[],deselectableIndices:[lowestIndex,highestIndex]};}};
// EXTERNAL MODULE: ./src/monatsplaner/elternteile/mutterschutz-calculator.ts
var mutterschutz_calculator = __webpack_require__(3330);
// EXTERNAL MODULE: ./src/monatsplaner/elternteile/elternteile-setting.ts
var elternteile_setting = __webpack_require__(1408);
// EXTERNAL MODULE: ./src/monatsplaner/elternteile/beg-anspruch.ts
var beg_anspruch = __webpack_require__(1207);
// EXTERNAL MODULE: ./src/monatsplaner/configuration.ts
var configuration = __webpack_require__(7079);
// EXTERNAL MODULE: ./src/monatsplaner/month-utils/index.ts + 1 modules
var month_utils = __webpack_require__(9861);
;// CONCATENATED MODULE: ./src/monatsplaner/elternteile/change-month.ts
const calculateBEGAnspruch=(currentElternteilMonths,otherElternteilMonths,partnerMonate,geburtstag)=>{let anspruch=(0,beg_anspruch/* getBEGAnspruch */.O)(geburtstag);if(partnerMonate){anspruch+=2;}return anspruch;};const roundUp=x=>Math.ceil(x/2);const canNotBeChangedDueToMutterschutz=(_ref,settings)=>{let{elternteil,monthIndex,targetType}=_ref;return (0,elternteile_setting/* hasMutterschutzSettings */.lq)(settings)&&(settings.mutterschutz.elternteil===elternteil||targetType==="PSB")&&monthIndex<(0,mutterschutz_calculator/* getNumberOfMutterschutzMonths */.d)(settings.geburtstag,settings.mutterschutz.endDate);};const canNotBeChangedDueToUnmodifiablePSB=(_ref2,elternteile)=>{let{elternteil,monthIndex,targetType}=_ref2;const currentType=elternteile[elternteil].months[monthIndex].type;const{selectableIndices,deselectableIndices}=getModifiablePSBMonthIndices(elternteile[elternteil].months,elternteile.remainingMonths.partnerschaftsbonus);return targetType==="PSB"&&!selectableIndices.includes(monthIndex)||targetType==="None"&&currentType==="PSB"&&!deselectableIndices.includes(monthIndex);};function canNotChangePSBBecauseNoPartnerMonths(_ref3,elternteileSettings){let{targetType}=_ref3;return targetType==="PSB"&&!!elternteileSettings&&!(0,elternteile_setting/* getPartnerMonateSettings */.Vb)(elternteileSettings);}function choosingASimultaneousBEGMonth(changeMonthSettings,elternteile){const{targetType,elternteil,monthIndex}=changeMonthSettings;const choosingBEG=targetType==="BEG";const otherParent=elternteil==="ET1"?elternteile.ET2:elternteile.ET1;const otherParentChoseBEGForSameMonth=otherParent.months[monthIndex].type==="BEG";return choosingBEG&&otherParentChoseBEGForSameMonth;}function isExceptionToSimulatenousMonthRestrictions(elternteileSettings){if(elternteileSettings){const{mehrlinge,behindertesGeschwisterkind}=elternteileSettings;return mehrlinge||behindertesGeschwisterkind;}else{return false;}}function reachedLimitOfSimultaneousBEGMonths(elternteile){const typesET1=elternteile.ET1.months.map(_ref4=>{let{type}=_ref4;return type;});const typesET2=elternteile.ET2.months.map(_ref5=>{let{type}=_ref5;return type;});const typePairs=typesET1.map((type,index)=>[type,typesET2[index]]);const numberOfSimultanuousMonths=typePairs.filter(_ref6=>{let[a,b]=_ref6;return a==="BEG"&&b==="BEG";}).length;return numberOfSimultanuousMonths>=configuration/* maxNumberOfSimultaneousBEGMonths */.r9;}function canNotChangeBEGDueToSimultaneousMonthRules(changeMonthSettings,elternteile,elternteileSettings){if(!choosingASimultaneousBEGMonth(changeMonthSettings,elternteile)||isExceptionToSimulatenousMonthRestrictions(elternteileSettings)){return false;}const choosingAfterTheTwelveMonth=changeMonthSettings.monthIndex>=12;const reachedLimit=reachedLimitOfSimultaneousBEGMonths(elternteile);return choosingAfterTheTwelveMonth||reachedLimit;}function canNotChangeBEGDueToLimitReachedPerParent(changeMonthSettings,elternteile,elternteileSettings){const choosingBEGMonth=changeMonthSettings.targetType==="BEG";const limit=limitOfMonthsPerParentAsEgp(elternteileSettings);const months=elternteile[changeMonthSettings.elternteil].months;const numberOfTakenMonths=getCombinedNumberOfMonthsAsEGP(months);const isLimitReached=limit-numberOfTakenMonths<BEG_TO_EGP_RATIO;return choosingBEGMonth&&isLimitReached;}function canNotChangeEGPDueToLimitReachedPerParent(changeMonthSettings,elternteile,elternteileSettings){const choosingEGPMonth=changeMonthSettings.targetType==="EG+";const limit=limitOfMonthsPerParentAsEgp(elternteileSettings);const months=elternteile[changeMonthSettings.elternteil].months;const numberOfTakenMonths=getCombinedNumberOfMonthsAsEGP(months);const isLimitReached=limit-numberOfTakenMonths<1;return choosingEGPMonth&&isLimitReached;}function canNotChangeDueToLimitReachedPerParent(changeMonthSettings,elternteile,elternteileSettings){const hasReachedBegLimit=canNotChangeBEGDueToLimitReachedPerParent(changeMonthSettings,elternteile,elternteileSettings);const hasReachedEgpLimit=canNotChangeEGPDueToLimitReachedPerParent(changeMonthSettings,elternteile,elternteileSettings);return hasReachedBegLimit||hasReachedEgpLimit;}const replaceMonthAtIndex=(replacement,monthIndex,months)=>{const modifiedMonths=[...months];modifiedMonths[monthIndex]=replacement;return modifiedMonths;};const changeMonth=(elternteile,changeMonthSettings,elternteileSettings)=>{const{elternteil,monthIndex,targetType}=changeMonthSettings;const otherETKey=elternteil==="ET1"?"ET2":"ET1";const currentET=elternteile[elternteil];const otherET=elternteile[otherETKey];const currentType=currentET.months[monthIndex].type;if(currentET.months[monthIndex].type===targetType){return elternteile;}if(elternteileSettings&&canNotBeChangedDueToMutterschutz(changeMonthSettings,elternteileSettings)){return elternteile;}if(canNotBeChangedDueToUnmodifiablePSB(changeMonthSettings,elternteile)){return elternteile;}if(canNotChangePSBBecauseNoPartnerMonths(changeMonthSettings,elternteileSettings)){return elternteile;}if(canNotChangeBEGDueToSimultaneousMonthRules(changeMonthSettings,elternteile,elternteileSettings)){return elternteile;}if(canNotChangeDueToLimitReachedPerParent(changeMonthSettings,elternteile,elternteileSettings)){return elternteile;}let currentMonths=replaceMonthAtIndex({type:targetType,isMutterschutzMonth:false},monthIndex,currentET.months);let otherMonths=otherET.months;// reset PSB of otherET for case that something else is selected
if(currentET.months[monthIndex].type==="PSB"){otherMonths=replaceMonthAtIndex({type:"None",isMutterschutzMonth:false},monthIndex,otherMonths);}if(targetType==="PSB"){// PSB must always be set for both elternteile
otherMonths=replaceMonthAtIndex({type:targetType,isMutterschutzMonth:false},monthIndex,otherMonths);//if there is no PSB Month, select two PSB months
const hasAtLeastOnePSBMonth=currentET.months.some(month=>month.type==="PSB");if(!hasAtLeastOnePSBMonth){const isLastMonthIndex=monthIndex===currentET.months.length-1;const automaticallySelectedPSBMonthIndex=isLastMonthIndex?monthIndex-1:monthIndex+1;otherMonths=replaceMonthAtIndex({type:targetType,isMutterschutzMonth:false},automaticallySelectedPSBMonthIndex,otherMonths);currentMonths=replaceMonthAtIndex({type:targetType,isMutterschutzMonth:false},automaticallySelectedPSBMonthIndex,currentMonths);}}//deselect PSB months if only one is remaining
if(targetType==="None"&&currentType==="PSB"){const existingPSBIndices=currentMonths.flatMap((month,index)=>month.type==="PSB"&&index!==monthIndex?[index]:[]);if(existingPSBIndices.length===1){const existingPSBIndex=existingPSBIndices[0];otherMonths=replaceMonthAtIndex({type:targetType,isMutterschutzMonth:false},existingPSBIndex,otherMonths);currentMonths=replaceMonthAtIndex({type:targetType,isMutterschutzMonth:false},existingPSBIndex,currentMonths);}}const anspruch=calculateBEGAnspruch(currentMonths,otherMonths,(0,elternteile_setting/* getPartnerMonateSettings */.Vb)(elternteileSettings),(0,elternteile_setting/* getGeburtstagSettings */.Qc)(elternteileSettings));const begMonthsTakenByBoth=(0,month_utils/* countBEGMonths */.ld)(currentMonths)+(0,month_utils/* countBEGMonths */.ld)(otherMonths);const egPlusMonthsTakenByBoth=(0,month_utils/* countEGPlusMonths */.Hj)(currentMonths)+(0,month_utils/* countEGPlusMonths */.Hj)(otherMonths);let remainingMonthsBEG=anspruch-begMonthsTakenByBoth;if(remainingMonthsBEG>0){remainingMonthsBEG=Math.max(0,remainingMonthsBEG-roundUp(egPlusMonthsTakenByBoth));}const remainingMonthsEGPlus=2*(anspruch-begMonthsTakenByBoth)-egPlusMonthsTakenByBoth;const remainingPartnerschaftsbonus=configuration/* maxNumberOfPartnerschaftbonus */.br-(0,month_utils/* countPSBMonths */.AI)(currentMonths);const changedCurrentET={...currentET,months:currentMonths};const changedOtherET={...otherET,months:otherMonths};return{...elternteile,remainingMonths:{basiselterngeld:remainingMonthsBEG,elterngeldplus:remainingMonthsEGPlus,partnerschaftsbonus:remainingPartnerschaftsbonus},[elternteil]:changedCurrentET,[otherETKey]:changedOtherET};};/* harmony default export */ const change_month = (changeMonth);function limitOfMonthsPerParentAsEgp(settings){return settings!==null&&settings!==void 0&&settings.alleinerziehend?28:24;}/**
 * The number of months of type BEG or EG+ together. The BEG months are counted
 * in ratio to EG+ to get a neutralized number. This is used for rules where
 * both types of months need to be taken into consideration together.
 *
 * E.g.:
 *   - 1 month BEG and 1 month EG+ makes 3 neutral months
 *   - 2 month BEG and 1 month EG+ makes 5 neutral months
 */function getCombinedNumberOfMonthsAsEGP(months){const begMonthCount=months.filter(isBEGMonth).length;const egpMonthCount=months.filter(isEGPMonth).length;const begAsEgpMonthCount=begMonthCount*BEG_TO_EGP_RATIO;return begAsEgpMonthCount+egpMonthCount;}function isBEGMonth(month){return month.type==="BEG";}function isEGPMonth(month){return month.type==="EG+";}const BEG_TO_EGP_RATIO=2;// 1 month BEG is "worth" 2 months EGP

/***/ }),

/***/ 1408:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qc: () => (/* binding */ getGeburtstagSettings),
/* harmony export */   Vb: () => (/* binding */ getPartnerMonateSettings),
/* harmony export */   lq: () => (/* binding */ hasMutterschutzSettings)
/* harmony export */ });
const hasMutterschutzSettings=settings=>{return"mutterschutz"in settings;};const hasPartnerMonateSettings=settings=>{return"partnerMonate"in settings;};const hasGeburtstagSettings=settings=>{return"geburtstag"in settings;};const getGeburtstagSettings=settings=>settings&&hasGeburtstagSettings(settings)?settings.geburtstag:undefined;const getPartnerMonateSettings=settings=>settings&&hasPartnerMonateSettings(settings)?settings.partnerMonate:false;

/***/ }),

/***/ 2505:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ getFruehchen)
/* harmony export */ });
/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9779);
const getFruehchen=geburtstag=>{const weeks=luxon__WEBPACK_IMPORTED_MODULE_0__/* .DateTime */ .ou.fromISO(geburtstag.errechnet).diff(luxon__WEBPACK_IMPORTED_MODULE_0__/* .DateTime */ .ou.fromISO(geburtstag.geburt)).as("weeks");if(weeks>=16){return"16Weeks";}if(weeks>=12){return"12Weeks";}if(weeks>=8){return"8Weeks";}if(weeks>=6){return"6Weeks";}return"NotAFruehchen";};

/***/ }),

/***/ 3330:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ getNumberOfMutterschutzMonths)
/* harmony export */ });
/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9779);
// WARN: full month differences could result in one month to much because of luxon taking 30 days as one month
// WARN: wrong result could be provided in periods which have a greater count of month with 31 day (compared to months with less days)
// HINT: according to Elterngeld Digital specification one day of Mutterschutz should set the entire calendar month concerned as Mutterschutz Monat
// TODO: fix the behaviour describe above
const getNumberOfMutterschutzMonths=(geburtstag,mutterschutzEndDate)=>{return Math.ceil(luxon__WEBPACK_IMPORTED_MODULE_0__/* .DateTime */ .ou.fromISO(mutterschutzEndDate).diff(luxon__WEBPACK_IMPORTED_MODULE_0__/* .DateTime */ .ou.fromISO(geburtstag.geburt)).as("months"));};

/***/ }),

/***/ 2110:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  pY: () => (/* reexport */ change_month/* default */.ZP),
  by: () => (/* reexport */ createElternteile),
  Gn: () => (/* reexport */ lebensmonate_lebensmonate),
  mz: () => (/* reexport */ validation)
});

// UNUSED EXPORTS: getFruehchen

// EXTERNAL MODULE: ./node_modules/luxon/src/luxon.js + 23 modules
var luxon = __webpack_require__(9779);
// EXTERNAL MODULE: ./src/monatsplaner/configuration.ts
var configuration = __webpack_require__(7079);
;// CONCATENATED MODULE: ./src/monatsplaner/lebensmonate/lebensmonate.ts
const lebensmonate=Array.from({length:configuration/* numberOfLebensmonate */.CT}).map(()=>({}));const getLebensmonate=geburtstag=>{if(!geburtstag){return lebensmonate;}return lebensmonate.map((_,index)=>{const fromDate=luxon/* DateTime */.ou.fromJSDate(geburtstag).plus({months:index}).startOf("day");const toDate=fromDate.plus({months:1}).minus({day:1}).endOf("day");return{from:fromDate.toISO({includeOffset:false}),to:toDate.toISO({includeOffset:false})};});};/* harmony default export */ const lebensmonate_lebensmonate = (getLebensmonate);
;// CONCATENATED MODULE: ./src/monatsplaner/lebensmonate/index.ts

// EXTERNAL MODULE: ./src/monatsplaner/elternteile/elternteile-setting.ts
var elternteile_setting = __webpack_require__(1408);
// EXTERNAL MODULE: ./src/monatsplaner/elternteile/beg-anspruch.ts
var beg_anspruch = __webpack_require__(1207);
// EXTERNAL MODULE: ./src/monatsplaner/elternteile/mutterschutz-calculator.ts
var mutterschutz_calculator = __webpack_require__(3330);
;// CONCATENATED MODULE: ./src/monatsplaner/elternteile/elternteile.ts
const createElternteile=settings=>{const emptyMonth={type:"None",isMutterschutzMonth:false};const emptyMonths=Array.from({length:configuration/* numberOfLebensmonate */.CT}).fill(emptyMonth);let begAnspruch=(0,beg_anspruch/* getBEGAnspruch */.O)((0,elternteile_setting/* getGeburtstagSettings */.Qc)(settings));let elternteil1={months:emptyMonths};let elternteil2=elternteil1;if(settings&&(0,elternteile_setting/* hasMutterschutzSettings */.lq)(settings)){const{elternteil,endDate}=settings.mutterschutz;const numberOfMutterschutzMonths=(0,mutterschutz_calculator/* getNumberOfMutterschutzMonths */.d)(settings.geburtstag,endDate);const months=emptyMonths.map((month,index)=>{if(index<numberOfMutterschutzMonths){return{...month,type:"BEG",isMutterschutzMonth:true};}return month;});switch(elternteil){case"ET1":elternteil1={months};break;case"ET2":elternteil2={months};break;}begAnspruch-=numberOfMutterschutzMonths;}let partnerschaftsbonus=configuration/* maxNumberOfPartnerschaftbonus */.br;if((0,elternteile_setting/* getPartnerMonateSettings */.Vb)(settings)){begAnspruch=begAnspruch+2;}else{partnerschaftsbonus=0;}return{remainingMonths:{basiselterngeld:begAnspruch,elterngeldplus:begAnspruch*2,partnerschaftsbonus},ET1:elternteil1,ET2:elternteil2};};
// EXTERNAL MODULE: ./src/monatsplaner/elternteile/fruehchen.ts
var fruehchen = __webpack_require__(2505);
// EXTERNAL MODULE: ./src/monatsplaner/elternteile/change-month.ts + 1 modules
var change_month = __webpack_require__(2444);
;// CONCATENATED MODULE: ./src/monatsplaner/elternteile/index.ts

;// CONCATENATED MODULE: ./src/monatsplaner/validation/validation-result.ts
const validResult={isValid:true};const allOf=function(){for(var _len=arguments.length,validationResults=new Array(_len),_key=0;_key<_len;_key++){validationResults[_key]=arguments[_key];}return validationResults.reduce((previousResult,current)=>{if(current.isValid){return previousResult;}const previousErrorCodes=previousResult.isValid?[]:previousResult.errorCodes;return{isValid:false,errorCodes:[...previousErrorCodes,...current.errorCodes]};},validResult);};/* eslint-disable no-redeclare */ /*
 * Function Overload:
 * https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads
 */function validationRule(errorCode,predicate){return(target,arg)=>{if(predicate(target,arg)){return validResult;}else{return{isValid:false,errorCodes:[errorCode]};}};}/* eslint-enable no-redeclare */
// EXTERNAL MODULE: ./src/monatsplaner/month-utils/index.ts + 1 modules
var month_utils = __webpack_require__(9861);
;// CONCATENATED MODULE: ./src/monatsplaner/validation/validation.ts
const hasAnySelection=validationRule("HasNoSelection",elternteile=>{return (0,month_utils/* countFilledMonths */._w)(elternteile.ET1.months)>0||(0,month_utils/* countFilledMonths */._w)(elternteile.ET2.months)>0;});const hasNotTakenMoreThanTheAvailableBEGMonths=validationRule("HasTakenMoreThanTheAvailableBEGMonths",elternteile=>{return elternteile.remainingMonths.basiselterngeld>=0;});const hasAtLeast2EGMonthsOrNoneAtAll=validationRule("DoesNotHaveTheMinimumAmountOfEGMonthsOrNoneAtAll",elternteile=>{const begMonthsET1=(0,month_utils/* countBEGMonths */.ld)(elternteile.ET1.months);const begMonthsET2=(0,month_utils/* countBEGMonths */.ld)(elternteile.ET2.months);const egPlusMonthsET1=(0,month_utils/* countEGPlusMonths */.Hj)(elternteile.ET1.months);const egPlusMonthsET2=(0,month_utils/* countEGPlusMonths */.Hj)(elternteile.ET2.months);const egMonthsET1=begMonthsET1+egPlusMonthsET1;const egMonthsET2=begMonthsET2+egPlusMonthsET2;return(egMonthsET1===0||egMonthsET1>=configuration/* minNumberOfElterngeld */.IP)&&(egMonthsET2===0||egMonthsET2>=configuration/* minNumberOfElterngeld */.IP);});const hasContinuousEGAfterBEGAnspruch=validationRule("DoesNotHaveContinuousEGAfterBEGAnspruch",(elternteile,lastMonthBEGAnspruch)=>{const monthOfBoth=elternteile.ET1.months.map((et1Month,index)=>{if(et1Month.type==="None"){return elternteile.ET2.months[index];}return et1Month;});const lastIndexOfEGOfBoth=(0,month_utils/* lastIndexOfType */.XO)(monthOfBoth,"EG+","PSB");return lastIndexOfEGOfBoth<=lastMonthBEGAnspruch||(0,month_utils/* hasContinuousMonthsOfType */.pm)(monthOfBoth,lastMonthBEGAnspruch,"EG+","PSB");});const hasNotTakenBEGAfterBEGAnspruch=validationRule("HasTakenBEGAfterBEGAnspruch",(elternteile,lastMonthBEGAnspruch)=>{return (0,month_utils/* lastIndexOfType */.XO)(elternteile.ET1.months,"BEG")<lastMonthBEGAnspruch&&(0,month_utils/* lastIndexOfType */.XO)(elternteile.ET2.months,"BEG")<lastMonthBEGAnspruch;});const getLastMonthOfBEGAnspruch=geburtstag=>{if(geburtstag){switch((0,fruehchen/* getFruehchen */.t)(geburtstag)){case"16Weeks":return 18;case"12Weeks":return 17;case"8Weeks":return 16;case"6Weeks":return 15;case"NotAFruehchen":return 14;}}return 14;};const validateElternteile=(elternteile,settings)=>{const lastMonthOfBEGAnspruch=getLastMonthOfBEGAnspruch((0,elternteile_setting/* getGeburtstagSettings */.Qc)(settings));return allOf(hasAnySelection(elternteile),hasNotTakenMoreThanTheAvailableBEGMonths(elternteile),hasAtLeast2EGMonthsOrNoneAtAll(elternteile),hasContinuousEGAfterBEGAnspruch(elternteile,lastMonthOfBEGAnspruch),hasNotTakenBEGAfterBEGAnspruch(elternteile,lastMonthOfBEGAnspruch));};/* harmony default export */ const validation = (validateElternteile);
;// CONCATENATED MODULE: ./src/monatsplaner/validation/index.ts

;// CONCATENATED MODULE: ./src/monatsplaner/index.ts


/***/ }),

/***/ 9861:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ld: () => (/* reexport */ countBEGMonths),
  Hj: () => (/* reexport */ countEGPlusMonths),
  _w: () => (/* reexport */ countFilledMonths),
  AI: () => (/* reexport */ countPSBMonths),
  pm: () => (/* reexport */ hasContinuousMonthsOfType),
  XO: () => (/* reexport */ lastIndexOfType)
});

;// CONCATENATED MODULE: ./src/monatsplaner/month-utils/month-utils.ts
const lastIndexOfType=function(months){for(var _len=arguments.length,types=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){types[_key-1]=arguments[_key];}return months.reduceRight((lastIndex,month,index)=>{if(lastIndex===-1&&types.includes(month.type)){return index;}return lastIndex;},-1);};const countMonthsByType=type=>months=>{return months.filter(month=>month.type===type).length;};const countBEGMonths=countMonthsByType("BEG");const countEGPlusMonths=countMonthsByType("EG+");const countPSBMonths=countMonthsByType("PSB");const countFilledMonths=months=>{return months.filter(month=>month.type!=="None").length;};const hasContinuousMonthsOfType=function(months,startIndex){for(var _len2=arguments.length,types=new Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){types[_key2-2]=arguments[_key2];}const endIndex=lastIndexOfType(months,...types);return!months.slice(startIndex,endIndex+1).some(month=>!types.includes(month.type));};
;// CONCATENATED MODULE: ./src/monatsplaner/month-utils/index.ts


/***/ }),

/***/ 3153:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CG: () => (/* binding */ useAppSelector),
/* harmony export */   TL: () => (/* binding */ useAppDispatch),
/* harmony export */   qr: () => (/* binding */ useAppStore),
/* harmony export */   v6: () => (/* binding */ createAppSelector)
/* harmony export */ });
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4420);
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3553);
// Use typed dispatch and selectors throughout your app instead of plain any-typed `useDispatch` and `useSelector`
const useAppDispatch=()=>(0,react_redux__WEBPACK_IMPORTED_MODULE_0__/* .useDispatch */ .I0)();const createAppSelector=_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__/* .createSelector */ .P1.withTypes();const useAppSelector=react_redux__WEBPACK_IMPORTED_MODULE_0__/* .useSelector */ .v9;const useAppStore=react_redux__WEBPACK_IMPORTED_MODULE_0__/* .useStore */ .oR.withTypes();

/***/ }),

/***/ 8772:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Wo: () => (/* binding */ monatsplanerActions),
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   lf: () => (/* binding */ getAutomaticallySelectedPSBMonthIndex),
/* harmony export */   sF: () => (/* binding */ monatsplanerSelectors)
/* harmony export */ });
/* unused harmony export initialMonatsplanerState */
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3553);
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7291);
/* harmony import */ var _stepAllgemeineAngabenSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(177);
/* harmony import */ var _stepNachwuchsSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8632);
/* harmony import */ var _globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3444);
/* harmony import */ var _monatsplaner__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2110);
/* harmony import */ var _globals_js_elternteile_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1648);
const initialMonatsplanerState={mutterschutzElternteil:null,settings:undefined,// EGR-244 - no conditions to get Partner Monate for only one Elternteil - property default value is true
partnerMonate:true,elternteile:(0,_monatsplaner__WEBPACK_IMPORTED_MODULE_3__/* .createElternteile */ .by)({mehrlinge:false,behindertesGeschwisterkind:false,partnerMonate:true})};const getSelectablePSBMonthIndices=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_5__/* .createSelector */ .P1)(state=>state.monatsplaner.elternteile.ET1.months,state=>state.monatsplaner.elternteile.remainingMonths.partnerschaftsbonus,(months,remainingMonthsPSB)=>{const currentPSBIndices=months.flatMap((month,index)=>month.type==="PSB"?[index]:[]);if(currentPSBIndices.length===0){return{selectableIndices:months.map((_,index)=>index),deselectableIndices:[]};}const lowestIndex=currentPSBIndices[0];const highestIndex=currentPSBIndices[currentPSBIndices.length-1];if(remainingMonthsPSB>0){return{selectableIndices:[lowestIndex-1,highestIndex+1],deselectableIndices:[lowestIndex,highestIndex]};}else{return{selectableIndices:[],deselectableIndices:[lowestIndex,highestIndex]};}});const getAutomaticallySelectedPSBMonthIndex=(months,selectedMonthIndex)=>{const hasAtLeastOnePSBMonth=months.some(month=>month.type==="PSB");if(!hasAtLeastOnePSBMonth){if(selectedMonthIndex===months.length-1){return selectedMonthIndex-1;}else{return selectedMonthIndex+1;}}};const monatsplanerSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__/* .createSlice */ .oM)({name:"monatsplaner",initialState:initialMonatsplanerState,reducers:{changeMonth:(state,_ref)=>{let{payload:{elternteil,targetType,monthIndex}}=_ref;const nextElternteile=(0,_monatsplaner__WEBPACK_IMPORTED_MODULE_3__/* .changeMonth */ .pY)(state.elternteile,{elternteil,targetType,monthIndex},state.settings);return{...state,elternteile:nextElternteile};},resetMonths:state=>({...state,elternteile:(0,_monatsplaner__WEBPACK_IMPORTED_MODULE_3__/* .createElternteile */ .by)(state.settings)})},extraReducers:builder=>{builder.addCase(_stepAllgemeineAngabenSlice__WEBPACK_IMPORTED_MODULE_0__/* .stepAllgemeineAngabenActions */ .mk.submitStep,(state,_ref2)=>{let{payload}=_ref2;if(payload.mutterschaftssleistungen===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_2__/* .YesNo */ .l.YES){if(payload.antragstellende==="EinenElternteil"){state.mutterschutzElternteil="ET1";}else{state.mutterschutzElternteil=payload.mutterschaftssleistungenWer;}}const alleinerziehend=payload.alleinerziehend===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_2__/* .YesNo */ .l.YES;const partnerMonate=alleinerziehend||payload.antragstellende==="FuerBeide";state.settings={alleinerziehend,partnerMonate,mehrlinge:false,behindertesGeschwisterkind:false};state.partnerMonate=partnerMonate;state.elternteile=(0,_monatsplaner__WEBPACK_IMPORTED_MODULE_3__/* .createElternteile */ .by)(state.settings);});builder.addCase(_stepNachwuchsSlice__WEBPACK_IMPORTED_MODULE_1__/* .stepNachwuchsActions */ .Lk.submitStep,(state,_ref3)=>{var _state$settings;let{payload}=_ref3;const mehrlinge=payload.anzahlKuenftigerKinder>1;const behindertesGeschwisterkind=payload.geschwisterkinder.filter(kind=>kind.istBehindert).length>0;const[day,month,year]=payload.wahrscheinlichesGeburtsDatum.split(".");const mutterSchutzMonate=(0,_globals_js_elternteile_utils__WEBPACK_IMPORTED_MODULE_4__/* .numberOfMutterschutzMonths */ .r)(payload.anzahlKuenftigerKinder,payload.mutterschaftssleistungen);const wahrscheinlichesISOGeburtsDatum="".concat(year,"-").concat(month,"-").concat(day,"T00:00:00Z");// create suitable configuration for ed-monatsplaner-app API
const settings=(0,_globals_js_elternteile_utils__WEBPACK_IMPORTED_MODULE_4__/* .createDefaultElternteileSettings */ .m)(mehrlinge,behindertesGeschwisterkind,wahrscheinlichesISOGeburtsDatum,state.mutterschutzElternteil,mutterSchutzMonate,state.partnerMonate,(_state$settings=state.settings)===null||_state$settings===void 0?void 0:_state$settings.alleinerziehend);return{...state,settings,elternteile:(0,_monatsplaner__WEBPACK_IMPORTED_MODULE_3__/* .createElternteile */ .by)(settings)};});}});const monatsplanerSelectors={getSelectablePSBMonthIndices};const monatsplanerActions=monatsplanerSlice.actions;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (monatsplanerSlice.reducer);

/***/ }),

/***/ 177:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   cI: () => (/* binding */ stepAllgemeineAngabenSelectors),
/* harmony export */   mk: () => (/* binding */ stepAllgemeineAngabenActions)
/* harmony export */ });
/* unused harmony export initialStepAllgemeineAngabenState */
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7291);
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3553);
const initialStepAllgemeineAngabenState={antragstellende:null,pseudonym:{ET1:"",ET2:""},alleinerziehend:null,mutterschaftssleistungen:null,mutterschaftssleistungenWer:null};const stepAllgemeineAngabenSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__/* .createSlice */ .oM)({name:"stepAllgemeineAngaben",initialState:initialStepAllgemeineAngabenState,reducers:{submitStep:(_,action)=>{const alleinerziehend=action.payload.antragstellende==="FuerBeide"?null:action.payload.alleinerziehend;return{...action.payload,alleinerziehend};}}});const getAntragssteller=state=>state.stepAllgemeineAngaben.antragstellende;const getElternteilNames=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__/* .createSelector */ .P1)(state=>state.stepAllgemeineAngaben.pseudonym.ET1,state=>state.stepAllgemeineAngaben.pseudonym.ET2,(pseudonymElternteil1,pseudonymElternteil2)=>{return{ET1:pseudonymElternteil1||"Elternteil 1",ET2:pseudonymElternteil2||"Elternteil 2"};});const getAlleinerziehend=state=>state.stepAllgemeineAngaben.alleinerziehend;const stepAllgemeineAngabenActions=stepAllgemeineAngabenSlice.actions;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stepAllgemeineAngabenSlice.reducer);const stepAllgemeineAngabenSelectors={getAntragssteller,getElternteilNames,getAlleinerziehend};

/***/ }),

/***/ 5353:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KH: () => (/* binding */ stepEinkommenActions),
/* harmony export */   Yg: () => (/* binding */ initialTaetigkeit),
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports initialAverageOrMonthlyStateNichtSelbstaendig, initialStepEinkommenState */
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7291);
/* harmony import */ var luxon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9779);
/* harmony import */ var _stepErwerbstaetigkeitSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8049);
/* harmony import */ var _stepAllgemeineAngabenSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(177);
/* harmony import */ var _globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3444);
const initialAverageOrMonthlyStateNichtSelbstaendig={type:"average",average:null,perYear:null,perMonth:Array.from({length:12}).fill(null)};const initialAverageOrMonthlyStateSelbstaendig={type:"yearly",average:null,perYear:null,perMonth:[]};const initialTaetigkeit={artTaetigkeit:"NichtSelbststaendig",bruttoEinkommenDurchschnitt:null,isMinijob:null,zeitraum:[{from:"",to:""}],versicherungen:{hasRentenversicherung:false,hasArbeitslosenversicherung:false,hasKrankenversicherung:false,none:false}};const initialStepEinkommenElternteil={bruttoEinkommenNichtSelbstaendig:initialAverageOrMonthlyStateNichtSelbstaendig,steuerKlasse:null,splittingFaktor:null,kinderFreiBetrag:_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .KinderFreiBetrag */ .uy.ZKF1,gewinnSelbstaendig:initialAverageOrMonthlyStateSelbstaendig,rentenVersicherung:null,zahlenSieKirchenSteuer:null,kassenArt:null,taetigkeitenNichtSelbstaendigUndSelbstaendig:[],istErwerbstaetig:null,hasMischEinkommen:null,istSelbststaendig:null,istNichtSelbststaendig:null};const resetStepEinkommenElternteil={...initialStepEinkommenElternteil,istErwerbstaetig:_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.NO};const initialStepEinkommenState={ET1:initialStepEinkommenElternteil,ET2:initialStepEinkommenElternteil,antragstellende:null,limitEinkommenUeberschritten:null};const sumBruttoEinkommen=(payload,elternteil)=>{const incomeInputType=payload[elternteil].bruttoEinkommenNichtSelbstaendig.type;if(incomeInputType==="average"){return payload[elternteil].bruttoEinkommenNichtSelbstaendig.average*12||0;}if(incomeInputType==="monthly"){var _payload$elternteil$b;return((_payload$elternteil$b=payload[elternteil].bruttoEinkommenNichtSelbstaendig.perMonth)===null||_payload$elternteil$b===void 0?void 0:_payload$elternteil$b.reduce((a,b)=>a+b,0))||0;}return 0;};const sumGewinnEinkommen=(payload,elternteil)=>{const sumGewinnPerYear=payload[elternteil].gewinnSelbstaendig.perYear||0;return sumGewinnPerYear;};const sumMischEinkommen=(payload,elternteil)=>{const mischEinkommen=payload[elternteil].taetigkeitenNichtSelbstaendigUndSelbstaendig.map(period=>{const einkommen=period.bruttoEinkommenDurchschnitt;const numOfMonths=period.zeitraum.map(zeitraum=>{return luxon__WEBPACK_IMPORTED_MODULE_0__/* .DateTime */ .ou.fromISO(zeitraum.to).diff(luxon__WEBPACK_IMPORTED_MODULE_0__/* .DateTime */ .ou.fromISO(zeitraum.from),"months").toObject().months+1;}).reduce((a,b)=>a+b,0);return einkommen*numOfMonths;}).reduce((a,b)=>a+b,0);return mischEinkommen;};const stepEinkommenSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__/* .createSlice */ .oM)({name:"stepEinkommen",initialState:initialStepEinkommenState,reducers:{submitStep:(_,_ref)=>{let{payload}=_ref;const einkommen={ET1:0,ET2:0};const mischEinkommen={ET1:0,ET2:0};const totalEinkommen={ET1:0,ET2:0};const elternteile=["ET1","ET2"];elternteile.forEach(function(elternteil){if(payload[elternteil]&&payload[elternteil].istErwerbstaetig===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.YES){if(_[elternteil].istNichtSelbststaendig){einkommen[elternteil]=sumBruttoEinkommen(payload,elternteil);}if(_[elternteil].istSelbststaendig){einkommen[elternteil]=sumGewinnEinkommen(payload,elternteil);}if(_[elternteil].hasMischEinkommen){mischEinkommen[elternteil]=sumMischEinkommen(payload,elternteil);}totalEinkommen[elternteil]=_[elternteil].hasMischEinkommen===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.YES?mischEinkommen[elternteil]:einkommen[elternteil];}});return{..._,...payload};}},extraReducers:builder=>{builder.addCase(_stepErwerbstaetigkeitSlice__WEBPACK_IMPORTED_MODULE_1__/* .stepErwerbstaetigkeitActions */ .lq.submitStep,(state,_ref2)=>{let{payload}=_ref2;const istErwerbstaetigET1=payload.ET1.vorGeburt;const istErwerbstaetigET2=payload.ET2.vorGeburt;const hasMischEinkommenET1=payload.ET1.isNichtSelbststaendig&&payload.ET1.isSelbststaendig?_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.YES:_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.NO;const hasMischEinkommenET2=payload.ET2.isNichtSelbststaendig&&payload.ET2.isSelbststaendig?_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.YES:_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.NO;const istNichtSelbststaendigET1=payload.ET1.isNichtSelbststaendig===true&&payload.ET1.isSelbststaendig===false;const istNichtSelbststaendigET2=payload.ET2.isNichtSelbststaendig===true&&payload.ET2.isSelbststaendig===false;const istSelbststaendigET1=payload.ET1.isNichtSelbststaendig===false&&payload.ET1.isSelbststaendig===true;const istSelbststaendigET2=payload.ET2.isNichtSelbststaendig===false&&payload.ET2.isSelbststaendig===true;const et1=istErwerbstaetigET1===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.YES?{...state.ET1,istErwerbstaetig:istErwerbstaetigET1,hasMischEinkommen:hasMischEinkommenET1,istSelbststaendig:istSelbststaendigET1,istNichtSelbststaendig:istNichtSelbststaendigET1}:{...resetStepEinkommenElternteil};const et2=istErwerbstaetigET2===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_3__/* .YesNo */ .l.YES?{...state.ET2,istErwerbstaetig:istErwerbstaetigET2,hasMischEinkommen:hasMischEinkommenET2,istSelbststaendig:istSelbststaendigET2,istNichtSelbststaendig:istNichtSelbststaendigET2}:{...resetStepEinkommenElternteil};return{...state,ET1:{...et1},ET2:{...et2}};});builder.addCase(_stepAllgemeineAngabenSlice__WEBPACK_IMPORTED_MODULE_2__/* .stepAllgemeineAngabenActions */ .mk.submitStep,(state,_ref3)=>{let{payload}=_ref3;state.antragstellende=payload.antragstellende;});}});const stepEinkommenActions=stepEinkommenSlice.actions;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stepEinkommenSlice.reducer);

/***/ }),

/***/ 8049:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vf: () => (/* binding */ initialStepErwerbstaetigkeitElternteil),
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   ZT: () => (/* binding */ stepErwerbstaetigkeitElternteilSelectors),
/* harmony export */   lq: () => (/* binding */ stepErwerbstaetigkeitActions)
/* harmony export */ });
/* unused harmony export initialStepErwerbstaetigkeitState */
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7291);
/* harmony import */ var _globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3444);
const initialStepErwerbstaetigkeitElternteil={vorGeburt:null,isNichtSelbststaendig:false,isSelbststaendig:false,mehrereTaetigkeiten:_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_0__/* .YesNo */ .l.NO,sozialVersicherungsPflichtig:null,monatlichesBrutto:null};const initialStepErwerbstaetigkeitState={ET1:initialStepErwerbstaetigkeitElternteil,ET2:initialStepErwerbstaetigkeitElternteil};const stepErwerbstaetigkeitSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__/* .createSlice */ .oM)({name:"stepErwerbstaetigkeit",initialState:initialStepErwerbstaetigkeitState,reducers:{submitStep:(_,action)=>{return action.payload;}}});const isErwerbstaetigVorGeburt=state=>{return state.vorGeburt===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_0__/* .YesNo */ .l.YES;};const hasAnyTypeOfSelbstaendigkeit=state=>state.vorGeburt===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_0__/* .YesNo */ .l.YES&&state.isSelbststaendig;const isOnlyErwerbstaetig=state=>{return state.vorGeburt===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_0__/* .YesNo */ .l.YES&&state.isNichtSelbststaendig&&!hasAnyTypeOfSelbstaendigkeit(state);};const isOnlySelbstaendig=state=>{return state.vorGeburt===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_0__/* .YesNo */ .l.YES&&!state.isNichtSelbststaendig&&hasAnyTypeOfSelbstaendigkeit(state);};const isSelbstaendigOrNoMiniJob=state=>{return state.vorGeburt===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_0__/* .YesNo */ .l.YES&&(hasAnyTypeOfSelbstaendigkeit(state)||state.monatlichesBrutto!=="MiniJob");};const isSelbstaendigAndErwerbstaetig=state=>{return state.vorGeburt===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_0__/* .YesNo */ .l.YES&&state.isNichtSelbststaendig&&hasAnyTypeOfSelbstaendigkeit(state);};const stepErwerbstaetigkeitActions=stepErwerbstaetigkeitSlice.actions;const stepErwerbstaetigkeitElternteilSelectors={isErwerbstaetigVorGeburt,isOnlyErwerbstaetig,isOnlySelbstaendig,isSelbstaendigOrNoMiniJob,isSelbstaendigAndErwerbstaetig};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stepErwerbstaetigkeitSlice.reducer);

/***/ }),

/***/ 8632:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lk: () => (/* binding */ stepNachwuchsActions),
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yb: () => (/* binding */ stepNachwuchsSelectors)
/* harmony export */ });
/* unused harmony export initialStepNachwuchsState */
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7291);
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3553);
/* harmony import */ var _stepAllgemeineAngabenSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(177);
/* harmony import */ var _monatsplaner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2110);
/* harmony import */ var _globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3444);
/* harmony import */ var _utils_locale_formatting__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3227);
const initialStepNachwuchsState={anzahlKuenftigerKinder:0,wahrscheinlichesGeburtsDatum:"",geschwisterkinder:[],mutterschaftssleistungen:_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_2__/* .YesNo */ .l.NO};const stepNachwuchsSlice=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__/* .createSlice */ .oM)({name:"stepNachwuchs",initialState:initialStepNachwuchsState,reducers:{submitStep:(_,_ref)=>{let{payload}=_ref;const filteredEmptyGeschwisterkinder=payload.geschwisterkinder.filter(value=>value.geburtsdatum!=="");return{...payload,geschwisterkinder:filteredEmptyGeschwisterkinder};}},extraReducers:builder=>{builder.addCase(_stepAllgemeineAngabenSlice__WEBPACK_IMPORTED_MODULE_0__/* .stepAllgemeineAngabenActions */ .mk.submitStep,(state,_ref2)=>{let{payload}=_ref2;if(payload.mutterschaftssleistungen===_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_2__/* .YesNo */ .l.YES){state.mutterschaftssleistungen=_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_2__/* .YesNo */ .l.YES;}else{state.mutterschaftssleistungen=_globals_js_calculations_model__WEBPACK_IMPORTED_MODULE_2__/* .YesNo */ .l.NO;}});}});const getWahrscheinlichesGeburtsDatum=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__/* .createSelector */ .P1)(state=>state.stepNachwuchs.wahrscheinlichesGeburtsDatum,wahrscheinlichesGeburtsDatum=>(0,_utils_locale_formatting__WEBPACK_IMPORTED_MODULE_5__/* .parseGermanDateString */ .j)(wahrscheinlichesGeburtsDatum));const getLebensmonateAfterBirth=(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__/* .createSelector */ .P1)(getWahrscheinlichesGeburtsDatum,wahrscheinlichesGeburtsDatum=>{const lebensmonate=(0,_monatsplaner__WEBPACK_IMPORTED_MODULE_1__/* .getLebensmonate */ .Gn)(wahrscheinlichesGeburtsDatum);return lebensmonate.map(month=>({monthIsoString:month.from,labelShort:new Date(month.from).toLocaleDateString("de-DE",{month:"short"}),labelLong:new Date(month.from).toLocaleDateString("de-DE",{month:"long"})}));});const stepNachwuchsSelectors={getWahrscheinlichesGeburtsDatum,getLebensmonateAfterBirth};const stepNachwuchsActions=stepNachwuchsSlice.actions;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stepNachwuchsSlice.reducer);

/***/ }),

/***/ 2760:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  al: () => (/* binding */ calculateElterngeld),
  ZP: () => (/* binding */ redux_stepRechnerSlice),
  Lo: () => (/* binding */ initialBruttoEinkommenZeitraum),
  lq: () => (/* binding */ stepRechnerActions),
  _A: () => (/* binding */ stepRechnerSelectors)
});

// UNUSED EXPORTS: initialStepRechnerState

// EXTERNAL MODULE: ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs + 2 modules
var redux_toolkit_modern = __webpack_require__(7291);
// EXTERNAL MODULE: ./node_modules/reselect/dist/reselect.mjs
var reselect = __webpack_require__(3553);
// EXTERNAL MODULE: ./node_modules/luxon/src/luxon.js + 23 modules
var luxon = __webpack_require__(9779);
// EXTERNAL MODULE: ./src/redux/stepNachwuchsSlice.ts
var stepNachwuchsSlice = __webpack_require__(8632);
// EXTERNAL MODULE: ./src/redux/stepErwerbstaetigkeitSlice.ts
var stepErwerbstaetigkeitSlice = __webpack_require__(8049);
// EXTERNAL MODULE: ./src/globals/js/calculations/model/index.ts + 15 modules
var model = __webpack_require__(3444);
;// CONCATENATED MODULE: ./src/redux/persoenlicheDatenFactory.ts
const erwerbsTaetigkeitVorGeburtOf=(state,elternteil)=>{const erwerbsTaetigkeit=state.stepErwerbstaetigkeit[elternteil];if(erwerbsTaetigkeit.vorGeburt===null||erwerbsTaetigkeit.vorGeburt===model/* YesNo */.l.NO){return model/* ErwerbsArt */.$h.NEIN;}const onlySelbstaendig=stepErwerbstaetigkeitSlice/* stepErwerbstaetigkeitElternteilSelectors */.ZT.isOnlySelbstaendig(erwerbsTaetigkeit);if(onlySelbstaendig){return model/* ErwerbsArt */.$h.JA_SELBSTSTAENDIG;}const isMischeinkommen=stepErwerbstaetigkeitSlice/* stepErwerbstaetigkeitElternteilSelectors */.ZT.isSelbstaendigAndErwerbstaetig(erwerbsTaetigkeit);const mehrereEinkommen=erwerbsTaetigkeit.mehrereTaetigkeiten===model/* YesNo */.l.YES;if(isMischeinkommen||mehrereEinkommen){return model/* ErwerbsArt */.$h.JA_MISCHEINKOMMEN;}if(erwerbsTaetigkeit.monatlichesBrutto==="MiniJob"){return model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI;}return erwerbsTaetigkeit.sozialVersicherungsPflichtig===model/* YesNo */.l.YES?model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI:model/* ErwerbsArt */.$h.JA_NICHT_SELBST_OHNE_SOZI;};const dateOf=date=>{const[day,month,year]=date.split(".");const dateTime=luxon/* DateTime */.ou.fromISO("".concat(year,"-").concat(month,"-").concat(day));return dateTime.toJSDate();};const persoenlicheDatenOfUi=(state,elternteil,bruttoEinkommenZeitraum)=>{var _state$stepAllgemeine;const wahrscheinlichesGeburtsdatum=stepNachwuchsSlice/* stepNachwuchsSelectors */.yb.getWahrscheinlichesGeburtsDatum(state);const persoenlicheDaten=new model/* PersoenlicheDaten */.J4(wahrscheinlichesGeburtsdatum);persoenlicheDaten.anzahlKuenftigerKinder=state.stepNachwuchs.anzahlKuenftigerKinder;persoenlicheDaten.sindSieAlleinerziehend=(_state$stepAllgemeine=state.stepAllgemeineAngaben.alleinerziehend)!==null&&_state$stepAllgemeine!==void 0?_state$stepAllgemeine:model/* YesNo */.l.NO;persoenlicheDaten.etVorGeburt=erwerbsTaetigkeitVorGeburtOf(state,elternteil);persoenlicheDaten.etNachGeburt=bruttoEinkommenZeitraum.length>0?model/* YesNo */.l.YES:model/* YesNo */.l.NO;const kuenftigeKinder=Array.from({length:state.stepNachwuchs.anzahlKuenftigerKinder},(_,index)=>({nummer:index+1,geburtsdatum:undefined,istBehindert:false}));const geschwisterKinder=state.stepNachwuchs.geschwisterkinder.map((kind,index)=>({nummer:index+1+state.stepNachwuchs.anzahlKuenftigerKinder,geburtsdatum:dateOf(kind.geburtsdatum),istBehindert:kind.istBehindert}));persoenlicheDaten.kinder=[...kuenftigeKinder,...geschwisterKinder];return persoenlicheDaten;};
// EXTERNAL MODULE: ./node_modules/big.js/big.mjs
var big = __webpack_require__(8113);
// EXTERNAL MODULE: ./src/globals/js/calculations/common/math-util.ts
var math_util = __webpack_require__(7895);
;// CONCATENATED MODULE: ./src/redux/finanzDatenFactory.ts
const averageFromAverageOrMonthly=averageOrMonthly=>{var _averageOrMonthly$ave,_averageOrMonthly$per;switch(averageOrMonthly.type){case"average":return(_averageOrMonthly$ave=averageOrMonthly.average)!==null&&_averageOrMonthly$ave!==void 0?_averageOrMonthly$ave:0;case"monthly":return averageOrMonthly.perMonth.map(value=>value!==null&&value!==void 0?value:0).reduce((accumulator,currentValue)=>accumulator+currentValue,0)/averageOrMonthly.perMonth.length;case"yearly":return((_averageOrMonthly$per=averageOrMonthly.perYear)!==null&&_averageOrMonthly$per!==void 0?_averageOrMonthly$per:0)/12;}throw new Error("Unknown AverageOrMonthlyState Type.");};const ANZAHL_MONATE_PRO_JAHR=12;const mischEinkommenTaetigkeitenOf=taetigkeiten=>taetigkeiten.map(taetigkeit=>{var _taetigkeit$bruttoEin;const mischEinkommenTaetigkeiten=new model/* MischEkTaetigkeit */.u4();if(taetigkeit.artTaetigkeit==="Selbststaendig"){mischEinkommenTaetigkeiten.erwerbsTaetigkeit=model/* ErwerbsTaetigkeit */.uA.SELBSTSTAENDIG;}if(taetigkeit.isMinijob===model/* YesNo */.l.YES){mischEinkommenTaetigkeiten.erwerbsTaetigkeit=model/* ErwerbsTaetigkeit */.uA.MINIJOB;}mischEinkommenTaetigkeiten.bruttoEinkommenDurchschnitt=(0,big/* default */.Z)((_taetigkeit$bruttoEin=taetigkeit.bruttoEinkommenDurchschnitt)!==null&&_taetigkeit$bruttoEin!==void 0?_taetigkeit$bruttoEin:math_util/* MathUtil */.k.BIG_ZERO);mischEinkommenTaetigkeiten.rentenVersicherungsPflichtig=taetigkeit.versicherungen.hasRentenversicherung?model/* YesNo */.l.YES:model/* YesNo */.l.NO;mischEinkommenTaetigkeiten.krankenVersicherungsPflichtig=taetigkeit.versicherungen.hasKrankenversicherung?model/* YesNo */.l.YES:model/* YesNo */.l.NO;mischEinkommenTaetigkeiten.arbeitslosenVersicherungsPflichtig=taetigkeit.versicherungen.hasArbeitslosenversicherung?model/* YesNo */.l.YES:model/* YesNo */.l.NO;mischEinkommenTaetigkeiten.bemessungsZeitraumMonate=Array.from({length:ANZAHL_MONATE_PRO_JAHR},(_,monthIndex)=>{const taetigkeitHasZeitraumIncludingThisMonth=taetigkeit.zeitraum.some(_ref=>{let{from,to}=_ref;const indexStart=Number.parseInt(from)-1;const indexEnd=Number.parseInt(to)-1;return monthIndex>=indexStart&&monthIndex<=indexEnd;});return taetigkeitHasZeitraumIncludingThisMonth;});return mischEinkommenTaetigkeiten;}).filter(value=>value.getAnzahlBemessungsZeitraumMonate()>0);const erwerbsZeitraumLebensMonatListOf=bruttoEinkommenZeitraumList=>bruttoEinkommenZeitraumList.map(bruttoEinkommenZeitraum=>{var _bruttoEinkommenZeitr;const erwerbsZeitraumLebensMonat=new model/* ErwerbsZeitraumLebensMonat */.dq();erwerbsZeitraumLebensMonat.vonLebensMonat=Number.parseInt(bruttoEinkommenZeitraum.zeitraum.from);erwerbsZeitraumLebensMonat.bisLebensMonat=Number.parseInt(bruttoEinkommenZeitraum.zeitraum.to);const bruttoEinkommen=(_bruttoEinkommenZeitr=bruttoEinkommenZeitraum.bruttoEinkommen)!==null&&_bruttoEinkommenZeitr!==void 0?_bruttoEinkommenZeitr:0;erwerbsZeitraumLebensMonat.bruttoProMonat=new model/* Einkommen */.$J(bruttoEinkommen);return erwerbsZeitraumLebensMonat;});const finanzDatenOfUi=(state,elternteil,bruttoEinkommenZeitraumSanitized)=>{var _state$stepEinkommen$,_state$stepEinkommen$2,_state$stepEinkommen$3,_state$stepEinkommen$4,_state$stepEinkommen$5,_state$stepEinkommen$6;const finanzDaten=new model/* FinanzDaten */.Bf();const stateErwerbsTaetigkeit=state.stepErwerbstaetigkeit[elternteil];const isOnlySelbstaendig=stepErwerbstaetigkeitSlice/* stepErwerbstaetigkeitElternteilSelectors */.ZT.isOnlySelbstaendig(stateErwerbsTaetigkeit);const isSelbstaendigAndErwerbstaetig=stepErwerbstaetigkeitSlice/* stepErwerbstaetigkeitElternteilSelectors */.ZT.isSelbstaendigAndErwerbstaetig(stateErwerbsTaetigkeit);const mehrereEinkommen=stateErwerbsTaetigkeit.mehrereTaetigkeiten===model/* YesNo */.l.YES;const isMiniJob=stateErwerbsTaetigkeit.monatlichesBrutto==="MiniJob";let bruttoEinkommenBeforeBirth=0;if(stateErwerbsTaetigkeit.isNichtSelbststaendig&&!isSelbstaendigAndErwerbstaetig){bruttoEinkommenBeforeBirth=averageFromAverageOrMonthly(state.stepEinkommen[elternteil].bruttoEinkommenNichtSelbstaendig);}if(isOnlySelbstaendig&&!isMiniJob){bruttoEinkommenBeforeBirth=averageFromAverageOrMonthly(state.stepEinkommen[elternteil].gewinnSelbstaendig);}finanzDaten.bruttoEinkommen=new model/* Einkommen */.$J(bruttoEinkommenBeforeBirth);finanzDaten.zahlenSieKirchenSteuer=(_state$stepEinkommen$=state.stepEinkommen[elternteil].zahlenSieKirchenSteuer)!==null&&_state$stepEinkommen$!==void 0?_state$stepEinkommen$:model/* YesNo */.l.NO;finanzDaten.kinderFreiBetrag=(_state$stepEinkommen$2=state.stepEinkommen[elternteil].kinderFreiBetrag)!==null&&_state$stepEinkommen$2!==void 0?_state$stepEinkommen$2:model/* KinderFreiBetrag */.uy.ZKF0;finanzDaten.steuerKlasse=(_state$stepEinkommen$3=state.stepEinkommen[elternteil].steuerKlasse)!==null&&_state$stepEinkommen$3!==void 0?_state$stepEinkommen$3:model/* SteuerKlasse */.nf.SKL_UNBEKANNT;finanzDaten.kassenArt=(_state$stepEinkommen$4=state.stepEinkommen[elternteil].kassenArt)!==null&&_state$stepEinkommen$4!==void 0?_state$stepEinkommen$4:model/* KassenArt */.TN.GESETZLICH_PFLICHTVERSICHERT;finanzDaten.rentenVersicherung=(_state$stepEinkommen$5=state.stepEinkommen[elternteil].rentenVersicherung)!==null&&_state$stepEinkommen$5!==void 0?_state$stepEinkommen$5:model/* RentenArt */.d0.GESETZLICHE_RENTEN_VERSICHERUNG;finanzDaten.splittingFaktor=(_state$stepEinkommen$6=state.stepEinkommen[elternteil].splittingFaktor)!==null&&_state$stepEinkommen$6!==void 0?_state$stepEinkommen$6:1.0;if(isSelbstaendigAndErwerbstaetig||mehrereEinkommen){finanzDaten.mischEinkommenTaetigkeiten=mischEinkommenTaetigkeitenOf(state.stepEinkommen[elternteil].taetigkeitenNichtSelbstaendigUndSelbstaendig);}finanzDaten.erwerbsZeitraumLebensMonatList=erwerbsZeitraumLebensMonatListOf(bruttoEinkommenZeitraumSanitized);return finanzDaten;};
// EXTERNAL MODULE: ./src/globals/js/calculations/common/kind-util.ts
var kind_util = __webpack_require__(417);
;// CONCATENATED MODULE: ./src/globals/js/calculations/abstract-algorithmus.ts
/**
 * Source: de.init.anton.plugins.egr.service.AbstractAlgorithmus
 */class AbstractAlgorithmus{ersatzrate_eg(ek_vor_copy){const ek_vor=ek_vor_copy;const ersatzrate1=model/* EgrBerechnungParamId */.kd.ERSATZRATE1;const ersatzrate2=model/* EgrBerechnungParamId */.kd.ERSATZRATE2;const grenze1=model/* EgrBerechnungParamId */.kd.GRENZE1;const grenze2=model/* EgrBerechnungParamId */.kd.GRENZE2;const grenze3=model/* EgrBerechnungParamId */.kd.GRENZE3;let ersatzrate_eg=ersatzrate1;if(ek_vor.gt(grenze1)){ersatzrate_eg=ersatzrate2;}if(ek_vor.gt(grenze2)&&ek_vor.lte(grenze1)){let y=ek_vor.sub(grenze2);y=y.div((0,big/* default */.Z)(2));y=math_util/* MathUtil */.k.floor(y);y=y.mul((0,big/* default */.Z)(0.001));ersatzrate_eg=ersatzrate1.sub(y);}if(ek_vor.lt(grenze3)){let y=grenze3.sub(ek_vor);y=y.div((0,big/* default */.Z)(2));y=math_util/* MathUtil */.k.floor(y);y=y.mul((0,big/* default */.Z)(0.001));ersatzrate_eg=ersatzrate1.add(y);ersatzrate_eg=math_util/* MathUtil */.k.fMin(ersatzrate_eg,math_util/* MathUtil */.k.BIG_ONE);}return ersatzrate_eg;}/**
   * Suche das Geburtsdatum des jüngsten Kindes.
   *
   * @param kindList Eine Liste von {@link Kind}.
   * @return Das {@link Date} des jüngsten Kindes oder undefined, wenn die Liste leer ist.
   */fktMax(kindList){var _KindUtil$findLastBor;return(_KindUtil$findLastBor=kind_util/* KindUtil */.L.findLastBornChild(kindList))===null||_KindUtil$findLastBor===void 0?void 0:_KindUtil$findLastBor.geburtsdatum;}/**
   * Suche das Geburtsdatum des zweitjüngsten Kindes.
   *
   * @param kindList Eine Liste von {@link Kind}.
   * @return Das {@link Date} des zweitjüngsten Kindes oder undefined, wenn die Liste leer ist oder nur ein Kind enthält.
   */fktZweitMax(kindList){var _KindUtil$findSecondL;return(_KindUtil$findSecondL=kind_util/* KindUtil */.L.findSecondLastBornChild(kindList))===null||_KindUtil$findSecondL===void 0?void 0:_KindUtil$findSecondL.geburtsdatum;}elterngeld_keine_et(ekVor){let ersatzrate=model/* EgrBerechnungParamId */.kd.ERSATZRATE1;let elterngeld_keine_et=ekVor.mul(ersatzrate);if(ekVor.gt(model/* EgrBerechnungParamId */.kd.GRENZE1)){elterngeld_keine_et=math_util/* MathUtil */.k.fMin(model/* EgrBerechnungParamId */.kd.ERSATZRATE2.mul(ekVor),model/* EgrBerechnungParamId */.kd.HOECHSTSATZ);}if(ekVor.gt(model/* EgrBerechnungParamId */.kd.GRENZE2)&&ekVor.lte(model/* EgrBerechnungParamId */.kd.GRENZE1)){ersatzrate=model/* EgrBerechnungParamId */.kd.ERSATZRATE1.sub(math_util/* MathUtil */.k.floor(ekVor.sub(model/* EgrBerechnungParamId */.kd.GRENZE2).div((0,big/* default */.Z)(2.0))).mul((0,big/* default */.Z)(0.001)));elterngeld_keine_et=ekVor.mul(ersatzrate);}if(ekVor.lt(model/* EgrBerechnungParamId */.kd.GRENZE3)){ersatzrate=model/* EgrBerechnungParamId */.kd.ERSATZRATE1.add(math_util/* MathUtil */.k.floor(model/* EgrBerechnungParamId */.kd.GRENZE3.sub(ekVor).div((0,big/* default */.Z)(2))).mul((0,big/* default */.Z)(0.001)));ersatzrate=math_util/* MathUtil */.k.fMin(ersatzrate,(0,big/* default */.Z)(1));elterngeld_keine_et=ekVor.mul(ersatzrate);}elterngeld_keine_et=math_util/* MathUtil */.k.fMax(elterngeld_keine_et,model/* EgrBerechnungParamId */.kd.MINDESTSATZ);return elterngeld_keine_et;}elterngeld_et(ekVor,ekNach){let ersatzrate=math_util/* MathUtil */.k.BIG_ZERO;const ek_diff=math_util/* MathUtil */.k.fMax(math_util/* MathUtil */.k.fMin(ekVor,model/* EgrBerechnungParamId */.kd.HOECHST_ET).sub(ekNach),math_util/* MathUtil */.k.BIG_ZERO);let elterngeld_et=ek_diff.mul(model/* EgrBerechnungParamId */.kd.ERSATZRATE1);if(ekVor.gt(model/* EgrBerechnungParamId */.kd.GRENZE1)){elterngeld_et=math_util/* MathUtil */.k.fMin(model/* EgrBerechnungParamId */.kd.ERSATZRATE2.mul(ek_diff),model/* EgrBerechnungParamId */.kd.HOECHSTSATZ);}if(ekVor.gt(model/* EgrBerechnungParamId */.kd.GRENZE2)&&ekVor.lte(model/* EgrBerechnungParamId */.kd.GRENZE1)){ersatzrate=model/* EgrBerechnungParamId */.kd.ERSATZRATE1.sub(math_util/* MathUtil */.k.floor(ekVor.sub(model/* EgrBerechnungParamId */.kd.GRENZE2).div((0,big/* default */.Z)(2.0))).mul((0,big/* default */.Z)(0.001)));elterngeld_et=ek_diff.mul(ersatzrate);}if(ekVor.lt(model/* EgrBerechnungParamId */.kd.GRENZE3)){ersatzrate=model/* EgrBerechnungParamId */.kd.ERSATZRATE1.add(math_util/* MathUtil */.k.floor(model/* EgrBerechnungParamId */.kd.GRENZE3.sub(ekVor).div((0,big/* default */.Z)(2))).mul((0,big/* default */.Z)(0.001)));ersatzrate=math_util/* MathUtil */.k.fMin(ersatzrate,(0,big/* default */.Z)(1));elterngeld_et=ek_diff.mul(ersatzrate);}elterngeld_et=math_util/* MathUtil */.k.fMax(elterngeld_et,model/* EgrBerechnungParamId */.kd.MINDESTSATZ);return elterngeld_et;}elterngeldplus_et(ekVor,ekNach){let ersatzrate=math_util/* MathUtil */.k.BIG_ZERO;const ek_diff=math_util/* MathUtil */.k.fMax(math_util/* MathUtil */.k.fMin(ekVor,model/* EgrBerechnungParamId */.kd.HOECHST_ET).sub(ekNach),math_util/* MathUtil */.k.BIG_ZERO);let elterngeldplus_et=ek_diff.mul(model/* EgrBerechnungParamId */.kd.ERSATZRATE1);if(ekVor.gt(model/* EgrBerechnungParamId */.kd.GRENZE1)){elterngeldplus_et=math_util/* MathUtil */.k.fMin(model/* EgrBerechnungParamId */.kd.ERSATZRATE2.mul(ek_diff),model/* EgrBerechnungParamId */.kd.HOECHSTSATZ);}if(ekVor.gt(model/* EgrBerechnungParamId */.kd.GRENZE2)&&ekVor.lte(model/* EgrBerechnungParamId */.kd.GRENZE1)){ersatzrate=model/* EgrBerechnungParamId */.kd.ERSATZRATE1.sub(math_util/* MathUtil */.k.floor(ekVor.sub(model/* EgrBerechnungParamId */.kd.GRENZE2).div((0,big/* default */.Z)(2.0))).mul((0,big/* default */.Z)(0.001)));elterngeldplus_et=ek_diff.mul(ersatzrate);}if(ekVor.lt(model/* EgrBerechnungParamId */.kd.GRENZE3)){ersatzrate=model/* EgrBerechnungParamId */.kd.ERSATZRATE1.add(math_util/* MathUtil */.k.floor(model/* EgrBerechnungParamId */.kd.GRENZE3.sub(ekVor).div((0,big/* default */.Z)(2))).mul((0,big/* default */.Z)(0.001)));ersatzrate=math_util/* MathUtil */.k.fMin(ersatzrate,(0,big/* default */.Z)(1));elterngeldplus_et=ek_diff.mul(ersatzrate);}elterngeldplus_et=math_util/* MathUtil */.k.fMax(elterngeldplus_et,model/* EgrBerechnungParamId */.kd.MINDESTSATZ.div((0,big/* default */.Z)(2)));if(elterngeldplus_et.gt((0,big/* default */.Z)(900.0))){elterngeldplus_et=(0,big/* default */.Z)(900.0);}return elterngeldplus_et;}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/egr-steuer-rechner/bmf-abgaben.ts
class BmfAbgaben{constructor(){/**
   * Lohnsteuerzahlung
   */this.lstlzz=new big/* default */.Z(0);/**
   * Für den Lohnzahlungszeitraum einzubehaltender Solidaritätszuschlag
   */this.solzlzz=new big/* default */.Z(0);/**
   * Bemessungsgrundlage für die Kirchenlohnsteuer
   */this.bk=new big/* default */.Z(0);/**
   * Bemessungsgrundlage der sonstigen Bezüge (ohne Vergütung für mehrjährige Tätigkeit) für die Kirchenlohnsteuer
   */this.bks=new big/* default */.Z(0);/**
   * Bemessungsgrundlage der Vergütung für mehrjährige Tätigkeit für die Kirchenlohnsteuer
   */this.bkv=new big/* default */.Z(0);/**
   * Solidaritätszuschlag für sonstige Bezüge (ohne Vergütung für mehrjährige Tätigkeit)
   */this.solzs=new big/* default */.Z(0);/**
   * Solidaritätszuschlag für die Vergütung für mehrjährige Tätigkeit
   */this.solzv=new big/* default */.Z(0);/**
   * Lohnsteuer für sonstige Bezüge (ohne Vergütung für mehrjährige Tätigkeit)
   */this.sts=new big/* default */.Z(0);/**
   * Lohnsteuer für die Vergütung für mehrjährige Tätigkeit
   */this.stv=new big/* default */.Z(0);}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/egr-steuer-rechner/bmf-abgaben-factory.ts
function bmfAbgabenOf(bmfResponse){const bmfAbgaben=new BmfAbgaben();bmfAbgaben.bk=bmfResponse.BK;bmfAbgaben.bks=bmfResponse.BKS;bmfAbgaben.bkv=bmfResponse.BKV;bmfAbgaben.lstlzz=bmfResponse.LSTLZZ;bmfAbgaben.solzlzz=bmfResponse.SOLZLZZ;bmfAbgaben.solzs=bmfResponse.SOLZS;bmfAbgaben.solzv=bmfResponse.SOLZV;bmfAbgaben.sts=bmfResponse.STS;bmfAbgaben.stv=bmfResponse.STV;return bmfAbgaben;}
// EXTERNAL MODULE: ./node_modules/@bmfin/steuerrechner/build/cjs/index.js
var cjs = __webpack_require__(1701);
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/bmf-steuer-rechner/bmf-steuer-rechner-parameter.ts
/**
 * Parameter for BMF Lohn- und Einkommensteuerrechner.
 *
 * Parameter and interface descriptions:
 * - https://www.bmf-steuerrechner.de/interface/einganginterface.xhtml
 * - https://issues.init.de/secure/attachment/708773/708773_2021-11-05-PAP-2022-anlage-1.pdf
 *
 * Field descriptions are copied from:
 * https://issues.init.de/secure/attachment/708773/708773_2021-11-05-PAP-2022-anlage-1.pdf
 */class BmfSteuerRechnerParameter{constructor(){/**
   * Der Lohnzahlungszeitraum. Angabe wie folgt:
   * 1 = Jahr
   * 2 = Monat
   * 3 = Woche
   * 4 = Tag
   */this.LZZ=0;/**
   * Steuerpflichtiger Arbeitslohn für den Lohnzahlungszeitraum vor Berücksichtigung des Versorgungsfreibetrags und
   * des Zuschlags zum Versorgungsfreibetrag, des Altersentlastungsbetrags und des als elektronisches
   * Lohnsteuerabzugsmerkmal festgestellten oder in der Bescheinigung für den Lohnsteuerabzug 2022 für den
   * Lohnzahlungszeitraum eingetragenen Freibetrags bzw. Hinzurechnungsbetrags in Cent.
   */this.RE4=0;/**
   * Steuerklasse:
   * 1 = I
   * 2 = II
   * 3 = III
   * 4 = IV
   * 5 = V
   * 6 = VI
   */this.STKL=1;/**
   * Zahl der Freibeträge für Kinder (eine Dezimalstelle, nur bei Steuerklassen I, II, III und IV).
   */this.ZKF=0;/**
   * Religionsgemeinschaft des Arbeitnehmers lt. elektronischer Lohnsteuerabzugsmerkmale oder der Bescheinigung für den
   * Lohnsteuerabzug 2022 (bei keiner Religionszugehörigkeit = 0).
   */this.R=0;/**
   * Art der Krankenversicherung:
   * 0 = gesetzlich krankenversicherte Arbeitnehmer
   * 1 = ausschließlich privat krankenversicherte Arbeitnehmer ohne Arbeitgeberzuschuss
   * 2 = ausschließlich privat krankenversicherte Arbeitnehmer mit Arbeitgeberzuschuss
   */this.PKV=0;/**
   * Kassenindividueller Zusatzbeitragssatz bei einem gesetzlich krankenversicherten Arbeitnehmer in Prozent
   * (bspw. 1,30 für 1,30 %) mit 2 Dezimalstellen. Es ist der volle Zusatzbeitragssatz anzugeben. Die Aufteilung
   * in Arbeitnehmer- und Arbeitgeberanteil erfolgt im Programmablauf.
   */this.KVZ=0;/**
   * 1, wenn bei der sozialen Pflegeversicherung die Besonderheiten in Sachsen zu berücksichtigen sind
   * bzw. zu berücksichtigen wären.
   */this.PVS=0;/**
   * 1, wenn der Arbeitnehmer den Zuschlag zur sozialen Pflegeversicherung zu zahlen hat.
   */this.PVZ=0;/**
   * KRV Merker für die Vorsorgepauschale:
   * 0 = der Arbeitnehmer ist in der gesetzlichen Rentenversicherung oder einer berufsständischen Versorgungseinrichtung
   * pflichtversichert oder bei Befreiung von der Versicherungspflicht freiwillig versichert; es gilt die
   * allgemeine Beitragsbemessungsgrenze (BBG West)
   *
   * 1 = der Arbeitnehmer ist in der gesetzlichen Rentenversicherung oder einer berufsständischen Versorgungseinrichtung
   * pflichtversichert oder bei Befreiung von der Versicherungspflicht freiwillig versichert; es gilt die
   * Beitragsbemessungsgrenze Ost (BBG Ost)
   *
   * 2 = wenn nicht 0 oder 1
   */this.KRV=0;/**
   * 1, wenn das 64. Lebensjahr vor Beginn des Kalenderjahres vollendet wurde, in dem der Lohnzahlungszeitraum
   * endet (§ 24a EStG), sonst = 0.
   */this.ALTER1=0;/**
   * 1, wenn die Anwendung des Faktorverfahrens gewählt wurde (nur in Steuerklasse IV).
   */this.AF=0;/**
   * Eingetragener Faktor mit drei Nachkommastellen.
   */this.F=0;}}function urlSearchParamsOf(bmfSteuerRechnerParameter){return new URLSearchParams(JSON.parse(JSON.stringify(bmfSteuerRechnerParameter)));}
;// CONCATENATED MODULE: ./src/globals/js/calculations/calculation-error-code.ts
function errorOf(calculationErrorCode){return new Error(calculationErrorCode);}
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/bmf-steuer-rechner/bmf-steuer-rechner-configuration.ts
/**
 * Reads domain for bmf steuerrechner call from env.
 *
 * @see https://www.bmf-steuerrechner.de/interface/einganginterface.xhtml
 */const bmfSteuerRechnerDomainFromEnv=()=>{const domain="";if(domain===undefined){throw errorOf("BmfSteuerRechnerDomainUndefined");}return domain;};/**
 * Available years for bmf steuerrechner remote call.
 */const bmfSteuerRechnerAvailableYearsRemote=()=>{const years="2021,2022";if(years===undefined){throw errorOf("BmfSteuerRechnerAvailableYearsUndefined");}return years.split(",").map(years=>Number.parseInt(years));};/**
 * Available years for bmf steuerrechner lib.
 */const bmfSteuerRechnerAvailableYearsLib=()=>{const years="2022,2023";if(years===undefined){throw errorOf("BmfSteuerRechnerAvailableYearsUndefined");}return years.split(",").map(years=>Number.parseInt(years));};/**
 * Reads code for bmf steuerrechner call from env.
 *
 * @see https://www.bmf-steuerrechner.de/interface/einganginterface.xhtml
 */const bmfSteuerRechnerCodeFromEnv=()=>{const code="2022eP";if(code===undefined){throw errorOf("BmfSteuerRechnerCodeUndefined");}return code;};/**
 * Creates url for bmf steuerrechner call.
 *
 * @param lohnSteuerJahr Lohnsteuerjahr for correct version page. Must be greater than 2020.
 * @param bmfSteuerRechnerParameter Parameter for BMF Lohn- und Einkommensteuerrechner.
 * @return {RequestOptions} with correct hostname and path.
 *
 * @see https://www.bmf-steuerrechner.de/interface/einganginterface.xhtml
 */function bmfSteuerRechnerUrlOf(lohnSteuerJahr,bmfSteuerRechnerParameter){if(!bmfSteuerRechnerAvailableYearsRemote().includes(lohnSteuerJahr)){throw errorOf("BmfSteuerRechnerNotImplementedForLohnsteuerjahr");}const version="".concat(lohnSteuerJahr,"Version1");const searchParams=urlSearchParamsOf(bmfSteuerRechnerParameter);searchParams.append("code",bmfSteuerRechnerCodeFromEnv());const urlPath="/interface/".concat(version,".xhtml?").concat(searchParams.toString());const bmfSteuerRechnerDomain=bmfSteuerRechnerDomainFromEnv();if(bmfSteuerRechnerDomain.length>0){return"https://".concat(bmfSteuerRechnerDomainFromEnv()).concat(urlPath);}else{return urlPath;}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/bmf-steuer-rechner/bmf-steuer-rechner-response.ts
/**
 * Response from BMF Lohn- und Einkommensteuerrechner.
 *
 * Response and interface descriptions:
 * - https://www.bmf-steuerrechner.de/interface/einganginterface.xhtml
 * - https://issues.init.de/secure/attachment/708773/708773_2021-11-05-PAP-2022-anlage-1.pdf
 *
 * Only "Ausgangsparameter" of the response are mapped. "Ausgangsparameter DBA" not included.
 *
 * Field descriptions are copied from:
 * https://issues.init.de/secure/attachment/708773/708773_2021-11-05-PAP-2022-anlage-1.pdf
 */class BmfSteuerRechnerResponse{constructor(){/**
   * Bemessungsgrundlage für die Kirchenlohnsteuer in Cent
   */this.BK=new big/* default */.Z(0);/**
   * Bemessungsgrundlage der sonstigen Bezüge (ohne Vergütung für
   * mehrjährige Tätigkeit) für die Kirchenlohnsteuer in Cent.
   * Hinweis: Negativbeträge, die aus nicht zu besteuernden Vorteilen bei
   * Vermögensbeteiligungen (§ 19a Absatz 1 Satz 4 EStG) resultieren,
   * mindern BK (maximal bis 0). Der Sonderausgabenabzug für
   * tatsächlich erbrachte Vorsorgeaufwendungen im Rahmen der
   * Veranlagung zur Einkommensteuer bleibt unberührt.
   */this.BKS=new big/* default */.Z(0);/**
   * Bemessungsgrundlage der Vergütung für mehrjährige Tätigkeit und
   * der tarifermäßigt zu besteuernden Vorteile bei
   * Vermögensbeteiligungen für die Kirchenlohnsteuer in Cent
   */this.BKV=new big/* default */.Z(0);/**
   * Für den Lohnzahlungszeitraum einzubehaltende Lohnsteuer in Cent
   */this.LSTLZZ=new big/* default */.Z(0);/**
   * Für den Lohnzahlungszeitraum einzubehaltender
   * Solidaritätszuschlag in Cent
   */this.SOLZLZZ=new big/* default */.Z(0);/**
   * Solidaritätszuschlag für sonstige Bezüge (ohne Vergütung für
   * mehrjährige Tätigkeit in Cent.
   * Hinweis: Negativbeträge, die aus nicht zu besteuernden Vorteilen bei
   * Vermögensbeteiligungen (§ 19a Absatz 1 Satz 4 EStG) resultieren,
   * mindern SOLZLZZ (maximal bis 0). Der Sonderausgabenabzug für
   * tatsächlich erbrachte Vorsorgeaufwendungen im Rahmen der
   * Veranlagung zur Einkommensteuer bleibt unberührt.
   */this.SOLZS=new big/* default */.Z(0);/**
   * Solidaritätszuschlag für die Vergütung für mehrjährige Tätigkeit und
   * der tarifermäßigt zu besteuernden Vorteile bei
   * Vermögensbeteiligungen in Cent
   */this.SOLZV=new big/* default */.Z(0);/**
   * Lohnsteuer für sonstige Bezüge (ohne Vergütung für mehrjährige
   * Tätigkeit und ohne tarifermäßigt zu besteuernde Vorteile bei
   * Vermögensbeteiligungen) in Cent
   * Hinweis: Negativbeträge, die aus nicht zu besteuernden Vorteilen bei
   * Vermögensbeteiligungen (§ 19a Absatz 1 Satz 4 EStG) resultieren,
   * mindern LSTLZZ (maximal bis 0). Der Sonderausgabenabzug für
   * tatsächlich erbrachte Vorsorgeaufwendungen im Rahmen der
   * Veranlagung zur Einkommensteuer bleibt unberührt.
   */this.STS=new big/* default */.Z(0);/**
   * Lohnsteuer für die Vergütung für mehrjährige Tätigkeit und der
   * tarifermäßigt zu besteuernden Vorteile bei Vermögensbeteiligungen
   * in Cent
   */this.STV=new big/* default */.Z(0);/**
   * Für den Lohnzahlungszeitraum berücksichtigte Beiträge des
   * Arbeitnehmers zur privaten Basis-Krankenversicherung und privaten
   * Pflege-Pflichtversicherung (ggf. auch die Mindestvorsorgepauschale)
   * in Cent beim laufenden Arbeitslohn. Für Zwecke der
   * Lohnsteuerbescheinigung sind die einzelnen Ausgabewerte
   * außerhalb des eigentlichen Lohnsteuerberechnungsprogramms zu
   * addieren; hinzuzurechnen sind auch die Ausgabewerte VKVSONST.
   */this.VKVLZZ=new big/* default */.Z(0);/**
   * Für den Lohnzahlungszeitraum berücksichtigte Beiträge des
   * Arbeitnehmers zur privaten Basis-Krankenversicherung und privaten
   * Pflege-Pflichtversicherung (ggf. auch die Mindestvorsorgepauschale)
   * in Cent bei sonstigen Bezügen. Der Ausgabewert kann auch negativ
   * sein. Für tarifermäßigt zu besteuernde Vergütungen für mehrjährige
   * Tätigkeiten enthält der PAP keinen entsprechenden Ausgabewert.
   */this.VKVSONST=new big/* default */.Z(0);}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/bmf-steuer-rechner/bmf-steuer-rechner-response-parser.ts
/**
 * Parser for XML response from BMF Lohn- und Einkommensteuerrechner.
 *
 * Response and interface descriptions:
 * - https://www.bmf-steuerrechner.de/interface/einganginterface.xhtml
 * - https://issues.init.de/secure/attachment/708773/708773_2021-11-05-PAP-2022-anlage-1.pdf
 */let BmfSteuerRechnerResponseParser;(function(_BmfSteuerRechnerResponseParser){const parser=new DOMParser();const fillResponseFromXmlElement=(xmlElement,response)=>{const name=xmlElement.getAttribute("name");if(name==null){return;}const value=xmlElement.getAttribute("value");if(value==null){return;}let fieldName;for(fieldName in response){if(fieldName===name){// Values from bmf xml are cents, response values are euros
response[fieldName]=(0,big/* default */.Z)(value).div(100);}}};/**
   * Parse XML response from BMF Lohn- und Einkommensteuerrechner from a string into BmfLohnRechnerResponse.
   *
   * @param xml XML response from BMF Lohn- und Einkommensteuerrechner
   *
   * @return BmfLohnRechnerResponse from BMF Lohn- und Einkommensteuerrechner
   */function parse(xml){const response=new BmfSteuerRechnerResponse();const document=parser.parseFromString(xml,"text/xml");const ausgabeElementList=document.getElementsByTagName("ausgabe");for(let i=0;i<ausgabeElementList.length;i++){const xmlElement=ausgabeElementList.item(i);if(xmlElement){fillResponseFromXmlElement(xmlElement,response);}}return response;}_BmfSteuerRechnerResponseParser.parse=parse;})(BmfSteuerRechnerResponseParser||(BmfSteuerRechnerResponseParser={}));
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/bmf-steuer-rechner/bmf-steuer-rechner-response-converter.ts
let BmfSteuerRechnerResponseConverter;(function(_BmfSteuerRechnerResponseConverter){const convert=_BmfSteuerRechnerResponseConverter.convert=lstOutput=>({BK:toBigEuro(lstOutput.BK),BKS:toBigEuro(lstOutput.BKS),BKV:toBigEuro(lstOutput.BKV),LSTLZZ:toBigEuro(lstOutput.LSTLZZ),SOLZLZZ:toBigEuro(lstOutput.SOLZLZZ),SOLZS:toBigEuro(lstOutput.SOLZS),SOLZV:toBigEuro(lstOutput.SOLZV),STS:toBigEuro(lstOutput.STS),STV:toBigEuro(lstOutput.STV),VKVLZZ:toBigEuro(lstOutput.VKVLZZ),VKVSONST:toBigEuro(lstOutput.VKVSONST)});const toBigEuro=cent=>(0,big/* default */.Z)(cent).div(100);})(BmfSteuerRechnerResponseConverter||(BmfSteuerRechnerResponseConverter={}));
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/bmf-steuer-rechner/bmf-steuer-rechner-parameter-converter.ts
let BmfSteuerRechnerParameterConverter;(function(_BmfSteuerRechnerParameterConverter){const convert=_BmfSteuerRechnerParameterConverter.convert=parameter=>({LZZ:parameter.LZZ,RE4:(0,big/* default */.Z)(parameter.RE4),STKL:parameter.STKL,ZKF:(0,big/* default */.Z)(parameter.ZKF),R:parameter.R,PKV:parameter.PKV,KVZ:(0,big/* default */.Z)(parameter.KVZ),PVS:parameter.PVS===1,PVZ:parameter.PVZ===1,KRV:parameter.KRV,ALTER1:parameter.ALTER1===1,AF:parameter.AF===1,F:(0,big/* default */.Z)(parameter.F)});})(BmfSteuerRechnerParameterConverter||(BmfSteuerRechnerParameterConverter={}));
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/bmf-steuer-rechner/bmf-steuer-rechner.ts
/**
 * Namespace for function to call the BMF Lohn- und Einkommensteuerrechner.
 *
 * BMF Lohn- und Einkommensteuerrechner descriptions:
 * - https://www.bmf-steuerrechner.de/interface/einganginterface.xhtml
 * - https://issues.init.de/secure/attachment/708773/708773_2021-11-05-PAP-2022-anlage-1.pdf
 */let BmfSteuerRechner;(function(_BmfSteuerRechner){const USE_REMOTE_STEUER_RECHNER=_BmfSteuerRechner.USE_REMOTE_STEUER_RECHNER=false;async function call(lohnSteuerJahr,bmfSteuerRechnerParameter){let response;if(USE_REMOTE_STEUER_RECHNER){response=await callRemoteRechner(lohnSteuerJahr,bmfSteuerRechnerParameter);}else{response=await callRechnerLib(lohnSteuerJahr,bmfSteuerRechnerParameter);}return response;}_BmfSteuerRechner.call=call;})(BmfSteuerRechner||(BmfSteuerRechner={}));async function callRechnerLib(lohnSteuerJahr,bmfSteuerRechnerParameter){const lstInput=BmfSteuerRechnerParameterConverter.convert(bmfSteuerRechnerParameter);const lstOutput=lst(lohnSteuerJahr,lstInput);return BmfSteuerRechnerResponseConverter.convert(lstOutput);}function lst(lohnSteuerJahr,lstInput){if(lohnSteuerJahr===2022){return (0,cjs/* LST */.w8)("2022.1",lstInput);}return (0,cjs/* LST */.w8)("2023.1",lstInput);}async function callRemoteRechner(lohnSteuerJahr,bmfSteuerRechnerParameter){const url=bmfSteuerRechnerUrlOf(lohnSteuerJahr,bmfSteuerRechnerParameter);const xml=await queryBmfSteuerRechner(url);return BmfSteuerRechnerResponseParser.parse(xml);}const queryBmfSteuerRechner=url=>{return fetch(url).then(function(response){return response.text();}).catch(function(reason){console.error(reason);throw errorOf("BmfSteuerRechnerCallFailed");});};
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/bmf-steuer-rechner/index.ts

;// CONCATENATED MODULE: ./src/globals/js/calculations/common/logger.ts
let Logger;(function(_Logger){function log(message){const loggerEnabled="false";if(loggerEnabled==="true"){console.log(message);}}_Logger.log=log;})(Logger||(Logger={}));
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/egr-steuer-rechner/egr-steuer-rechner.ts
/**
 * EGR-Steuerrechner. Wrapper for BMF Lohn- und Einkommensteuerrechner with EGR data model.
 */class EgrSteuerRechner{static bestLohnSteuerJahrOf(wahrscheinlichesGeburtsDatum){const geburtsDatumJahr=wahrscheinlichesGeburtsDatum.getFullYear();const jahrVorDerGeburt=geburtsDatumJahr-1;const availableYears=BmfSteuerRechner.USE_REMOTE_STEUER_RECHNER?bmfSteuerRechnerAvailableYearsRemote():bmfSteuerRechnerAvailableYearsLib();if(availableYears.includes(jahrVorDerGeburt)){return jahrVorDerGeburt;}const minAvailableYear=Math.min(...availableYears);if(jahrVorDerGeburt<minAvailableYear){return minAvailableYear;}const maxAvailableYear=Math.max(...availableYears);if(jahrVorDerGeburt>maxAvailableYear){return maxAvailableYear;}throw errorOf("BmfSteuerRechnerNotImplementedForLohnsteuerjahr");}/**
   * Ermittlung der Abgaben unter Nutzung der Schnittstelle des Brutto-Netto-Rechners des BMF.
   *
   * Source: de.init.anton.plugins.egr.service.BruttoNettoRechner.abgabenSteuern(...)
   *
   * @param {FinanzDaten} finanzDaten Angaben zum Einkommen.
   * @param {ErwerbsArt} erwerbsArt Art des Einkommens (selbstständig, angestellt, ...)
   * @param bruttoProMonat Steuerpflichtiger durchschnittlicher Arbeitslohn pro Monat für das angegebene Jahr.
   * @param lohnSteuerJahr Das Lohnsteuerjahr des angegebenen steuerpflichtigen Arbeitslohns.
   */async abgabenSteuern(finanzDaten,erwerbsArt,bruttoProMonat,lohnSteuerJahr){const parameter=new BmfSteuerRechnerParameter();if(erwerbsArt===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI){finanzDaten.kinderFreiBetrag=model/* KinderFreiBetrag */.uy.ZKF0;}// Zusatzbeitrag ist laut Herrn Klos jetzt immer 0,9
parameter.KVZ=0.9;parameter.ALTER1=0;if(finanzDaten.steuerKlasse===model/* SteuerKlasse */.nf.SKL4_FAKTOR){var _finanzDaten$splittin;parameter.AF=1;parameter.F=(_finanzDaten$splittin=finanzDaten.splittingFaktor)!==null&&_finanzDaten$splittin!==void 0?_finanzDaten$splittin:1.0;}else{parameter.AF=0;parameter.F=1.0;}const steuerklasseNumber=(0,model/* steuerklasseToNumber */.Dj)(finanzDaten.steuerKlasse);parameter.STKL=steuerklasseNumber===undefined?1:steuerklasseNumber;parameter.ZKF=(0,model/* kinderFreiBetragToNumber */.W9)(finanzDaten.kinderFreiBetrag);parameter.R=finanzDaten.zahlenSieKirchenSteuer===model/* YesNo */.l.NO?0:1;parameter.KRV=erwerbsArt===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_OHNE_SOZI?2:0;parameter.LZZ=2;let einkommenInCent=bruttoProMonat.mul((0,big/* default */.Z)(100));if(model/* ErwerbsArt */.$h.JA_SELBSTSTAENDIG===erwerbsArt){einkommenInCent=einkommenInCent.add(model/* EgrBerechnungParamId */.kd.PAUSCH.mul((0,big/* default */.Z)(100)));}parameter.RE4=einkommenInCent.round(0,big/* default */.Z.roundHalfUp).toNumber();try{const bmfResponse=await BmfSteuerRechner.call(lohnSteuerJahr,parameter);return bmfAbgabenOf(bmfResponse);}catch(e){Logger.log(e);throw errorOf("BmfSteuerRechnerCallFailed");}}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/egr-steuer-rechner/index.ts

;// CONCATENATED MODULE: ./src/globals/js/calculations/brutto-netto-rechner/brutto-netto-rechner.ts
class BruttoNettoRechner{constructor(){this.egrSteuerRechner=new EgrSteuerRechner();}/**
   * Methode zum Ermitteln der Abzüge anhand des durchschnittlichen monatlichen Bruttogehaltes
   *
   * @param {Big} bruttoProMonat Steuerpflichtiger durchschnittlicher Arbeitslohn pro Monat für das angegebene Jahr.
   * @param {number} lohnSteuerJahr Das Lohnsteuerjahr des angegebenen steuerpflichtigen Arbeitslohns.
   * @param {FinanzDaten} finanzDaten Angaben zum Einkommen.
   * @param {ErwerbsArt} erwerbsArt Art des Einkommens (selbstständig, angestellt, ...)
   * @return {Big} Die Höhe der Abzüge.
   * @throws EgrBerechnungException
   */async abzuege(bruttoProMonat,lohnSteuerJahr,finanzDaten,erwerbsArt){let rentenversicherungspflichtig=finanzDaten.rentenVersicherung===model/* RentenArt */.d0.GESETZLICHE_RENTEN_VERSICHERUNG;let krankenversicherungspflichtig=finanzDaten.kassenArt===model/* KassenArt */.TN.GESETZLICH_PFLICHTVERSICHERT;if(erwerbsArt===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI){rentenversicherungspflichtig=true;}if(erwerbsArt===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_OHNE_SOZI){rentenversicherungspflichtig=false;krankenversicherungspflichtig=false;}// in 2023 only rentenversicherungspflichtig: https://www.dgb.de/schwerpunkt/minijob
if(erwerbsArt===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI){krankenversicherungspflichtig=false;rentenversicherungspflichtig=true;}let steuerKlasse=finanzDaten.steuerKlasse;let splittingFaktor=finanzDaten.splittingFaktor;if(erwerbsArt===model/* ErwerbsArt */.$h.JA_SELBSTSTAENDIG){steuerKlasse=model/* SteuerKlasse */.nf.SKL4;splittingFaktor=1.0;}// TODO Prüfen on diese Zuweisungen nötig und sinnvoll sind, wenn die Methode vom EGR aufgerufen wird.
finanzDaten.steuerKlasse=steuerKlasse;finanzDaten.splittingFaktor=splittingFaktor;return await this.berechneSteuernAbgaben(finanzDaten,krankenversicherungspflichtig,rentenversicherungspflichtig,erwerbsArt,bruttoProMonat,lohnSteuerJahr);}/**
   * Methode zum Ermitteln des Zwischenergebnisses, wurde aus VB übernommen. Variablen haben identische Namen wie in
   * VB. Soll auch so bleiben.
   *
   * @param {FinanzDaten} finanzdaten
   * @param erwerbsArtVorGeburt
   * @param lohnSteuerJahr
   * @return {NettoEinkommen}
   */async nettoEinkommenZwischenErgebnis(finanzdaten,erwerbsArtVorGeburt,lohnSteuerJahr){let netto=new model/* Einkommen */.$J(0);const status=erwerbsArtVorGeburt;const brutto=finanzdaten.bruttoEinkommen.value;const art_rv=finanzdaten.rentenVersicherung;const art_kv=finanzdaten.kassenArt;let rentenversicherungspflichtig;let krankenversicherungspflichtig;rentenversicherungspflichtig=art_rv===model/* RentenArt */.d0.GESETZLICHE_RENTEN_VERSICHERUNG;krankenversicherungspflichtig=art_kv===model/* KassenArt */.TN.GESETZLICH_PFLICHTVERSICHERT;if(status===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_OHNE_SOZI){rentenversicherungspflichtig=false;krankenversicherungspflichtig=false;}if(status===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI){rentenversicherungspflichtig=true;}if(status!==model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI){const steuerUndAbgaben=await this.berechneSteuernAbgaben(finanzdaten,krankenversicherungspflichtig,rentenversicherungspflichtig,status,brutto,lohnSteuerJahr);netto.value=brutto.sub(steuerUndAbgaben);}else{netto.value=brutto;}return netto;}/**
   * Methode errechnet Abzüge (Lohnsteuer, Kirchensteuer) vom Bruttogehalt.
   */async summeSteuer(finanzdaten,erwerbsArt,bruttoProMonat,lohnSteuerJahr){const charge=await this.egrSteuerRechner.abgabenSteuern(finanzdaten,erwerbsArt,bruttoProMonat,lohnSteuerJahr);const kirchensteuersatz=8;let kirchenlohnsteuer=BruttoNettoRechner.calculateChurchTaxes(kirchensteuersatz,charge.bk);kirchenlohnsteuer=math_util/* MathUtil */.k.round(kirchenlohnsteuer);let summeSteuer=charge.lstlzz.add(charge.solzlzz);if(bruttoProMonat.lte(model/* EgrBerechnungParamId */.kd.GRENZE_MINI_MIDI)){kirchenlohnsteuer=math_util/* MathUtil */.k.BIG_ZERO;summeSteuer=math_util/* MathUtil */.k.BIG_ZERO;}Logger.log("Lohnsteuer: ".concat(charge.lstlzz));Logger.log("SoliZuschlag: ".concat(charge.solzlzz));Logger.log("Kirchensteuer: ".concat(kirchenlohnsteuer));return summeSteuer.add(kirchenlohnsteuer);}/**
   * Methode errechnet Abzüge vom Bruttogehalt in Summe (Lohnsteuer, Kirchensteuer und Sozialabgaben).
   */async berechneSteuernAbgaben(finanzdaten,krankenversicherungspflichtig,rentenversicherungspflichtig,status,bruttoProMonat,lohnSteuerJahr){const summeSteuer=await this.summeSteuer(finanzdaten,status,bruttoProMonat,lohnSteuerJahr);let summe_sozab=BruttoNettoRechner.summer_svb(krankenversicherungspflichtig,rentenversicherungspflichtig,status,bruttoProMonat);summe_sozab=math_util/* MathUtil */.k.round(summe_sozab);Logger.log("Summe Sozialabgaben: ".concat(summe_sozab));return summeSteuer.add(summe_sozab);}/**
   * Ermittlung der Sozialversicherungsabgaben in Summe.
   */static summer_svb(krankenversicherungspflichtig_sub,rentenversicherungspflichtig_sub,status_sub,brutto_sub){let abgaben_kvpv=math_util/* MathUtil */.k.BIG_ZERO;let abgaben_rv=math_util/* MathUtil */.k.BIG_ZERO;let abgaben_alv=math_util/* MathUtil */.k.BIG_ZERO;let abgaben_gleitzone=math_util/* MathUtil */.k.BIG_ZERO;const brutto_rech_sub=brutto_sub;const satz_kvpv_beeg=model/* EgrBerechnungParamId */.kd.SATZ_KVPV_BEEG;const satz_rv_beeg=model/* EgrBerechnungParamId */.kd.SATZ_RV_BEEG;const satz_alv_beeg=model/* EgrBerechnungParamId */.kd.SATZ_ALV_BEEG;const f_faktor=model/* EgrBerechnungParamId */.kd.F_FAKTOR;const grenze_mini_midi=model/* EgrBerechnungParamId */.kd.GRENZE_MINI_MIDI;const grenze_midi_max=model/* EgrBerechnungParamId */.kd.GRENZE_MIDI_MAX;if(brutto_rech_sub.gt(grenze_midi_max)||brutto_rech_sub.lte(grenze_mini_midi)){if(krankenversicherungspflichtig_sub){abgaben_kvpv=brutto_rech_sub.mul(satz_kvpv_beeg);}if(rentenversicherungspflichtig_sub){abgaben_rv=brutto_rech_sub.mul(satz_rv_beeg);}if(status_sub===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI){abgaben_alv=brutto_rech_sub.mul(satz_alv_beeg);}}if(brutto_rech_sub.gt(grenze_mini_midi)&&brutto_rech_sub.lte(grenze_midi_max)){let beitragsatz=math_util/* MathUtil */.k.BIG_ZERO;const tmp=f_faktor.mul(grenze_mini_midi);const bd850_450=grenze_midi_max.sub(grenze_mini_midi);const bd850=grenze_midi_max;const bd450=grenze_mini_midi;let x;let y;x=bd850.div(bd850_450);y=bd450.mul(f_faktor);y=y.div(bd850_450);const tmp2=x.sub(y);const tmp3=brutto_rech_sub.sub(grenze_mini_midi);let bemessungsentgelt=tmp2.mul(tmp3);bemessungsentgelt=bemessungsentgelt.add(tmp);if(krankenversicherungspflichtig_sub){beitragsatz=beitragsatz.add(satz_kvpv_beeg);}if(rentenversicherungspflichtig_sub){beitragsatz=beitragsatz.add(satz_rv_beeg);}if(status_sub===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI){beitragsatz=beitragsatz.add(satz_alv_beeg);}abgaben_gleitzone=beitragsatz.mul(bemessungsentgelt);abgaben_kvpv=math_util/* MathUtil */.k.round(abgaben_kvpv);abgaben_rv=math_util/* MathUtil */.k.round(abgaben_rv);abgaben_alv=math_util/* MathUtil */.k.round(abgaben_alv);abgaben_gleitzone=math_util/* MathUtil */.k.round(abgaben_gleitzone);}Logger.log("KV: ".concat(abgaben_kvpv));Logger.log("RV: ".concat(abgaben_rv));Logger.log("ALV: ".concat(abgaben_alv));Logger.log("Gleitzone: ".concat(abgaben_gleitzone));return abgaben_kvpv.add(abgaben_rv).add(abgaben_alv).add(abgaben_gleitzone);}/**
   * Ermittlung der Sozialversicherungsabgaben in Summe für Mischeinkünfte
   *
   * //@formatter:off
   * Public Function summe_svb_misch(grenze_rv_sub, krankenversicherungspflichtig_sub, rentenversicherungspflichtig_sub, status_sub, brutto_sub)
   *
   * 'Berechnung Sozialabgaben
   *
   * abgaben_kvpv = 0
   * abgaben_rv = 0
   * abgaben_alv = 0
   * abgaben_gleitzone = 0
   * brutto_rech_sub = brutto_sub
   *
   * If krankenversicherungspflichtig_sub = 1 Then abgaben_kvpv = brutto_rech_sub * satz_kvpv_beeg
   * If rentenversicherungspflichtig_sub = 1 Then abgaben_rv = brutto_rech_sub * satz_rv_beeg
   * If status_sub = 2 Then abgaben_alv = brutto_rech_sub * satz_alv_beeg
   *
   * abgaben_kvpv = Round(abgaben_kvpv, 2)
   * abgaben_rv = Round(abgaben_rv, 2)
   * abgaben_alv = Round(abgaben_alv, 2)
   * summe_svb_misch = Round(abgaben_kvpv + abgaben_rv + abgaben_alv, 2)
   * End Function
   * //@formatter:on
   *
   * @param {boolean} krankenversicherungspflichtig_sub
   * @param {boolean} rentenversicherungspflichtig_sub
   * @param {ErwerbsArt} status_sub
   * @param {Big} brutto_sub
   * @return {Big}
   */summe_svb_misch(krankenversicherungspflichtig_sub,rentenversicherungspflichtig_sub,status_sub,brutto_sub){let abgaben_kvpv=math_util/* MathUtil */.k.BIG_ZERO;let abgaben_rv=math_util/* MathUtil */.k.BIG_ZERO;let abgaben_alv=math_util/* MathUtil */.k.BIG_ZERO;const brutto_rech_sub=brutto_sub;const satz_kvpv_beeg=model/* EgrBerechnungParamId */.kd.SATZ_KVPV_BEEG;const satz_rv_beeg=model/* EgrBerechnungParamId */.kd.SATZ_RV_BEEG;const satz_alv_beeg=model/* EgrBerechnungParamId */.kd.SATZ_ALV_BEEG;if(krankenversicherungspflichtig_sub){abgaben_kvpv=brutto_rech_sub.mul(satz_kvpv_beeg);}if(rentenversicherungspflichtig_sub){abgaben_rv=brutto_rech_sub.mul(satz_rv_beeg);}if(status_sub===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI){abgaben_alv=brutto_rech_sub.mul(satz_alv_beeg);}abgaben_kvpv=math_util/* MathUtil */.k.round(abgaben_kvpv);abgaben_rv=math_util/* MathUtil */.k.round(abgaben_rv);abgaben_alv=math_util/* MathUtil */.k.round(abgaben_alv);Logger.log("KV: ".concat(abgaben_kvpv));Logger.log("RV: ".concat(abgaben_rv));Logger.log("ALV: ".concat(abgaben_alv));return math_util/* MathUtil */.k.round(abgaben_kvpv.add(abgaben_rv).add(abgaben_alv));}static calculateChurchTaxes(kirchensteuersatz,bk){return bk.div(math_util/* MathUtil */.k.BIG_100).mul((0,big/* default */.Z)(kirchensteuersatz));}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/basis-eg-algorithmus.ts
const basis_eg_algorithmus_ANZAHL_MONATE_PRO_JAHR=12;/**
 * Bildet die Berechnung von Netto und Basiselterngeld ab.
 */class BasisEgAlgorithmus extends AbstractAlgorithmus{/**
   * Bildet die Berechnung von Netto und Basiselterngeld für Mischeinkommen ab.
   *
   * @param {PersoenlicheDaten} persoenlicheDaten Persönliche Angaben für die Berechnung des Elterngeldes.
   * @param {FinanzDaten} finanzDaten Angaben zum Einkommen.
   * @param {number} lohnSteuerJahr Das Lohnsteuerjahr des angegebenen steuerpflichtigen Arbeitslohns.
   *
   * @return Das Zwischenergebnis bei Mischeinkommen.
   */async berechneMischNettoUndBasiselterngeld(persoenlicheDaten,finanzDaten,lohnSteuerJahr){let netto;let steuern=(0,big/* default */.Z)(0);let abgaben=(0,big/* default */.Z)(0);finanzDaten.mischEinkommenTaetigkeiten.forEach(mischEkTaetigkeit=>{if(math_util/* MathUtil */.k.greater(mischEkTaetigkeit.bruttoEinkommenDurchschnitt,model/* EgrBerechnungParamId */.kd.GRENZE_MINI_MIDI)&&math_util/* MathUtil */.k.lessOrEqual(mischEkTaetigkeit.bruttoEinkommenDurchschnitt,model/* EgrBerechnungParamId */.kd.GRENZE_MIDI_MAX)&&mischEkTaetigkeit.erwerbsTaetigkeit===model/* ErwerbsTaetigkeit */.uA.NICHT_SELBSTSTAENDIG){const midiRange=model/* EgrBerechnungParamId */.kd.GRENZE_MIDI_MAX.sub(model/* EgrBerechnungParamId */.kd.GRENZE_MINI_MIDI);const overMini=mischEkTaetigkeit.bruttoEinkommenDurchschnitt.sub(model/* EgrBerechnungParamId */.kd.GRENZE_MINI_MIDI);const faktoredMin=model/* EgrBerechnungParamId */.kd.F_FAKTOR.mul(model/* EgrBerechnungParamId */.kd.GRENZE_MINI_MIDI);const faktoredMidi=model/* EgrBerechnungParamId */.kd.GRENZE_MIDI_MAX.sub(faktoredMin).div(midiRange).mul(overMini);mischEkTaetigkeit.bruttoEinkommenDurchschnittMidi=faktoredMin.add(faktoredMidi);}});let betrachtungsmonate=0;let letzter_Betrachtungsmonat=0;let zaehler_Pauschmonate=0;const monate_pausch=new Array(12).fill(0);for(let i=0;i<basis_eg_algorithmus_ANZAHL_MONATE_PRO_JAHR;i++){let tmpBetrachtungsmonateFlag=false;let array=finanzDaten.mischEinkommenTaetigkeiten;for(let index=0;index<array.length;index++){let mischEkTaetigkeit=array[index];if(mischEkTaetigkeit.bemessungsZeitraumMonate[i]){tmpBetrachtungsmonateFlag=true;}if(mischEkTaetigkeit.bemessungsZeitraumMonate[i]&&mischEkTaetigkeit.erwerbsTaetigkeit!==model/* ErwerbsTaetigkeit */.uA.SELBSTSTAENDIG&&monate_pausch[i]===0){zaehler_Pauschmonate++;monate_pausch[i]=1;}}if(tmpBetrachtungsmonateFlag){betrachtungsmonate++;letzter_Betrachtungsmonat=i;}}let summe_EK_SS=math_util/* MathUtil */.k.BIG_ZERO;let summe_EK_NS=math_util/* MathUtil */.k.BIG_ZERO;let summe_EK_NS_SV=math_util/* MathUtil */.k.BIG_ZERO;let summe_EK_GNS=math_util/* MathUtil */.k.BIG_ZERO;let array=finanzDaten.mischEinkommenTaetigkeiten;for(let index=0;index<array.length;index++){let mischEkTaetigkeit=array[index];const bruttoGesamt=mischEkTaetigkeit.bruttoEinkommenDurchschnitt.mul(new big/* default */.Z(mischEkTaetigkeit.getAnzahlBemessungsZeitraumMonate()));switch(mischEkTaetigkeit.erwerbsTaetigkeit){case model/* ErwerbsTaetigkeit */.uA.SELBSTSTAENDIG:summe_EK_SS=summe_EK_SS.add(mischEkTaetigkeit.bruttoEinkommenDurchschnitt.mul(new big/* default */.Z(mischEkTaetigkeit.getAnzahlBemessungsZeitraumMonate())));break;case model/* ErwerbsTaetigkeit */.uA.NICHT_SELBSTSTAENDIG:summe_EK_NS=summe_EK_NS.add(bruttoGesamt);if(math_util/* MathUtil */.k.isEqual(mischEkTaetigkeit.bruttoEinkommenDurchschnittMidi,math_util/* MathUtil */.k.BIG_ZERO)){summe_EK_NS_SV=summe_EK_NS_SV.add(bruttoGesamt);}else if(math_util/* MathUtil */.k.greater(mischEkTaetigkeit.bruttoEinkommenDurchschnittMidi,math_util/* MathUtil */.k.BIG_ZERO)){summe_EK_NS_SV=summe_EK_NS_SV.add(mischEkTaetigkeit.bruttoEinkommenDurchschnittMidi.mul(new big/* default */.Z(mischEkTaetigkeit.getAnzahlBemessungsZeitraumMonate())));}break;case model/* ErwerbsTaetigkeit */.uA.MINIJOB:summe_EK_GNS=summe_EK_GNS.add(bruttoGesamt);break;}}const brutto_elg=math_util/* MathUtil */.k.round(summe_EK_SS.add(summe_EK_NS).add(summe_EK_GNS).sub((0,big/* default */.Z)(zaehler_Pauschmonate).mul(model/* EgrBerechnungParamId */.kd.PAUSCH)).div(basis_eg_algorithmus_ANZAHL_MONATE_PRO_JAHR),2);const brutto_steuer=math_util/* MathUtil */.k.round(summe_EK_SS.add(summe_EK_NS).div(basis_eg_algorithmus_ANZAHL_MONATE_PRO_JAHR),2);const brutto_sv=math_util/* MathUtil */.k.round(summe_EK_SS.add(summe_EK_NS_SV).div(basis_eg_algorithmus_ANZAHL_MONATE_PRO_JAHR),2);const betrachtungszeitraumRV=[];const betrachtungszeitraumKV=[];const betrachtungszeitraumAV=[];for(let i=0;i<basis_eg_algorithmus_ANZAHL_MONATE_PRO_JAHR;i++){betrachtungszeitraumRV.push(false);betrachtungszeitraumKV.push(false);betrachtungszeitraumAV.push(false);{let array=finanzDaten.mischEinkommenTaetigkeiten;for(let index=0;index<array.length;index++){let mischEkTaetigkeit=array[index];if(mischEkTaetigkeit.bemessungsZeitraumMonate[i]&&mischEkTaetigkeit.erwerbsTaetigkeit!==model/* ErwerbsTaetigkeit */.uA.MINIJOB){if(mischEkTaetigkeit.rentenVersicherungsPflichtig===model/* YesNo */.l.YES){betrachtungszeitraumRV[i]=true;}if(mischEkTaetigkeit.krankenVersicherungsPflichtig===model/* YesNo */.l.YES){betrachtungszeitraumKV[i]=true;}if(mischEkTaetigkeit.arbeitslosenVersicherungsPflichtig===model/* YesNo */.l.YES){betrachtungszeitraumAV[i]=true;}}}}}const betrachtungsmonate_grenze=(0,big/* default */.Z)(betrachtungsmonate).div((0,big/* default */.Z)(2));let anzahl_monate_rv=math_util/* MathUtil */.k.BIG_ZERO;let anzahl_monate_kv=math_util/* MathUtil */.k.BIG_ZERO;let anzahl_monate_av=math_util/* MathUtil */.k.BIG_ZERO;for(let i=0;i<basis_eg_algorithmus_ANZAHL_MONATE_PRO_JAHR;i++){if(betrachtungszeitraumRV[i]){anzahl_monate_rv=anzahl_monate_rv.add(math_util/* MathUtil */.k.BIG_ONE);}if(betrachtungszeitraumKV[i]){anzahl_monate_kv=anzahl_monate_kv.add(math_util/* MathUtil */.k.BIG_ONE);}if(betrachtungszeitraumAV[i]){anzahl_monate_av=anzahl_monate_av.add(math_util/* MathUtil */.k.BIG_ONE);}}let rentenversicherungspflichtig=0;let krankenversicherungspflichtig=0;let arbeitslosenversicherungspflichtig=0;if(math_util/* MathUtil */.k.greater(anzahl_monate_rv,betrachtungsmonate_grenze)){rentenversicherungspflichtig=1;}if(math_util/* MathUtil */.k.isEqual(anzahl_monate_rv,betrachtungsmonate_grenze)&&betrachtungszeitraumRV[letzter_Betrachtungsmonat]){rentenversicherungspflichtig=1;}if(math_util/* MathUtil */.k.greater(anzahl_monate_kv,betrachtungsmonate_grenze)){krankenversicherungspflichtig=1;}if(math_util/* MathUtil */.k.isEqual(anzahl_monate_kv,betrachtungsmonate_grenze)&&betrachtungszeitraumKV[letzter_Betrachtungsmonat]){krankenversicherungspflichtig=1;}if(math_util/* MathUtil */.k.greater(anzahl_monate_av,betrachtungsmonate_grenze)){arbeitslosenversicherungspflichtig=1;}if(math_util/* MathUtil */.k.isEqual(anzahl_monate_av,betrachtungsmonate_grenze)&&betrachtungszeitraumAV[letzter_Betrachtungsmonat]){arbeitslosenversicherungspflichtig=1;}let status=model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI;if(rentenversicherungspflichtig+krankenversicherungspflichtig+arbeitslosenversicherungspflichtig===0){status=model/* ErwerbsArt */.$h.JA_NICHT_SELBST_OHNE_SOZI;}if(math_util/* MathUtil */.k.greater(summe_EK_SS,summe_EK_NS.add(summe_EK_GNS))){status=model/* ErwerbsArt */.$h.JA_SELBSTSTAENDIG;}if(math_util/* MathUtil */.k.lessOrEqual(brutto_elg,model/* EgrBerechnungParamId */.kd.GRENZE_MINI_MIDI)&&status!==model/* ErwerbsArt */.$h.JA_SELBSTSTAENDIG){status=model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI;}persoenlicheDaten.etVorGeburt=status;if(rentenversicherungspflichtig===1){finanzDaten.rentenVersicherung=model/* RentenArt */.d0.GESETZLICHE_RENTEN_VERSICHERUNG;}if(krankenversicherungspflichtig===1){finanzDaten.kassenArt=model/* KassenArt */.TN.GESETZLICH_PFLICHTVERSICHERT;}if(status===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI){netto=brutto_elg;}else{if(status===model/* ErwerbsArt */.$h.JA_SELBSTSTAENDIG){finanzDaten.steuerKlasse=model/* SteuerKlasse */.nf.SKL4;finanzDaten.splittingFaktor=1.0;}if(finanzDaten.steuerKlasse===model/* SteuerKlasse */.nf.SKL4){finanzDaten.splittingFaktor=1.0;}if(finanzDaten.steuerKlasse===model/* SteuerKlasse */.nf.SKL4_FAKTOR){finanzDaten.steuerKlasse=model/* SteuerKlasse */.nf.SKL4;}Logger.log("Berechne Summe der Sozialabgaben mit: kv=".concat(krankenversicherungspflichtig,", rv=").concat(rentenversicherungspflichtig,", status=").concat(status,", brutto_sv=").concat(brutto_sv));const summe_sozab=new BruttoNettoRechner().summe_svb_misch(krankenversicherungspflichtig>0,rentenversicherungspflichtig>0,status,brutto_sv);const summe_steuer_abzug=await new BruttoNettoRechner().summeSteuer(finanzDaten,status,brutto_steuer,lohnSteuerJahr);netto=brutto_elg.sub(summe_steuer_abzug).sub(summe_sozab);steuern=summe_steuer_abzug;abgaben=summe_sozab;Logger.log("Netto (".concat(netto,") berechnet aus Brutto ").concat(brutto_elg," und Abgaben SV=").concat(summe_sozab,", Steuer=").concat(summe_steuer_abzug));}const ek_vor=netto;const elterngeldbasis=math_util/* MathUtil */.k.round(this.elterngeld_keine_et(ek_vor),2);return{krankenversicherungspflichtig:krankenversicherungspflichtig===1,rentenversicherungspflichtig:rentenversicherungspflichtig===1,netto:netto,brutto:brutto_elg,steuern:steuern,abgaben:abgaben,elterngeldbasis:elterngeldbasis,status:status};}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/common/date-util.ts
let DateUtil;(function(_DateUtil){function dateWithoutTimeOf(date){return luxon/* DateTime */.ou.fromJSDate(date).set({hour:0}).set({minute:0}).set({second:0}).set({millisecond:0}).toJSDate();}_DateUtil.dateWithoutTimeOf=dateWithoutTimeOf;function plusDays(date,days){return luxon/* DateTime */.ou.fromJSDate(date).plus({days:days}).toJSDate();}_DateUtil.plusDays=plusDays;function minusDays(date,days){return luxon/* DateTime */.ou.fromJSDate(date).minus({days:days}).toJSDate();}_DateUtil.minusDays=minusDays;function plusMonths(date,months){return luxon/* DateTime */.ou.fromJSDate(date).plus({months:months}).toJSDate();}_DateUtil.plusMonths=plusMonths;function plusYears(date,years){return luxon/* DateTime */.ou.fromJSDate(date).plus({years:years}).toJSDate();}_DateUtil.plusYears=plusYears;function daysBetween(date1,date2){return utcDateWithoutTimeOf(date2).diff(utcDateWithoutTimeOf(date1)).as("days");}_DateUtil.daysBetween=daysBetween;function setDayOfMonth(date,dayOfMonth){return luxon/* DateTime */.ou.fromJSDate(date).set({day:dayOfMonth}).toJSDate();}_DateUtil.setDayOfMonth=setDayOfMonth;})(DateUtil||(DateUtil={}));/**
 * Returns a new utc date without time.
 *
 * @param date Date with or without time.
 * @return A new date without time and with zone utc, created from incoming date.
 */function utcDateWithoutTimeOf(date){const year=date.getFullYear();const month=(date.getMonth()+1).toString().padStart(2,"0");const dayOfMonth=date.getDate().toString().padStart(2,"0");const isoDate="".concat(year,"-").concat(month,"-").concat(dayOfMonth);return luxon/* DateTime */.ou.fromISO(isoDate,{zone:"utc"});}
;// CONCATENATED MODULE: ./src/globals/js/calculations/eg-zwischen-ergebnis-algorithmus.ts
/**
 * Algorithmus zur Berechnung des Zwischenergebnisses des Elterngeldrechners.
 *
 * Im Elterngeldrechner Plus dient das Zwischenergebnis u.a. zur Ermittlung
 * des Basiselterngelds, sowie der Mehrlingszulage bzw. des Geschwisterbonus.
 */class EgZwischenErgebnisAlgorithmus extends AbstractAlgorithmus{/**
   * Berechnet das Zwischenergebnis des Elterngeldrechners.
   *
   * @param {PersoenlicheDaten} persoenlicheDaten Die persönlichen Daten eines Elternteils.
   * @param {NettoEinkommen} nettoEinkommen Nettoeinkommen vor der Geburt.
   * @return {ZwischenErgebnis} Das Zwischenergebnis des Elterngeldrechners.
   */elterngeldZwischenergebnis(persoenlicheDaten,nettoEinkommen){if(persoenlicheDaten.wahrscheinlichesGeburtsDatum===undefined){throw new Error("wahrscheinlichesGeburtsDatum is undefined");}const geburt=persoenlicheDaten.wahrscheinlichesGeburtsDatum;const geschw=persoenlicheDaten.kinder;let ende=undefined;const ind_geschw=persoenlicheDaten.isGeschwisterVorhanden();const no_kinder=persoenlicheDaten.anzahlKuenftigerKinder;const ek_vor=model/* ErwerbsArt */.$h.NEIN!==persoenlicheDaten.etVorGeburt?nettoEinkommen:new model/* Einkommen */.$J(0);let ek_vor_copy=math_util/* MathUtil */.k.BIG_ZERO;ek_vor_copy=ek_vor_copy.add(ek_vor.value);const status_et=persoenlicheDaten.etVorGeburt;let mehrlingszuschlag;let ende_bonus_u2_final;let ende_bonus_u14_final;let ende_bonus_u6_final;const pausch=model/* EgrBerechnungParamId */.kd.PAUSCH;let elterngeldbasis;let ersatzrate_ausgabe;const betrag_Mehrlingszuschlag=model/* EgrBerechnungParamId */.kd.BETRAG_MEHRLINGSZUSCHLAG;let geschwisterbonus;const rate_bonus=model/* EgrBerechnungParamId */.kd.RATE_BONUS;const min_geschwisterbonus=model/* EgrBerechnungParamId */.kd.MIN_GESCHWISTERBONUS;if(ind_geschw){ende_bonus_u2_final=DateUtil.dateWithoutTimeOf(this.ende_bonus_u2(geburt,geschw));ende_bonus_u14_final=DateUtil.dateWithoutTimeOf(this.ende_bonus_u14(geburt,geschw));ende_bonus_u6_final=DateUtil.dateWithoutTimeOf(this.ende_bonus_u6(geburt,geschw));if(ende_bonus_u2_final>=ende_bonus_u14_final&&ende_bonus_u2_final>=ende_bonus_u6_final&&ende_bonus_u2_final>=geburt){ende=ende_bonus_u2_final;}else if(ende_bonus_u6_final>=ende_bonus_u2_final&&ende_bonus_u6_final>=ende_bonus_u14_final&&ende_bonus_u6_final>=geburt){ende=ende_bonus_u6_final;}else if(ende_bonus_u14_final>=ende_bonus_u2_final&&ende_bonus_u14_final>=ende_bonus_u6_final&&ende_bonus_u14_final>=geburt){ende=ende_bonus_u14_final;}else{ende=geburt;}}if(ende===undefined||ende<geburt){ende=geburt;}if(status_et===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI||status_et===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_OHNE_SOZI||status_et===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI){ek_vor_copy=math_util/* MathUtil */.k.fMax(ek_vor_copy.sub(pausch),math_util/* MathUtil */.k.BIG_ZERO);}elterngeldbasis=this.elterngeld_keine_et(ek_vor_copy);ersatzrate_ausgabe=this.ersatzrate_eg(ek_vor_copy);if(no_kinder>1){mehrlingszuschlag=betrag_Mehrlingszuschlag.mul((0,big/* default */.Z)(no_kinder-1));}else{mehrlingszuschlag=math_util/* MathUtil */.k.BIG_ZERO;}if(ende!==undefined&&ende>geburt){geschwisterbonus=math_util/* MathUtil */.k.fMax(elterngeldbasis.mul(rate_bonus),min_geschwisterbonus);}else{geschwisterbonus=math_util/* MathUtil */.k.BIG_ZERO;}elterngeldbasis=math_util/* MathUtil */.k.round(elterngeldbasis);ersatzrate_ausgabe=math_util/* MathUtil */.k.round(ersatzrate_ausgabe);geschwisterbonus=math_util/* MathUtil */.k.round(geschwisterbonus,3);return{elternGeld:elterngeldbasis,ersatzRate:ersatzrate_ausgabe,geschwisterBonus:geschwisterbonus,mehrlingsZulage:mehrlingszuschlag,zeitraumGeschwisterBonus:ende,nettoVorGeburt:nettoEinkommen.value};}ende_bonus_u6(geburt,geschw){const geschw_jung=this.fktZweitMax(this.onlyGeschwisterVorGeburt(geburt,geschw));return this.ende_bonus(geburt,geschw_jung,6);}ende_bonus_u14(geburt,geschw){const geschw_b=[];geschw.forEach(act=>{if(act.istBehindert){geschw_b.push(act);}else{geschw_b.push({nummer:act.nummer,geburtsdatum:new Date(1899,11,31),istBehindert:act.istBehindert});}});// jüngstes Kind finden (ausser Neugeborenes)
const geschw_jung=this.fktMax(this.onlyGeschwisterVorGeburt(geburt,geschw_b));return this.ende_bonus(geburt,geschw_jung,14);}/**
   * Geschwisterbonus wird bis zu dem Zeitpunkt gezahlt an dem ein Geschwisterkind 3 Jahre alt wird.
   * Der Zeitraum endet mit dem Ende des jeweiligen Lebensmonats des Kindes, für das Elterngeld bezogen wird.
   *
   * Public Function ende_bonus_u2(geburt, geschw)
   * geschw_jung = fktMax(geschw)
   * zweiter_geb_geschw_jung = DateSerial(Year(geschw_jung) + 3, Month(geschw_jung), Day(geschw_jung))
   * zeit_bis_ende_bonus_u2 = Max(zweiter_geb_geschw_jung - geburt, 0)
   * ende_bonus_u2 = DateSerial(Year(geburt), Month(geburt), Day(geburt) + zeit_bis_ende_bonus_u2)
   * zusatz = Day(DateSerial(Year(geburt), Month(geburt) + Dauer, Day(geburt))) - Day(ende_bonus_u2) - 1
   * If ende_bonus_u2 > geburt Then
   * If zusatz >= 0 Then
   * ende_bonus_u2 = DateSerial(Year(ende_bonus_u2), Month(ende_bonus_u2), Day(ende_bonus_u2) + zusatz)
   * ElseIf zusatz < 0 Then
   * ende_bonus_u2 = DateSerial(Year(ende_bonus_u2), Month(ende_bonus_u2) + 1, Day(ende_bonus_u2) + zusatz)
   * End If
   * End If
   * End Function
   *
   * @param {Date} geburt
   * @param {Kind[]} geschw
   * @return
   */ende_bonus_u2(geburt,geschw){// jüngstes Kind finden (ausser Neugeborenes)
const geschw_jung=this.fktMax(this.onlyGeschwisterVorGeburt(geburt,geschw));return this.ende_bonus(geburt,geschw_jung,3);}onlyGeschwisterVorGeburt(geburt,geschw){return geschw.filter(value=>{return value.geburtsdatum!==undefined&&value.geburtsdatum<geburt;});}ende_bonus(geburt,geburtstag_geschw,bonusYears){let zeit_bis_ende_bonus_days=-1;if(geburtstag_geschw!==undefined){const bonus_geb_geschw_jung=DateUtil.plusYears(geburtstag_geschw,bonusYears);if(bonus_geb_geschw_jung>=geburt){zeit_bis_ende_bonus_days=DateUtil.daysBetween(geburt,bonus_geb_geschw_jung);}}let ende_bonus=DateUtil.plusDays(geburt,zeit_bis_ende_bonus_days);if(ende_bonus>=geburt){// Ende LM berechnen
if(geburt.getDate()<=28){ende_bonus=luxon/* DateTime */.ou.fromJSDate(ende_bonus).set({day:geburt.getDate()}).plus({month:1}).minus({day:1}).toJSDate();}else{ende_bonus=luxon/* DateTime */.ou.fromJSDate(ende_bonus).set({day:geburt.getDate()}).minus({day:1}).plus({month:1}).toJSDate();}}return ende_bonus;}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/eg-brutto-rechner.ts
/**
 * Einige Berechnungen, die sich im BruttoNettoRechner befanden,
 * sind in diesen neuen Namespace besser aufgehoben.
 */let ElternGeldBruttoRechner;(function(_ElternGeldBruttoRechner){function bruttoEGPlusNeu(planungsergebnis,finanzDaten){const bruttoLM=finanzDaten.bruttoLeistungsMonate();const brutto_LM_Plus=finanzDaten.bruttoLeistungsMonateWithPlanung(true,planungsergebnis);const brutto_LM_Basis=finanzDaten.bruttoLeistungsMonateWithPlanung(false,planungsergebnis);let lm_mit_et_basis=0;let lm_mit_et_plus=0;let summe_brutto_basis=math_util/* MathUtil */.k.BIG_ZERO;let summe_brutto_plus=math_util/* MathUtil */.k.BIG_ZERO;let brutto_basis=math_util/* MathUtil */.k.BIG_ZERO;let brutto_plus=math_util/* MathUtil */.k.BIG_ZERO;for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){if(planungsergebnis.get(i)===model/* ElternGeldArt */.Tc.KEIN_BEZUG&&math_util/* MathUtil */.k.greater(bruttoLM[i],math_util/* MathUtil */.k.BIG_ZERO)){// Logger.log("Es wurde Einkommen in Monaten ohne Bezug angegeben!");
// Keine Fehlermeldung in GUI, da auch
// in Berechnung des Einkommens nach
// Kalendermonaten, die keine Rollte
// spielte
}if(!math_util/* MathUtil */.k.isEqual(brutto_LM_Basis[i],math_util/* MathUtil */.k.BIG_ZERO)&&planungsergebnis.get(i)===model/* ElternGeldArt */.Tc.BASIS_ELTERNGELD){lm_mit_et_basis=lm_mit_et_basis+1;summe_brutto_basis=summe_brutto_basis.add(brutto_LM_Basis[i]);}if(!math_util/* MathUtil */.k.isEqual(brutto_LM_Plus[i],math_util/* MathUtil */.k.BIG_ZERO)&&planungsergebnis.get(i)===model/* ElternGeldArt */.Tc.ELTERNGELD_PLUS||planungsergebnis.get(i)===model/* ElternGeldArt */.Tc.PARTNERSCHAFTS_BONUS){lm_mit_et_plus=lm_mit_et_plus+1;summe_brutto_plus=summe_brutto_plus.add(brutto_LM_Plus[i]);}}if(lm_mit_et_basis>0){brutto_basis=math_util/* MathUtil */.k.round(summe_brutto_basis.div(lm_mit_et_basis));}if(lm_mit_et_plus>0){brutto_plus=math_util/* MathUtil */.k.round(summe_brutto_plus.div(lm_mit_et_plus));}return{summeBruttoBasis:summe_brutto_basis,summeBruttoPlus:summe_brutto_plus,bruttoLMBasis:brutto_LM_Basis,bruttoLMPlus:brutto_LM_Plus,bruttoEinkommenDurch:brutto_basis,bruttoEinkommenPlusDurch:brutto_plus,lmMitETBasis:lm_mit_et_basis,lmMitETPlus:lm_mit_et_plus};}_ElternGeldBruttoRechner.bruttoEGPlusNeu=bruttoEGPlusNeu;})(ElternGeldBruttoRechner||(ElternGeldBruttoRechner={}));
;// CONCATENATED MODULE: ./src/globals/js/calculations/plus-eg-algorithmus.ts
class PlusEgAlgorithmus extends AbstractAlgorithmus{constructor(){super(...arguments);this.bruttoNettoRechner=new BruttoNettoRechner();this.pb_von=null;this.pb_bis=null;this.partnerbonus=model/* YesNo */.l.NO;// Das Array wird mit Index 1-32 benutzt.
this.anfang_LM=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev+1);// Das Array wird mit Index 1-32 benutzt.
this.ende_LM=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev+1);}async elterngeldPlusErgebnis(planungsergebnis,persoenlicheDaten,finanzDaten,lohnSteuerJahr,mischEkZwischenErgebnis,z){// Das Array wird mit Index 1-32 benutzt.
let brutto_LM_Plus=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev+1);// Das Array wird mit Index 1-32 benutzt.
let brutto_LM_Basis=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev+1);brutto_LM_Plus.fill(math_util/* MathUtil */.k.BIG_ZERO);brutto_LM_Basis.fill(math_util/* MathUtil */.k.BIG_ZERO);const etVorGeburt=persoenlicheDaten.etVorGeburt!==model/* ErwerbsArt */.$h.NEIN;const eg_verlauf=planungsergebnis.planung;let ergebnis;const finanzDatenBerechnet={bruttoEinkommenDurch:math_util/* MathUtil */.k.BIG_ZERO,bruttoEinkommenPlusDurch:math_util/* MathUtil */.k.BIG_ZERO,bruttoLMBasis:[],bruttoLMPlus:[],lmMitETBasis:0,lmMitETPlus:0,summeBruttoBasis:math_util/* MathUtil */.k.BIG_ZERO,summeBruttoPlus:math_util/* MathUtil */.k.BIG_ZERO};if(!etVorGeburt){ergebnis=PlusEgAlgorithmus.ohneETVorGeburt();}else{ergebnis=await this.mitETVorGeburt(planungsergebnis,persoenlicheDaten,finanzDaten,lohnSteuerJahr,mischEkZwischenErgebnis,z);}this.partnerbonus=model/* YesNo */.l.NO;//let listBruttoLMBasis: Array<Big> = finanzDatenBerechnet.bruttoLMBasis;
//let listBruttoLMPlus: Array<Big> = finanzDatenBerechnet.bruttoLMPlus;
const listBruttoLMPlus=finanzDaten.bruttoLeistungsMonateWithPlanung(true,planungsergebnis);const listBruttoLMBasis=finanzDaten.bruttoLeistungsMonateWithPlanung(false,planungsergebnis);if(listBruttoLMBasis!=null&&listBruttoLMBasis.length>0){brutto_LM_Basis=listBruttoLMBasis;}if(listBruttoLMPlus!=null&&listBruttoLMPlus.length>0){brutto_LM_Plus=listBruttoLMPlus;}finanzDatenBerechnet.bruttoLMBasis=listBruttoLMBasis;finanzDatenBerechnet.bruttoLMPlus=listBruttoLMPlus;if(!etVorGeburt){// Das Array wird mit Index 1-32 benutzt.
finanzDatenBerechnet.bruttoLMPlus=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev+1).fill(math_util/* MathUtil */.k.BIG_ZERO);}const verlauf=this.determineElternGeldKategorie(finanzDatenBerechnet,eg_verlauf,brutto_LM_Basis,brutto_LM_Plus,etVorGeburt);ergebnis=this.validateEinkommenPartnerBonus(ergebnis);return this.createElterngeldAusgabe(persoenlicheDaten,finanzDaten,ergebnis,z,mischEkZwischenErgebnis,verlauf,planungsergebnis);}static getEKVor(finanzDaten,ek_vor,mischEkZwischenErgebnis){if(finanzDaten.isMischeinkommen()){if(mischEkZwischenErgebnis===null){throw errorOf("MischEinkommenEnabledButMissingMischEinkommen");}ek_vor=mischEkZwischenErgebnis.netto;if(mischEkZwischenErgebnis.status!==model/* ErwerbsArt */.$h.JA_SELBSTSTAENDIG){ek_vor=ek_vor.add(model/* EgrBerechnungParamId */.kd.PAUSCH);}}return ek_vor;}static ohneETVorGeburt(){return{anfangEGPeriode:[],elternGeldAusgabe:[],endeEGPeriode:[],ersatzRate:math_util/* MathUtil */.k.BIG_ZERO,etVorGeburt:false,geschwisterBonus:math_util/* MathUtil */.k.BIG_ZERO,geschwisterBonusDeadLine:null,hasPartnerBonusError:false,mehrlingsZulage:math_util/* MathUtil */.k.BIG_ZERO,nettoNachGeburtDurch:math_util/* MathUtil */.k.BIG_ZERO,elternGeldBasis:model/* EgrBerechnungParamId */.kd.MINDESTSATZ,elternGeldKeineEtPlus:model/* EgrBerechnungParamId */.kd.MINDESTSATZ.div((0,big/* default */.Z)(2)),message:"Sie erhalten 300 Euro Elterngeld sowie evtl. Geschwisterbonus und/oder Mehrlingszuschlag",bruttoBasis:math_util/* MathUtil */.k.BIG_ZERO,nettoBasis:math_util/* MathUtil */.k.BIG_ZERO,elternGeldErwBasis:math_util/* MathUtil */.k.BIG_ZERO,bruttoPlus:math_util/* MathUtil */.k.BIG_ZERO,nettoPlus:math_util/* MathUtil */.k.BIG_ZERO,elternGeldEtPlus:math_util/* MathUtil */.k.BIG_ZERO};}async mitETVorGeburt(planungsergebnis,persoenlicheDaten,finanzDaten,lohnSteuerJahr,mischEkZwischenErgebnis,z){const nicht_erw=persoenlicheDaten.etNachGeburt;let ek_nach_plus;let elterngeld_erw_plus;let brutto_basis=math_util/* MathUtil */.k.BIG_ZERO;let netto_basis=math_util/* MathUtil */.k.BIG_ZERO;let elterngeld_erw_basis=math_util/* MathUtil */.k.BIG_ZERO;let brutto_plus=math_util/* MathUtil */.k.BIG_ZERO;let netto_plus=math_util/* MathUtil */.k.BIG_ZERO;let elterngeld_et_plus=math_util/* MathUtil */.k.BIG_ZERO;let elterngeld_keine_et_plus=math_util/* MathUtil */.k.BIG_ZERO;let elternGeldPerioden={anfang:[],ende:[]};if(nicht_erw===model/* YesNo */.l.YES){// es liegt Erwerbstätigkeit nach der Geburt vor
const pausch=model/* EgrBerechnungParamId */.kd.PAUSCH;// if (finanzDaten.erwerbsZeitraumLeistungsMonatList == null) {
//   finanzDaten.erwerbsZeitraumLeistungsMonatList = [];
// }
if(persoenlicheDaten.wahrscheinlichesGeburtsDatum===undefined){throw new Error("wahrscheinlichesGeburtsDatum === undefined");}const geburt=persoenlicheDaten.wahrscheinlichesGeburtsDatum;const anzahl_monate=(0,model/* zaehleMonateErwerbsTaetigkeit */.fc)(finanzDaten.erwerbsZeitraumLebensMonatList);if(anzahl_monate!=null&&anzahl_monate!==0){elternGeldPerioden=PlusEgAlgorithmus.determineEGPerioden(finanzDaten,planungsergebnis);let summe_brutto_basis=math_util/* MathUtil */.k.BIG_ZERO;let summe_brutto_plus=math_util/* MathUtil */.k.BIG_ZERO;this.fillLebensMonateList(geburt);persoenlicheDaten.anfangLM=this.anfang_LM;persoenlicheDaten.endeLM=this.ende_LM;const finanzDatenBerechnet=ElternGeldBruttoRechner.bruttoEGPlusNeu(planungsergebnis,finanzDaten);const lm_mit_et_basis=finanzDatenBerechnet.lmMitETBasis;const lm_mit_et_plus=finanzDatenBerechnet.lmMitETPlus;const bruttoLMPlus=finanzDaten.bruttoLeistungsMonateWithPlanung(true,planungsergebnis);const bruttoLMBasis=finanzDaten.bruttoLeistungsMonateWithPlanung(false,planungsergebnis);const brutto_LM_Plus=/* toArray */bruttoLMPlus.slice(0);const brutto_LM_Basis=/* toArray */bruttoLMBasis.slice(0);let steuer_sozab_basis=math_util/* MathUtil */.k.BIG_ZERO;let steuer_sozab_plus=math_util/* MathUtil */.k.BIG_ZERO;brutto_basis=finanzDatenBerechnet.bruttoEinkommenDurch;brutto_plus=finanzDatenBerechnet.bruttoEinkommenPlusDurch;if(persoenlicheDaten.etVorGeburt===model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI){netto_basis=brutto_basis;netto_plus=brutto_plus;}else{if(math_util/* MathUtil */.k.greater(brutto_basis,math_util/* MathUtil */.k.BIG_ZERO)){steuer_sozab_basis=await this.bruttoNettoRechner.abzuege(brutto_basis,lohnSteuerJahr,finanzDaten,persoenlicheDaten.etVorGeburt);}if(math_util/* MathUtil */.k.greater(brutto_plus,math_util/* MathUtil */.k.BIG_ZERO)){steuer_sozab_plus=await this.bruttoNettoRechner.abzuege(brutto_plus,lohnSteuerJahr,finanzDaten,persoenlicheDaten.etVorGeburt);}}let ek_vor=z.nettoVorGeburt;ek_vor=PlusEgAlgorithmus.getEKVor(finanzDaten,ek_vor,mischEkZwischenErgebnis);if(math_util/* MathUtil */.k.greater(brutto_basis,math_util/* MathUtil */.k.BIG_ZERO)){switch(persoenlicheDaten.etVorGeburt){case model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI:case model/* ErwerbsArt */.$h.JA_NICHT_SELBST_OHNE_SOZI:case model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI:ek_vor=math_util/* MathUtil */.k.fMax(math_util/* MathUtil */.k.round(ek_vor.sub(model/* EgrBerechnungParamId */.kd.PAUSCH)),math_util/* MathUtil */.k.BIG_ZERO);summe_brutto_basis=math_util/* MathUtil */.k.BIG_ZERO;for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){if(!math_util/* MathUtil */.k.isEqual(brutto_LM_Basis[i],math_util/* MathUtil */.k.BIG_ZERO)&&planungsergebnis.get(i)===model/* ElternGeldArt */.Tc.BASIS_ELTERNGELD){summe_brutto_basis=summe_brutto_basis.add(math_util/* MathUtil */.k.round(math_util/* MathUtil */.k.fMax(brutto_LM_Basis[i].sub(pausch),math_util/* MathUtil */.k.BIG_ZERO),2));}}if(lm_mit_et_basis>0){brutto_basis=math_util/* MathUtil */.k.round(summe_brutto_basis.div((0,big/* default */.Z)(lm_mit_et_basis)),2);}break;default:}netto_basis=math_util/* MathUtil */.k.fMax(brutto_basis.sub(steuer_sozab_basis),math_util/* MathUtil */.k.BIG_ZERO);const ek_nach_basis=netto_basis;elterngeld_erw_basis=math_util/* MathUtil */.k.round(this.elterngeld_et(ek_vor,ek_nach_basis),2);}if(math_util/* MathUtil */.k.greater(brutto_plus,math_util/* MathUtil */.k.BIG_ZERO)){let status;if(finanzDaten.isMischeinkommen()){if(mischEkZwischenErgebnis===null){throw errorOf("MischEinkommenEnabledButMissingMischEinkommen");}status=mischEkZwischenErgebnis.status;}else{status=persoenlicheDaten.etVorGeburt;}ek_vor=z.nettoVorGeburt;ek_vor=PlusEgAlgorithmus.getEKVor(finanzDaten,ek_vor,mischEkZwischenErgebnis);switch(status){case model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MINI:case model/* ErwerbsArt */.$h.JA_NICHT_SELBST_MIT_SOZI:case model/* ErwerbsArt */.$h.JA_NICHT_SELBST_OHNE_SOZI:ek_vor=math_util/* MathUtil */.k.fMax(ek_vor.sub(model/* EgrBerechnungParamId */.kd.PAUSCH),math_util/* MathUtil */.k.BIG_ZERO);summe_brutto_plus=math_util/* MathUtil */.k.BIG_ZERO;for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){if(!math_util/* MathUtil */.k.isEqual(brutto_LM_Plus[i],math_util/* MathUtil */.k.BIG_ZERO)&&(planungsergebnis.get(i)===model/* ElternGeldArt */.Tc.ELTERNGELD_PLUS||planungsergebnis.get(i)===model/* ElternGeldArt */.Tc.PARTNERSCHAFTS_BONUS)){summe_brutto_plus=summe_brutto_plus.add(math_util/* MathUtil */.k.round(math_util/* MathUtil */.k.fMax(brutto_LM_Plus[i].sub(pausch),math_util/* MathUtil */.k.BIG_ZERO),2));}}if(lm_mit_et_plus>0){brutto_plus=math_util/* MathUtil */.k.round(summe_brutto_plus.div((0,big/* default */.Z)(lm_mit_et_plus)),2);}break;default:}}netto_plus=math_util/* MathUtil */.k.fMax(brutto_plus.sub(steuer_sozab_plus),math_util/* MathUtil */.k.BIG_ZERO);ek_nach_plus=netto_plus;elterngeld_erw_plus=math_util/* MathUtil */.k.round(this.elterngeldplus_et(ek_vor,ek_nach_plus),2);elterngeld_keine_et_plus=z.elternGeld;if(finanzDaten.isMischeinkommen()){if(mischEkZwischenErgebnis===null){throw errorOf("MischEinkommenEnabledButMissingMischEinkommen");}elterngeld_keine_et_plus=mischEkZwischenErgebnis.elterngeldbasis;}elterngeld_keine_et_plus=elterngeld_keine_et_plus.div((0,big/* default */.Z)(2));elterngeld_et_plus=math_util/* MathUtil */.k.fMin(elterngeld_keine_et_plus,elterngeld_erw_plus);}}else{// Sollten keine Perioden angegeben sein, so berechne nichts
netto_plus=math_util/* MathUtil */.k.BIG_ZERO;elterngeld_keine_et_plus=math_util/* MathUtil */.k.BIG_ZERO;elterngeld_et_plus=math_util/* MathUtil */.k.BIG_ZERO;}return{anfangEGPeriode:elternGeldPerioden.anfang,endeEGPeriode:elternGeldPerioden.ende,elternGeldErwBasis:math_util/* MathUtil */.k.round(elterngeld_erw_basis,2),bruttoBasis:math_util/* MathUtil */.k.round(brutto_basis,2),nettoBasis:math_util/* MathUtil */.k.round(netto_basis,2),bruttoPlus:math_util/* MathUtil */.k.round(brutto_plus,2),nettoPlus:math_util/* MathUtil */.k.round(netto_plus,2),elternGeldEtPlus:math_util/* MathUtil */.k.round(elterngeld_et_plus,2),elternGeldKeineEtPlus:math_util/* MathUtil */.k.round(elterngeld_keine_et_plus,2),elternGeldAusgabe:[],elternGeldBasis:math_util/* MathUtil */.k.BIG_ZERO,ersatzRate:math_util/* MathUtil */.k.BIG_ZERO,etVorGeburt:false,geschwisterBonus:math_util/* MathUtil */.k.BIG_ZERO,geschwisterBonusDeadLine:null,hasPartnerBonusError:false,mehrlingsZulage:math_util/* MathUtil */.k.BIG_ZERO,message:"",nettoNachGeburtDurch:math_util/* MathUtil */.k.BIG_ZERO};}fillLebensMonateList(geburt){// Die Arrays anfang_LM und ende_LM werden mit Index 1-32 benutzt.
for(let i=0;i<model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){const anfang=DateUtil.plusMonths(geburt,i);const ende=DateUtil.minusDays(DateUtil.plusMonths(geburt,i+1),1);this.anfang_LM[i+1]=anfang;this.ende_LM[i+1]=ende;if(geburt.getDay()>28&&anfang.getMonth()===2&&anfang.getDay()<5){// this.anfang_LM[i] = new DateTime(new GregorianCalendar(calGeburt.get(YEAR), calGeburt.get(MONTH) + i + 1, 1).getTime());
this.anfang_LM[i+1]=DateUtil.setDayOfMonth(DateUtil.plusMonths(geburt,i+1),1);}if(geburt.getDay()>28&&ende.getMonth()===2&&ende.getDay()<5){// this.anfang_LM[i] = new DateTime(new GregorianCalendar(calGeburt.get(YEAR), calGeburt.get(MONTH) + i + 2, 0).getTime());
this.anfang_LM[i+1]=DateUtil.minusDays(DateUtil.setDayOfMonth(DateUtil.plusMonths(geburt,i+2),1),1);}}}determineElternGeldKategorie(finanzDatenBerechnet,eg_verlauf,// Das Array wird mit Index 0-31 benutzt.
brutto_LM_Basis,// Das Array wird mit Index 1-32 benutzt.
brutto_LM_Plus,// Das Array wird mit Index 1-32 benutzt.
etVorGeburt){const verlauf=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev);this.partnerbonus=model/* YesNo */.l.NO;let pbMonatVon=0;let pbMonatBis=0;let counter=0;for(let index=0;index<eg_verlauf.length;index++){let monat=eg_verlauf[index];counter++;if(monat===model/* ElternGeldArt */.Tc.PARTNERSCHAFTS_BONUS&&pbMonatVon===0){pbMonatVon=counter;pbMonatBis=counter;}else if(monat===model/* ElternGeldArt */.Tc.PARTNERSCHAFTS_BONUS){pbMonatBis=counter;}}if(!etVorGeburt){// **************************************************************************************************
// Abweichung vom FIT Algorithmus: an dieser Stelle noch berücksichtigen, ob ET nach Geburt angegeben
// dies dient zur Validierung des PB-Fehlers im Schritt 4
const brutto_LM_Plus_pb=finanzDatenBerechnet.bruttoLMPlus;for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){if(eg_verlauf[i-1]!==model/* ElternGeldArt */.Tc.BASIS_ELTERNGELD){verlauf[i-1]=model/* ElternGeldKategorie */.eK.KEIN_ELTERN_GELD;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.BASIS_ELTERNGELD){verlauf[i-1]=model/* ElternGeldKategorie */.eK.BASIS_ELTERN_GELD;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.ELTERNGELD_PLUS&&math_util/* MathUtil */.k.isEqual(brutto_LM_Plus_pb[i],math_util/* MathUtil */.k.BIG_ZERO)){verlauf[i-1]=model/* ElternGeldKategorie */.eK.ELTERN_GELD_PLUS_OHNE_ERWERBS_TAETIGKEIT;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.PARTNERSCHAFTS_BONUS&&math_util/* MathUtil */.k.isEqual(brutto_LM_Plus_pb[i],math_util/* MathUtil */.k.BIG_ZERO)){verlauf[i-1]=model/* ElternGeldKategorie */.eK.ELTERN_GELD_PLUS_OHNE_ERWERBS_TAETIGKEIT;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.PARTNERSCHAFTS_BONUS&&math_util/* MathUtil */.k.isEqual(brutto_LM_Plus[i],math_util/* MathUtil */.k.BIG_ZERO)){this.partnerbonus=model/* YesNo */.l.YES;break;}}}else{for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.KEIN_BEZUG){verlauf[i-1]=model/* ElternGeldKategorie */.eK.KEIN_ELTERN_GELD;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.BASIS_ELTERNGELD&&math_util/* MathUtil */.k.isEqual(brutto_LM_Basis[i],math_util/* MathUtil */.k.BIG_ZERO)){verlauf[i-1]=model/* ElternGeldKategorie */.eK.BASIS_ELTERN_GELD;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.BASIS_ELTERNGELD&&math_util/* MathUtil */.k.greater(brutto_LM_Basis[i],math_util/* MathUtil */.k.BIG_ZERO)){verlauf[i-1]=model/* ElternGeldKategorie */.eK.BASIS_ELTERN_GELD_MIT_ERWERBS_TAETIGKEIT;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.ELTERNGELD_PLUS&&math_util/* MathUtil */.k.isEqual(brutto_LM_Plus[i],math_util/* MathUtil */.k.BIG_ZERO)){verlauf[i-1]=model/* ElternGeldKategorie */.eK.ELTERN_GELD_PLUS_OHNE_ERWERBS_TAETIGKEIT;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.PARTNERSCHAFTS_BONUS&&math_util/* MathUtil */.k.isEqual(brutto_LM_Plus[i],math_util/* MathUtil */.k.BIG_ZERO)){this.partnerbonus=model/* YesNo */.l.YES;break;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.ELTERNGELD_PLUS&&math_util/* MathUtil */.k.greater(brutto_LM_Plus[i],math_util/* MathUtil */.k.BIG_ZERO)){verlauf[i-1]=model/* ElternGeldKategorie */.eK.ELTERN_GELD_PLUS_MIT_ERWERBS_TAETIGKEIT;}if(eg_verlauf[i-1]===model/* ElternGeldArt */.Tc.PARTNERSCHAFTS_BONUS&&math_util/* MathUtil */.k.greater(brutto_LM_Plus[i],math_util/* MathUtil */.k.BIG_ZERO)){verlauf[i-1]=model/* ElternGeldKategorie */.eK.ELTERN_GELD_PLUS_MIT_ERWERBS_TAETIGKEIT;}}}if(pbMonatVon!==0&&pbMonatBis!==0&&this.partnerbonus===model/* YesNo */.l.YES){if(this.anfang_LM[pbMonatVon-1]!=null&&this.ende_LM[pbMonatBis-1]!=null){this.pb_von=this.anfang_LM[pbMonatVon-1];this.pb_bis=this.ende_LM[pbMonatBis-1];}}return verlauf;}createElterngeldAusgabe(persoenlicheDaten,finanzDaten,ergebnis,z,misch,verlauf,planungsergebnis){if(persoenlicheDaten.wahrscheinlichesGeburtsDatum===undefined){throw new Error("wahrscheinlichesGeburtsDatum === undefined");}const ende_geschwisterbonus=z.zeitraumGeschwisterBonus;const geschw=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev).fill(0);if(persoenlicheDaten.isGeschwisterVorhanden()){// es sind Geschwister vorhanden
const geburt=persoenlicheDaten.wahrscheinlichesGeburtsDatum;if(ende_geschwisterbonus!=null&&ende_geschwisterbonus>=geburt){for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){this.anfang_LM[i]=DateUtil.plusMonths(geburt,i-1);}for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){this.ende_LM[i]=DateUtil.minusDays(DateUtil.plusMonths(geburt,i),1);}}for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){if(ende_geschwisterbonus!=null&&ende_geschwisterbonus>=this.ende_LM[i]){geschw[i-1]=1;}}}ergebnis.geschwisterBonusDeadLine=ende_geschwisterbonus;const ausgabeLebensmonate=[];let basiselterngeld=z.elternGeld;if(finanzDaten.isMischeinkommen()){if(misch===null){throw errorOf("MischEinkommenEnabledButMissingMischEinkommen");}basiselterngeld=misch.elterngeldbasis;}const basiselterngeld_erw=ergebnis.elternGeldErwBasis;const elterngeldplus=math_util/* MathUtil */.k.round(basiselterngeld.div((0,big/* default */.Z)(2)),2);const elterngeldplus_erw=ergebnis.elternGeldEtPlus;const betrag_mehrlingszuschlag=model/* EgrBerechnungParamId */.kd.BETRAG_MEHRLINGSZUSCHLAG;const min_geschwisterbonus=model/* EgrBerechnungParamId */.kd.MIN_GESCHWISTERBONUS;const rate_bonus=model/* EgrBerechnungParamId */.kd.RATE_BONUS;let mehrling=0;if(persoenlicheDaten.anzahlKuenftigerKinder>0){mehrling=persoenlicheDaten.anzahlKuenftigerKinder-1;}for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){const ausgabe={lebensMonat:i,elterngeldArt:planungsergebnis.get(i),elternGeld:math_util/* MathUtil */.k.BIG_ZERO,geschwisterBonus:math_util/* MathUtil */.k.BIG_ZERO,mehrlingsZulage:math_util/* MathUtil */.k.BIG_ZERO,mutterschaftsLeistungMonat:false};if(PlusEgAlgorithmus.isMutterschaftsLeistungImMonat(i,planungsergebnis)){ausgabe.mutterschaftsLeistungMonat=true;}else if(this.partnerbonus===model/* YesNo */.l.YES){// es ist schon alles auf 0 gesetzt
}else{let geschwisterbonus=math_util/* MathUtil */.k.BIG_ZERO;let mehrlingszuschlag=math_util/* MathUtil */.k.BIG_ZERO;let elterngeld=math_util/* MathUtil */.k.BIG_ZERO;if(verlauf[i-1]===model/* ElternGeldKategorie */.eK.KEIN_ELTERN_GELD){geschwisterbonus=math_util/* MathUtil */.k.BIG_ZERO;mehrlingszuschlag=math_util/* MathUtil */.k.BIG_ZERO;elterngeld=math_util/* MathUtil */.k.BIG_ZERO;}if(verlauf[i-1]===model/* ElternGeldKategorie */.eK.BASIS_ELTERN_GELD){geschwisterbonus=math_util/* MathUtil */.k.round(math_util/* MathUtil */.k.fMax(min_geschwisterbonus,basiselterngeld.mul(rate_bonus)).mul((0,big/* default */.Z)(geschw[i-1])),2);mehrlingszuschlag=betrag_mehrlingszuschlag.mul((0,big/* default */.Z)(mehrling));elterngeld=basiselterngeld.add(geschwisterbonus).add(mehrlingszuschlag);}if(verlauf[i-1]===model/* ElternGeldKategorie */.eK.BASIS_ELTERN_GELD_MIT_ERWERBS_TAETIGKEIT){mehrlingszuschlag=betrag_mehrlingszuschlag.mul((0,big/* default */.Z)(mehrling));geschwisterbonus=math_util/* MathUtil */.k.round(math_util/* MathUtil */.k.fMax(min_geschwisterbonus,basiselterngeld_erw.mul(rate_bonus)).mul((0,big/* default */.Z)(geschw[i-1])),2);elterngeld=basiselterngeld_erw.add(geschwisterbonus).add(mehrlingszuschlag);}if(verlauf[i-1]===model/* ElternGeldKategorie */.eK.ELTERN_GELD_PLUS_OHNE_ERWERBS_TAETIGKEIT){mehrlingszuschlag=betrag_mehrlingszuschlag.mul((0,big/* default */.Z)(mehrling)).div((0,big/* default */.Z)(2));geschwisterbonus=math_util/* MathUtil */.k.round(math_util/* MathUtil */.k.fMax(min_geschwisterbonus.div((0,big/* default */.Z)(2)),elterngeldplus.mul(rate_bonus)).mul((0,big/* default */.Z)(geschw[i-1])),2);elterngeld=elterngeldplus.add(geschwisterbonus).add(mehrlingszuschlag);}if(verlauf[i-1]===model/* ElternGeldKategorie */.eK.ELTERN_GELD_PLUS_MIT_ERWERBS_TAETIGKEIT){mehrlingszuschlag=betrag_mehrlingszuschlag.mul((0,big/* default */.Z)(mehrling)).div((0,big/* default */.Z)(2));geschwisterbonus=math_util/* MathUtil */.k.round(math_util/* MathUtil */.k.fMax(min_geschwisterbonus.div((0,big/* default */.Z)(2)),elterngeldplus_erw.mul(rate_bonus)).mul((0,big/* default */.Z)(geschw[i-1])),2);elterngeld=elterngeldplus_erw.add(geschwisterbonus).add(mehrlingszuschlag);}ausgabe.elternGeld=math_util/* MathUtil */.k.round(elterngeld);ausgabe.mehrlingsZulage=math_util/* MathUtil */.k.round(mehrlingszuschlag);ausgabe.geschwisterBonus=math_util/* MathUtil */.k.round(geschwisterbonus);}ausgabeLebensmonate.push(ausgabe);}if(ergebnis.ersatzRate==null){ergebnis.ersatzRate=math_util/* MathUtil */.k.round(z.ersatzRate);}ergebnis.elternGeldBasis=math_util/* MathUtil */.k.round(basiselterngeld);ergebnis.elternGeldErwBasis=math_util/* MathUtil */.k.round(basiselterngeld_erw);ergebnis.elternGeldKeineEtPlus=math_util/* MathUtil */.k.round(elterngeldplus);ergebnis.elternGeldEtPlus=math_util/* MathUtil */.k.round(elterngeldplus_erw);ergebnis.mehrlingsZulage=math_util/* MathUtil */.k.round(z.mehrlingsZulage);ergebnis.geschwisterBonus=math_util/* MathUtil */.k.round(z.geschwisterBonus);if(!persoenlicheDaten.etVorGeburt||persoenlicheDaten.etVorGeburt===model/* ErwerbsArt */.$h.NEIN){ergebnis.etVorGeburt=false;}ergebnis.elternGeldAusgabe=ausgabeLebensmonate;return ergebnis;}static isMutterschaftsLeistungImMonat(monat,planungsergebnis){return planungsergebnis.mutterschaftsLeistung!=null&&planungsergebnis.mutterschaftsLeistung!==model/* MutterschaftsLeistung */["do"].MUTTERSCHAFTS_LEISTUNG_NEIN&&monat<=(0,model/* mutterschaftsLeistungInMonaten */.Wm)(planungsergebnis.mutterschaftsLeistung);}validateEinkommenPartnerBonus(ergebnis){ergebnis.hasPartnerBonusError=false;if(this.partnerbonus===model/* YesNo */.l.YES){ergebnis.hasPartnerBonusError=true;// TODO TW message entfernen
ergebnis.message="Während des Bezugs des Partnerschaftsbonus muss Erwerbstätigkeit vorliegen.";ergebnis.bruttoBasis=math_util/* MathUtil */.k.BIG_ZERO;ergebnis.nettoBasis=math_util/* MathUtil */.k.BIG_ZERO;ergebnis.elternGeldErwBasis=math_util/* MathUtil */.k.BIG_ZERO;ergebnis.bruttoPlus=math_util/* MathUtil */.k.BIG_ZERO;ergebnis.nettoPlus=math_util/* MathUtil */.k.BIG_ZERO;ergebnis.elternGeldEtPlus=math_util/* MathUtil */.k.BIG_ZERO;ergebnis.elternGeldKeineEtPlus=math_util/* MathUtil */.k.BIG_ZERO;}return ergebnis;}/**
   * Methode zum Ermitteln der Elterngeldperioden (ausgedrückt in Lebensmonaten des Kindes) - abhängig von dem
   * Ergebnis der Elterngeldplanung
   *
   * @param {FinanzDaten} finanzDaten
   * @param {PlanungsDaten} planungsDaten
   * @return {ElternGeldPerioden}
   */static determineEGPerioden(finanzDaten,planungsDaten){const anfang_eg_per=[];const ende_eg_per=[];let start=true;for(let i=1;i<=model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){if(planungsDaten.get(i)!==model/* ElternGeldArt */.Tc.KEIN_BEZUG){if(start){anfang_eg_per.push(i);start=false;}if(anfang_eg_per.length===ende_eg_per.length){ende_eg_per[anfang_eg_per.length-1]=i;}else{ende_eg_per.push(i);}}else{start=true;}}if(ende_eg_per.length===anfang_eg_per.length-1){ende_eg_per.push(model/* PLANUNG_ANZAHL_MONATE */.Ev);}return{anfang:anfang_eg_per,ende:ende_eg_per};}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/ergebnis-utils.ts
var BIG_ZERO=math_util/* MathUtil */.k.BIG_ZERO;let ErgebnisUtils;(function(_ErgebnisUtils){function elternGeldSimulationErgebnisOf(basisElternGeld,elternGeldPlus,nettoLebensMonat){if(basisElternGeld.length+elternGeldPlus.length===0){return{rows:[]};}const rows=[];let previousRow=null;let previous=new ElternGeldAmount();for(let i=0;i<model/* PLANUNG_ANZAHL_MONATE */.Ev;i++){const lebensMonat=i+1;const current=new ElternGeldAmount();if(i<basisElternGeld.length){current.basisElternGeld=basisElternGeld[i].elternGeld;}if(i<elternGeldPlus.length){current.elterngeldPlus=elternGeldPlus[i].elternGeld;}if(i<nettoLebensMonat.length){current.nettoEinkommen=nettoLebensMonat[i];}if(i===0||current.isNotEquals(previous)&&current.greaterZero()){previous=current;previousRow={vonLebensMonat:lebensMonat,bisLebensMonat:lebensMonat,basisElternGeld:current.basisElternGeld,elternGeldPlus:current.elterngeldPlus,nettoEinkommen:current.nettoEinkommen};rows.push(previousRow);}else if(i>0&&previousRow&&current.isEquals(previous)){previousRow.bisLebensMonat=lebensMonat;}}return{rows};}_ErgebnisUtils.elternGeldSimulationErgebnisOf=elternGeldSimulationErgebnisOf;})(ErgebnisUtils||(ErgebnisUtils={}));class ElternGeldAmount{constructor(){let basisElternGeld=arguments.length>0&&arguments[0]!==undefined?arguments[0]:BIG_ZERO;let elterngeldPlus=arguments.length>1&&arguments[1]!==undefined?arguments[1]:BIG_ZERO;let nettoEinkommen=arguments.length>2&&arguments[2]!==undefined?arguments[2]:BIG_ZERO;this.basisElternGeld=basisElternGeld;this.elterngeldPlus=elterngeldPlus;this.nettoEinkommen=nettoEinkommen;}isEquals(other){return math_util/* MathUtil */.k.isEqual(this.basisElternGeld,other.basisElternGeld)&&math_util/* MathUtil */.k.isEqual(this.elterngeldPlus,other.elterngeldPlus)&&math_util/* MathUtil */.k.isEqual(this.nettoEinkommen,other.nettoEinkommen);}isNotEquals(other){return!this.isEquals(other);}greaterZero(){return this.basisElternGeld.gt(BIG_ZERO)||this.elterngeldPlus.gt(BIG_ZERO)||this.nettoEinkommen.gt(BIG_ZERO);}}
;// CONCATENATED MODULE: ./src/globals/js/calculations/egr-calculation.ts
class EgrCalculation{constructor(){this.bruttoNettoRechner=new BruttoNettoRechner();this.basisEgAlgorithmus=new BasisEgAlgorithmus();this.zwischenErgebnisAlgorithmus=new EgZwischenErgebnisAlgorithmus();}/**
   * Aus den angegebenen Daten wird sowohl das Basiselterngeld als auch das ElterngeldPlus errechnet.
   * Beides wird sozusagen simuliert, damit es im Monatsplaner angezeigt werden kann.
   *
   * @param persoenlicheDaten Persönliche Angaben für die Berechnung des Elterngeldes.
   * @param finanzDaten Angaben zum Einkommen für die Berechnung des Elterngeldes.
   * @param lohnSteuerJahr Das Lohnsteuerjahr für den Brutto-Netto-Rechner.
   * @param mutterschaftsLeistung Die Angaben zum Bezug von Mutterschaftsleistungen.
   */async simulate(persoenlicheDaten,finanzDaten,lohnSteuerJahr,mutterschaftsLeistung){const planungsDaten=new model/* PlanungsDaten */.y7(persoenlicheDaten.isAlleinerziehend(),persoenlicheDaten.isETVorGeburt(),false,mutterschaftsLeistung);planungsDaten.planung=new Array(EgrCalculation.BASIS_ELTERN_GELD_MAX_MONATE).fill(model/* ElternGeldArt */.Tc.BASIS_ELTERNGELD);const basisElternGeldErgebnis=await this.calculateElternGeld({// The current algorithms have side effects. It changes the input data, e.g. persoenlicheDaten.etVorGeburt in basis-eg-algorithmus.ts:259
finanzDaten:(0,model/* finanzDatenOf */.uk)(finanzDaten),persoenlicheDaten:(0,model/* persoenlicheDatenOf */.G0)(persoenlicheDaten),planungsDaten:planungsDaten},lohnSteuerJahr);planungsDaten.planung=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev).fill(model/* ElternGeldArt */.Tc.ELTERNGELD_PLUS);const elternGeldPlusErgebnis=await this.calculateElternGeld({// The current algorithms have side effects. It changes the input data, e.g. persoenlicheDaten.etVorGeburt in basis-eg-algorithmus.ts:259
finanzDaten:(0,model/* finanzDatenOf */.uk)(finanzDaten),persoenlicheDaten:(0,model/* persoenlicheDatenOf */.G0)(persoenlicheDaten),planungsDaten:planungsDaten},lohnSteuerJahr);// Create a list of netto for each Lebensmonat. Similar to ElternGeldAusgabe for each Lebensmonat.
const nettoLebensMonat=await this.nettoLebensMonatOf(finanzDaten,lohnSteuerJahr,persoenlicheDaten.etVorGeburt);return ErgebnisUtils.elternGeldSimulationErgebnisOf(basisElternGeldErgebnis.elternGeldAusgabe,elternGeldPlusErgebnis.elternGeldAusgabe,nettoLebensMonat);}async calculate(elternTeil1,elternTeil2,lohnSteuerJahr){const plusErgebnisElternTeil1=await this.calculateElternGeld(elternTeil1,lohnSteuerJahr);const plusErgebnisElternTeil2=await this.calculateElternGeld(elternTeil2,lohnSteuerJahr);return{elternTeil1:plusErgebnisElternTeil1,elternTeil2:plusErgebnisElternTeil2};}/**
   * Create a list of netto for each Lebensmonat. Similar to ElternGeldAusgabe for each Lebensmonat.
   */async nettoLebensMonatOf(finanzDaten,lohnSteuerJahr,etVorGeburt){const nettoLebensMonat=new Array(model/* PLANUNG_ANZAHL_MONATE */.Ev).fill(math_util/* MathUtil */.k.BIG_ZERO);// calculate netto for one month in each period and then set it for all months of the respective period
for(const erwerbsZeitraumLebensMonat of finanzDaten.erwerbsZeitraumLebensMonatList){const brutto=erwerbsZeitraumLebensMonat.bruttoProMonat.value;const abzuege=await this.bruttoNettoRechner.abzuege(brutto,lohnSteuerJahr,finanzDaten,etVorGeburt);const netto=brutto.sub(abzuege);erwerbsZeitraumLebensMonat.getLebensMonateList().forEach(lebensMonat=>nettoLebensMonat[lebensMonat-1]=netto);}return nettoLebensMonat;}async calculateElternGeld(elternGeldDaten,lohnSteuerJahr){// Steuern berechnen wenn erwerbstätig vor Geburt
const zwischenErgebnisEinkommen=await this.zwischenErgebnisEinkommenOf(elternGeldDaten,lohnSteuerJahr);const zwischenErgebnis=this.zwischenErgebnisAlgorithmus.elterngeldZwischenergebnis(elternGeldDaten.persoenlicheDaten,zwischenErgebnisEinkommen.nettoEinkommen);if(elternGeldDaten.persoenlicheDaten.etNachGeburt!==model/* YesNo */.l.YES){elternGeldDaten.finanzDaten.erwerbsZeitraumLebensMonatList=[];}if(elternGeldDaten.finanzDaten.isMischeinkommen()&&zwischenErgebnisEinkommen.mischEkZwischenErgebnis===null){throw errorOf("MischEinkommenEnabledButMissingMischEinkommen");}return await new PlusEgAlgorithmus().elterngeldPlusErgebnis(elternGeldDaten.planungsDaten,elternGeldDaten.persoenlicheDaten,elternGeldDaten.finanzDaten,lohnSteuerJahr,zwischenErgebnisEinkommen.mischEkZwischenErgebnis,zwischenErgebnis);}async zwischenErgebnisEinkommenOf(elternGeldDaten,lohnSteuerJahr){EgrCalculation.korrigiereErwerbsart(elternGeldDaten);const zwischenErgebnisEinkommen={mischEkZwischenErgebnis:null,nettoEinkommen:new model/* Einkommen */.$J(0)};if(elternGeldDaten.persoenlicheDaten.etVorGeburt!==model/* ErwerbsArt */.$h.NEIN){if(elternGeldDaten.persoenlicheDaten.etVorGeburt===model/* ErwerbsArt */.$h.JA_MISCHEINKOMMEN){zwischenErgebnisEinkommen.mischEkZwischenErgebnis=await this.basisEgAlgorithmus.berechneMischNettoUndBasiselterngeld(elternGeldDaten.persoenlicheDaten,elternGeldDaten.finanzDaten,lohnSteuerJahr);}else{zwischenErgebnisEinkommen.nettoEinkommen=await this.bruttoNettoRechner.nettoEinkommenZwischenErgebnis(elternGeldDaten.finanzDaten,elternGeldDaten.persoenlicheDaten.etVorGeburt,lohnSteuerJahr);}}return zwischenErgebnisEinkommen;}static korrigiereErwerbsart(elternGeldDaten){// mischeinkommen löschen, falls welche vorhanden sind, der der Algorithmus
if(elternGeldDaten.persoenlicheDaten.etVorGeburt!==model/* ErwerbsArt */.$h.JA_MISCHEINKOMMEN&&elternGeldDaten.finanzDaten.mischEinkommenTaetigkeiten.length>0){elternGeldDaten.finanzDaten.mischEinkommenTaetigkeiten=[];}}}EgrCalculation.BASIS_ELTERN_GELD_MAX_MONATE=14;
;// CONCATENATED MODULE: ./src/redux/stepRechnerSlice.ts
const initialBruttoEinkommenZeitraum={bruttoEinkommen:null,zeitraum:{from:"",to:""}};const initialStepRechnerElternteilState={bruttoEinkommenZeitraum:[],keinEinkommen:false,elterngeldResult:{state:"init"},hasBEGResultChangedDueToPrevFormSteps:false};const initialStepRechnerState={ET1:initialStepRechnerElternteilState,ET2:initialStepRechnerElternteilState};const mutterschaftsLeistungOfUi=(state,elternteil)=>{if(state.stepAllgemeineAngaben.mutterschaftssleistungen===model/* YesNo */.l.YES&&state.stepAllgemeineAngaben.mutterschaftssleistungenWer===elternteil){return state.stepNachwuchs.anzahlKuenftigerKinder>1?model/* MutterschaftsLeistung */["do"].MUTTERSCHAFTS_LEISTUNG_12_WOCHEN:model/* MutterschaftsLeistung */["do"].MUTTERSCHAFTS_LEISTUNG_8_WOCHEN;}return model/* MutterschaftsLeistung */["do"].MUTTERSCHAFTS_LEISTUNG_NEIN;};const calculateElterngeld=async(state,elternteil,bruttoEinkommenZeitraum)=>{const bruttoEinkommenZeitraumSanitized=bruttoEinkommenZeitraum.filter(value=>value.bruttoEinkommen!==null&&value.bruttoEinkommen>0);const persoenlicheDaten=persoenlicheDatenOfUi(state,elternteil,bruttoEinkommenZeitraumSanitized);const finanzDaten=finanzDatenOfUi(state,elternteil,bruttoEinkommenZeitraumSanitized);const mutterschaftsLeistung=mutterschaftsLeistungOfUi(state,elternteil);const lohnSteuerJahr=EgrSteuerRechner.bestLohnSteuerJahrOf(persoenlicheDaten.wahrscheinlichesGeburtsDatum);// Wir wissen noch nicht, wann der Nutzer welche Elterngeldart nehmen möchte. Um den Nutzer zu zeigen,
// wie hoch die Beträge sind, berechnen wir für den gesamten Zeitraum Basiselterngeld und ElterngeldPlus,
// auch wenn er beides für die gleichen Monate nicht beziehen kann.
const result=await new EgrCalculation().simulate(persoenlicheDaten,finanzDaten,lohnSteuerJahr,mutterschaftsLeistung);return result.rows.map(row=>({vonLebensMonat:row.vonLebensMonat,bisLebensMonat:row.bisLebensMonat,basisElternGeld:row.basisElternGeld.toNumber(),elternGeldPlus:row.elternGeldPlus.toNumber(),nettoEinkommen:row.nettoEinkommen.toNumber()}));};const calculateBEG=(0,redux_toolkit_modern/* createAsyncThunk */.hg)("stepRechner/calculateBEG",async(_ref,thunkAPI)=>{let{elternteil,bruttoEinkommenZeitraum}=_ref;const state=thunkAPI.getState();const rows=await calculateElterngeld(state,elternteil,bruttoEinkommenZeitraum);return{elternteil,bruttoEinkommenZeitraum,rows};});const recalculateBEG=(0,redux_toolkit_modern/* createAsyncThunk */.hg)("stepRechner/recalculateBEG",async(_ref2,thunkAPI)=>{let{elternteil,bruttoEinkommenZeitraum,previousBEGAmount}=_ref2;const state=thunkAPI.getState();const rows=await calculateElterngeld(state,elternteil,bruttoEinkommenZeitraum);/*
    TODO: änderungen in den rows erkennen

    const amountElterngeld = result.elterngeldbasis.toNumber();
    const amountNettoEinkommen = result.netto.toNumber();

    const hasResultChanged =
      !!previousBEGAmount && previousBEGAmount !== amountElterngeld;
*/return{elternteil,bruttoEinkommenZeitraum,hasResultChanged:false,rows};});const stepRechnerSlice=(0,redux_toolkit_modern/* createSlice */.oM)({name:"stepRechner",initialState:initialStepRechnerState,reducers:{setHasBEGResultChangedDueToPrevFormSteps:(state,action)=>{const recalculateIfNecessary=(changes,state)=>state.hasBEGResultChangedDueToPrevFormSteps=state.elterngeldResult.state!=="init"&&changes;recalculateIfNecessary(action.payload.ET1,state.ET1);recalculateIfNecessary(action.payload.ET2,state.ET2);return state;},resetHasBEGResultChangedDueToPrevFormSteps:(state,action)=>{const{elternteil}=action.payload;if(elternteil==="ET1"){state.ET1.hasBEGResultChangedDueToPrevFormSteps=initialStepRechnerState.ET1.hasBEGResultChangedDueToPrevFormSteps;}if(elternteil==="ET2"){state.ET2.hasBEGResultChangedDueToPrevFormSteps=initialStepRechnerState.ET2.hasBEGResultChangedDueToPrevFormSteps;}}},extraReducers:builder=>{builder.addCase(calculateBEG.pending,(state,_ref3)=>{let{meta}=_ref3;state[meta.arg.elternteil].elterngeldResult={state:"pending"};});builder.addCase(calculateBEG.rejected,(state,_ref4)=>{let{meta}=_ref4;state[meta.arg.elternteil].elterngeldResult={state:"error"};});builder.addCase(calculateBEG.fulfilled,(state,_ref5)=>{let{payload:{elternteil,bruttoEinkommenZeitraum,rows}}=_ref5;state[elternteil].bruttoEinkommenZeitraum=bruttoEinkommenZeitraum;state[elternteil].keinEinkommen=bruttoEinkommenZeitraum.length===0;state[elternteil].elterngeldResult={state:"success",data:rows};});builder.addCase(recalculateBEG.pending,(state,_ref6)=>{let{meta}=_ref6;state[meta.arg.elternteil].elterngeldResult={state:"pending"};});builder.addCase(recalculateBEG.rejected,(state,_ref7)=>{let{meta}=_ref7;state[meta.arg.elternteil].elterngeldResult={state:"error"};});builder.addCase(recalculateBEG.fulfilled,(state,_ref8)=>{let{payload:{elternteil,bruttoEinkommenZeitraum,hasResultChanged,rows}}=_ref8;state[elternteil].bruttoEinkommenZeitraum=bruttoEinkommenZeitraum;state[elternteil].keinEinkommen=bruttoEinkommenZeitraum.length===0;state[elternteil].elterngeldResult={state:"success",data:rows};state[elternteil].hasBEGResultChangedDueToPrevFormSteps=hasResultChanged;});}});const isMonatsplanerOverlayVisible=state=>{const antragstellende=state.stepAllgemeineAngaben.antragstellende;const stateResultElternteil1=state.stepRechner.ET1.elterngeldResult.state;const stateResultElternteil2=state.stepRechner.ET2.elterngeldResult.state;if(antragstellende==="EinenElternteil"){return stateResultElternteil1!=="success";}else{return stateResultElternteil1!=="success"||stateResultElternteil2!=="success";}};const hasElterngeldResult=(0,reselect/* createSelector */.P1)(state=>state.stepRechner.ET1.elterngeldResult.state,state=>state.stepRechner.ET2.elterngeldResult.state,(stateResultElternteil1,stateResultElternteil2)=>{return{ET1:stateResultElternteil1!=="init",ET2:stateResultElternteil2!=="init"};});const stepRechnerSelectors={isMonatsplanerOverlayVisible,hasElterngeldResult};const stepRechnerActions={...stepRechnerSlice.actions,calculateBEG,recalculateBEG};/* harmony default export */ const redux_stepRechnerSlice = (stepRechnerSlice.reducer);

/***/ }),

/***/ 5467:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Lh: () => (/* binding */ setupUserTracking),
  jY: () => (/* reexport */ trackNutzergruppe),
  fX: () => (/* reexport */ trackPartnerschaftlicheVerteilung)
});

// UNUSED EXPORTS: setTrackingVariable

;// CONCATENATED MODULE: ./src/user-tracking/cookies.ts
/**
 * Reads the value of a cookie with given name. If there is not such cookie
 * set yet, this function will wait and poll the cookies till it was set.
 *
 * @param name of the cookie
 * @param pollingInterval milliseconds between polls
 */function waitForCookieValue(name,pollingInterval){return new Promise(resolve=>{const intervalId=setInterval(()=>{const value=getCookies()[name];if(value!==undefined){clearInterval(intervalId);resolve(value);}},pollingInterval);});}/**
 * Parses the encoded document cookie string as a map to read from. This is
 * a work-around till the CookieManager API is well supported by all major
 * web-browsers.
 *
 * @returns map of cookie names to their value
 */function getCookies(){return document.cookie.split(";").map(rawKeyValuePair=>rawKeyValuePair.split("=")).reduce((cookieMap,_ref)=>{let[name,value]=_ref;return{...cookieMap,[name.trim()]:value};},{});}
;// CONCATENATED MODULE: ./src/user-tracking/data-layer.ts
function establishDataLayer(){const timeNow=Date.now();window._mtm=window._mtm||[];window._mtm[0]={event:"mtm.Start","mtm.startTime":timeNow};}/**
 * Set a new or updates the value of a tracking variable. The variable will be made
 * available for triggered events by tags of the tag manager.
 */function setTrackingVariable(name,value){if(window._mtm){window._mtm.push({[name]:value});}}
;// CONCATENATED MODULE: ./src/user-tracking/tag-manager.ts
function setupTagManager(sourceUrl){const isAlreadyPresent=isTagManagerScriptPresent(sourceUrl);if(!isAlreadyPresent){addTagManagerScript(sourceUrl);}}function isTagManagerScriptPresent(sourceUrl){const allScripts=Array.from(document.getElementsByTagName("script"));return allScripts.some(script=>script.src===sourceUrl);}function addTagManagerScript(sourceUrl){var _firstScript$parentNo;const tagManagerScript=document.createElement("script");tagManagerScript.async=true;tagManagerScript.src=sourceUrl;// We can assume that there is any script, else we would not run here.
const firstScript=document.getElementsByTagName("script")[0];(_firstScript$parentNo=firstScript.parentNode)===null||_firstScript$parentNo===void 0?void 0:_firstScript$parentNo.insertBefore(tagManagerScript,firstScript);}
;// CONCATENATED MODULE: ./src/user-tracking/nutzergruppe.ts
var Nutzergruppe=/*#__PURE__*/function(Nutzergruppe){Nutzergruppe["WERDENDE_ELTERN"]="werdende Eltern";Nutzergruppe["JUNGE_ELTERN"]="junge Eltern";Nutzergruppe["NACHBEANTRAGENDE_ELTERN"]="nachbeantragende Eltern";return Nutzergruppe;}(Nutzergruppe||{});function trackNutzergruppe(birthdate){const nutzergruppe=mapDateToNutzergruppe(birthdate);setTrackingVariable(TRACKING_VARIABLE_NAME,nutzergruppe);}function mapDateToNutzergruppe(birthdate){const today=new Date();const dayThreeMonthsAgo=new Date(new Date().setMonth(today.getMonth()-3));const isInFuture=birthdate>today;const wasWithinLastThreeMonths=dayThreeMonthsAgo<=birthdate&&birthdate<=today;return isInFuture?Nutzergruppe.WERDENDE_ELTERN:wasWithinLastThreeMonths?Nutzergruppe.JUNGE_ELTERN:Nutzergruppe.NACHBEANTRAGENDE_ELTERN;}const TRACKING_VARIABLE_NAME="nutzergruppe";
;// CONCATENATED MODULE: ./src/user-tracking/partnerschaftlichkeit.ts
function trackPartnerschaftlicheVerteilung(monthsET1,monthsET2,singleApplicant){if(!singleApplicant){const verteilung=calculatePartnerschaftlichkeiteVerteilung(monthsET1,monthsET2);setTrackingVariable(partnerschaftlichkeit_TRACKING_VARIABLE_NAME,verteilung);}}/**
 * This is a small algorithm which calculates a quotient of how well the planned
 * months are distributed between both partners. A quotient of `0` means no
 * distribution at all, while `1` means completely equal distribution. This takes
 * into account the different variants partners can choose from and assigns
 * balanced values to them.
 *
 * @returns quotient between 0 and 1 of the distribution
 */function calculatePartnerschaftlichkeiteVerteilung(monthsET1,monthsET2){const valueET1=calculateValueOfElternteil(monthsET1);const valueET2=calculateValueOfElternteil(monthsET2);const smallerValue=Math.min(valueET1,valueET2);const biggerValue=Math.max(valueET1,valueET2);const hasNoPartnerschaftlichkeit=biggerValue===0;const quotient=smallerValue/biggerValue;return hasNoPartnerschaftlichkeit?0:quotient;}/**
 * The calculated "value" for a partner is a unit less numeric value that
 * represents the sum of all the months planned for this partner. Therefore,
 * each planned month get weighted based on the chosen variant.
 */function calculateValueOfElternteil(months){return months.map(type=>ELTERNGELD_TYPE_TO_PARTNERSCHAFTLICHKEITS_VALUE[type]).reduce((sum,value)=>sum+value,0);}const ELTERNGELD_TYPE_TO_PARTNERSCHAFTLICHKEITS_VALUE={BEG:1,"EG+":0.5,PSB:0.5,None:0};const partnerschaftlichkeit_TRACKING_VARIABLE_NAME="partnerschaftlicheverteilung";
;// CONCATENATED MODULE: ./src/user-tracking/index.ts
async function setupUserTracking(){const tagMangerSourceUrl=getTagMangerSourceUrl();const isConfigured=!!tagMangerSourceUrl;if(isConfigured&&(await isTrackingAllowedByUser())){establishDataLayer();setupTagManager(tagMangerSourceUrl);}}function getTagMangerSourceUrl(){return ({"NODE_ENV":"production","PUBLIC_URL":".","WDS_SOCKET_HOST":undefined,"WDS_SOCKET_PATH":undefined,"WDS_SOCKET_PORT":undefined,"FAST_REFRESH":true,"REACT_APP_BMF_STEUER_RECHNER_DOMAIN":"","REACT_APP_BMF_STEUER_RECHNER_CODE":"2022eP","REACT_APP_BMF_STEUER_RECHNER_AVAILABLE_YEARS_REMOTE":"2021,2022","REACT_APP_BMF_STEUER_RECHNER_AVAILABLE_YEARS_LIB":"2022,2023","REACT_APP_CALCULATIONS_LOGGER_ENABLED":"false"}).REACT_APP_USER_TRACKING_TAG_MANAGER_SOURCE;}async function isTrackingAllowedByUser(){const cookieValue=await waitForCookieValue(ALLOW_TRACKING_COOKIE_NAME,COOKIE_POLLING_INTERVAL);return cookieValue==="1";}const ALLOW_TRACKING_COOKIE_NAME="cookie-allow-tracking";// set by cookie banner of the Familienportal
const COOKIE_POLLING_INTERVAL=500;

/***/ }),

/***/ 8137:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ formSteps)
/* harmony export */ });
const formSteps={allgemeinAngaben:{text:"Allgemeine Angaben",route:"/allgemeine-angaben"},nachwuchs:{text:"Ihr Nachwuchs",route:"/nachwuchs"},erwerbstaetigkeit:{text:"Erwerbstätigkeit",route:"/erwerbstaetigkeit"},einkommen:{text:"Ihr Einkommen",route:"/einkommen"},elterngeldvarianten:{text:"Elterngeldvarianten",route:"/elterngeldvarianten"},rechnerUndPlaner:{text:"Rechner und Planer",route:"/rechner-planer"},zusammenfassungUndDaten:{text:"Zusammenfassung",route:"/zusammenfassung-und-daten"}};

/***/ }),

/***/ 3227:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ formatAsCurrency),
/* harmony export */   j: () => (/* binding */ parseGermanDateString)
/* harmony export */ });
function formatAsCurrency(amount){const rounded=Math.floor(amount);return rounded.toLocaleString(undefined,{style:"currency",currency:"EUR",currencyDisplay:"symbol",maximumFractionDigits:0});}function parseGermanDateString(dateString){const[day,month,year]=dateString.split(".");return new Date(Number.parseInt(year),Number.parseInt(month)-1,Number.parseInt(day));}

/***/ }),

/***/ 1315:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PARAMS = void 0;
var big_js_1 = __webpack_require__(5395);
var constants_1 = __webpack_require__(2898);
var _2022_1 = __webpack_require__(1686);
var _2023_1 = __webpack_require__(2276);
var parseYEAR = function (inputYear) {
  var calculationYear;
  var calculationPatch;
  if (typeof inputYear === "number") {
    calculationYear = inputYear;
    calculationPatch = "";
  } else {
    var _a = inputYear.split("."),
      cYear = _a[0],
      cPatch = _a[1];
    calculationYear = parseInt(cYear);
    calculationPatch = cPatch;
  }
  return {
    BJAHR: calculationYear,
    PATCH: calculationPatch
  };
};
var PARAMS = function (year, CONFIG) {
  var _a = parseYEAR(year),
    BJAHR = _a.BJAHR,
    PATCH = _a.PATCH;
  var base = {
    BJAHR: BJAHR,
    PATCH: PATCH,
    KENNVMT: constants_1.KENNVMT.NORMAL,
    GFB: new big_js_1.default(0),
    SOLZFREI: new big_js_1.default(0),
    TBSVORV: new big_js_1.default(0),
    W1STKL5: new big_js_1.default(0),
    W2STKL5: new big_js_1.default(0),
    W3STKL5: new big_js_1.default(222260),
    RVSATZAN: new big_js_1.default(0),
    BBGRV: new big_js_1.default(0),
    VBEZBSO: new big_js_1.default(0),
    PVSATZAG: new big_js_1.default(0),
    PVSATZAN: new big_js_1.default(0),
    KVSATZAG: new big_js_1.default(0),
    KVSATZAN: new big_js_1.default(0),
    BBGKVPV: new big_js_1.default(0)
  };
  return __assign(__assign(__assign({}, base), BJAHR === 2022 ? (0, _2022_1.default)(CONFIG, base) : {}), BJAHR === 2023 ? (0, _2023_1.default)(CONFIG, base) : {});
};
exports.PARAMS = PARAMS;

/***/ }),

/***/ 1686:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.config = void 0;
var big_js_1 = __webpack_require__(5395);
var initial = function (_a, base) {
  var KRV = _a.KRV,
    KVZ = _a.KVZ,
    PVS = _a.PVS,
    PVZ = _a.PVZ;
  var defaults;
  defaults = __assign(__assign({}, base), {
    GFB: new big_js_1.default(9984),
    SOLZFREI: new big_js_1.default(16956),
    W1STKL5: new big_js_1.default(11480),
    W2STKL5: new big_js_1.default(29298),
    BBGKVPV: new big_js_1.default(58050),
    KVSATZAN: KVZ.div(2).div(100).add(0.07),
    KVSATZAG: new big_js_1.default(0.0065).add(0.07)
  });
  if (KRV < 2) {
    defaults = __assign(__assign({}, defaults), {
      BBGRV: KRV === 0 ? new big_js_1.default(84600) : new big_js_1.default(81000),
      RVSATZAN: new big_js_1.default(0.093),
      TBSVORV: new big_js_1.default(0.88)
    });
  }
  if (PVS) {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: new big_js_1.default(0.02025),
      PVSATZAG: new big_js_1.default(0.01025)
    });
  } else {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: new big_js_1.default(0.01525),
      PVSATZAG: new big_js_1.default(0.01525)
    });
  }
  if (PVZ) {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: defaults.PVSATZAN.add(0.0035)
    });
  }
  return __assign({}, defaults);
};
var june = function (_a, base) {
  var KRV = _a.KRV,
    KVZ = _a.KVZ,
    PVS = _a.PVS,
    PVZ = _a.PVZ;
  var defaults;
  defaults = __assign(__assign({}, base), {
    GFB: new big_js_1.default(10347),
    SOLZFREI: new big_js_1.default(16956),
    W1STKL5: new big_js_1.default(11793),
    W2STKL5: new big_js_1.default(29298),
    BBGKVPV: new big_js_1.default(58050),
    KVSATZAN: KVZ.div(2).div(100).add(0.07),
    KVSATZAG: new big_js_1.default(0.0065).add(0.07)
  });
  if (KRV < 2) {
    defaults = __assign(__assign({}, defaults), {
      BBGRV: KRV === 0 ? new big_js_1.default(84600) : new big_js_1.default(81000),
      RVSATZAN: new big_js_1.default(0.093),
      TBSVORV: new big_js_1.default(0.88)
    });
  }
  if (PVS) {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: new big_js_1.default(0.02025),
      PVSATZAG: new big_js_1.default(0.01025)
    });
  } else {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: new big_js_1.default(0.01525),
      PVSATZAG: new big_js_1.default(0.01525)
    });
  }
  if (PVZ) {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: defaults.PVSATZAN.add(0.0035)
    });
  }
  return __assign({}, defaults);
};
var config = function (CONFIG, base) {
  var PATCH = base.PATCH;
  if (PATCH && PATCH === "1") return __assign({}, initial(CONFIG, base));
  return __assign({}, june(CONFIG, base));
};
exports.config = config;
exports["default"] = exports.config;

/***/ }),

/***/ 2276:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.config = void 0;
var big_js_1 = __webpack_require__(5395);
var initial = function (_a, base) {
  var KRV = _a.KRV,
    KVZ = _a.KVZ,
    PVS = _a.PVS,
    PVZ = _a.PVZ;
  var defaults;
  defaults = __assign(__assign({}, base), {
    GFB: new big_js_1.default(10908),
    SOLZFREI: new big_js_1.default(17543),
    W1STKL5: new big_js_1.default(12485),
    W2STKL5: new big_js_1.default(31404),
    BBGKVPV: new big_js_1.default(59850),
    KVSATZAN: KVZ.div(2).div(100).add(0.07),
    KVSATZAG: new big_js_1.default(0.008).add(0.07)
  });
  if (KRV < 2) {
    defaults = __assign(__assign({}, defaults), {
      BBGRV: KRV === 0 ? new big_js_1.default(87600) : new big_js_1.default(85200),
      RVSATZAN: new big_js_1.default(0.093),
      TBSVORV: new big_js_1.default(1.0)
    });
  }
  if (PVS) {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: new big_js_1.default(0.02025),
      PVSATZAG: new big_js_1.default(0.01025)
    });
  } else {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: new big_js_1.default(0.01525),
      PVSATZAG: new big_js_1.default(0.01525)
    });
  }
  if (PVZ) {
    defaults = __assign(__assign({}, defaults), {
      PVSATZAN: defaults.PVSATZAN.add(0.0035)
    });
  }
  return __assign({}, defaults);
};
var july = function (_a, base) {
  var KRV = _a.KRV,
    KVZ = _a.KVZ,
    PVS = _a.PVS,
    PVZ = _a.PVZ,
    LZZ = _a.LZZ;
  var defaults;
  defaults = __assign(__assign({}, base), {
    GFB: new big_js_1.default(10908),
    SOLZFREI: new big_js_1.default(17543),
    W1STKL5: new big_js_1.default(12485),
    W2STKL5: new big_js_1.default(31404),
    BBGKVPV: new big_js_1.default(59850),
    KVSATZAN: KVZ.div(2).div(100).add(0.07),
    KVSATZAG: new big_js_1.default(0.008).add(0.07)
  });
  if (KRV < 2) {
    defaults = __assign(__assign({}, defaults), {
      BBGRV: KRV === 0 ? new big_js_1.default(87600) : new big_js_1.default(85200),
      RVSATZAN: new big_js_1.default(0.093),
      TBSVORV: new big_js_1.default(1.0)
    });
  }
  if (LZZ === 1) {
    if (PVS) {
      defaults = __assign(__assign({}, defaults), {
        PVSATZAN: new big_js_1.default(0.021125),
        PVSATZAG: new big_js_1.default(0.011125)
      });
    } else {
      defaults = __assign(__assign({}, defaults), {
        PVSATZAN: new big_js_1.default(0.016125),
        PVSATZAG: new big_js_1.default(0.016125)
      });
    }
    if (PVZ) {
      defaults = __assign(__assign({}, defaults), {
        PVSATZAN: defaults.PVSATZAN.add(new big_js_1.default(0.00475))
      });
    }
  } else {
    if (PVS) {
      defaults = __assign(__assign({}, defaults), {
        PVSATZAN: new big_js_1.default(0.022),
        PVSATZAG: new big_js_1.default(0.012)
      });
    } else {
      defaults = __assign(__assign({}, defaults), {
        PVSATZAN: new big_js_1.default(0.017),
        PVSATZAG: new big_js_1.default(0.017)
      });
    }
    if (PVZ) {
      defaults = __assign(__assign({}, defaults), {
        PVSATZAN: defaults.PVSATZAN.add(new big_js_1.default(0.006))
      });
    }
  }
  return __assign({}, defaults);
};
var config = function (CONFIG, base) {
  var PATCH = base.PATCH;
  if (PATCH && PATCH === "1") return __assign({}, initial(CONFIG, base));
  return __assign({}, july(CONFIG, base));
};
exports.config = config;
exports["default"] = exports.config;

/***/ }),

/***/ 2898:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TAB5 = exports.TAB4 = exports.TAB3 = exports.TAB2 = exports.TAB1 = exports.KENNVMT = exports.KZTAB = exports.STKL = exports.PKV = exports.LZZ = exports.KRV = void 0;
var big_js_1 = __webpack_require__(5395);
var KRV;
(function (KRV) {
  KRV[KRV["BBGW"] = 0] = "BBGW";
  KRV[KRV["BBGO"] = 1] = "BBGO";
  KRV[KRV["NONE"] = 2] = "NONE";
})(KRV || (exports.KRV = KRV = {}));
var LZZ;
(function (LZZ) {
  LZZ[LZZ["JAHR"] = 1] = "JAHR";
  LZZ[LZZ["MONAT"] = 2] = "MONAT";
  LZZ[LZZ["WOCHE"] = 3] = "WOCHE";
  LZZ[LZZ["TAG"] = 4] = "TAG";
})(LZZ || (exports.LZZ = LZZ = {}));
var PKV;
(function (PKV) {
  PKV[PKV["GKA"] = 0] = "GKA";
  PKV[PKV["PKAO"] = 1] = "PKAO";
  PKV[PKV["PKAM"] = 2] = "PKAM"; // 2 = ausschließlich privat krankenversicherte Arbeitnehmer mit Arbeitgeberzuschuss
})(PKV || (exports.PKV = PKV = {}));
var STKL;
(function (STKL) {
  STKL[STKL["I"] = 1] = "I";
  STKL[STKL["II"] = 2] = "II";
  STKL[STKL["III"] = 3] = "III";
  STKL[STKL["IV"] = 4] = "IV";
  STKL[STKL["V"] = 5] = "V";
  STKL[STKL["VI"] = 6] = "VI";
})(STKL || (exports.STKL = STKL = {}));
var KZTAB;
(function (KZTAB) {
  KZTAB[KZTAB["GRUND"] = 1] = "GRUND";
  KZTAB[KZTAB["SPLIT"] = 2] = "SPLIT";
})(KZTAB || (exports.KZTAB = KZTAB = {}));
var KENNVMT;
(function (KENNVMT) {
  KENNVMT[KENNVMT["NORMAL"] = 0] = "NORMAL";
  KENNVMT[KENNVMT["MJTAT"] = 1] = "MJTAT";
  KENNVMT[KENNVMT["VORPAU"] = 2] = "VORPAU";
})(KENNVMT || (exports.KENNVMT = KENNVMT = {}));
exports.TAB1 = {
  "2005": new big_js_1.default(0.400),
  "2006": new big_js_1.default(0.384),
  "2007": new big_js_1.default(0.368),
  "2008": new big_js_1.default(0.352),
  "2009": new big_js_1.default(0.336),
  "2010": new big_js_1.default(0.320),
  "2011": new big_js_1.default(0.304),
  "2012": new big_js_1.default(0.288),
  "2013": new big_js_1.default(0.272),
  "2014": new big_js_1.default(0.256),
  "2015": new big_js_1.default(0.240),
  "2016": new big_js_1.default(0.224),
  "2017": new big_js_1.default(0.208),
  "2018": new big_js_1.default(0.192),
  "2019": new big_js_1.default(0.176),
  "2020": new big_js_1.default(0.160),
  "2021": new big_js_1.default(0.152),
  "2022": new big_js_1.default(0.144),
  "2023": new big_js_1.default(0.136),
  "2024": new big_js_1.default(0.128),
  "2025": new big_js_1.default(0.120),
  "2026": new big_js_1.default(0.112),
  "2027": new big_js_1.default(0.104),
  "2028": new big_js_1.default(0.096),
  "2029": new big_js_1.default(0.088),
  "2030": new big_js_1.default(0.080),
  "2031": new big_js_1.default(0.072),
  "2032": new big_js_1.default(0.064),
  "2033": new big_js_1.default(0.056),
  "2034": new big_js_1.default(0.048),
  "2035": new big_js_1.default(0.040),
  "2036": new big_js_1.default(0.032),
  "2037": new big_js_1.default(0.024),
  "2038": new big_js_1.default(0.016),
  "2039": new big_js_1.default(0.008),
  "2040": new big_js_1.default(0.000)
}; // Tabelle für die Prozentsätze des Versorgungsfreibetrags
exports.TAB2 = {
  "2005": new big_js_1.default(3000),
  "2006": new big_js_1.default(2880),
  "2007": new big_js_1.default(2760),
  "2008": new big_js_1.default(2640),
  "2009": new big_js_1.default(2520),
  "2010": new big_js_1.default(2400),
  "2011": new big_js_1.default(2280),
  "2012": new big_js_1.default(2160),
  "2013": new big_js_1.default(2040),
  "2014": new big_js_1.default(1920),
  "2015": new big_js_1.default(1800),
  "2016": new big_js_1.default(1680),
  "2017": new big_js_1.default(1560),
  "2018": new big_js_1.default(1440),
  "2019": new big_js_1.default(1320),
  "2020": new big_js_1.default(1200),
  "2021": new big_js_1.default(1140),
  "2022": new big_js_1.default(1080),
  "2023": new big_js_1.default(1020),
  "2024": new big_js_1.default(960),
  "2025": new big_js_1.default(900),
  "2026": new big_js_1.default(840),
  "2027": new big_js_1.default(780),
  "2028": new big_js_1.default(720),
  "2029": new big_js_1.default(660),
  "2030": new big_js_1.default(600),
  "2031": new big_js_1.default(540),
  "2032": new big_js_1.default(480),
  "2033": new big_js_1.default(420),
  "2034": new big_js_1.default(360),
  "2035": new big_js_1.default(300),
  "2036": new big_js_1.default(240),
  "2037": new big_js_1.default(180),
  "2038": new big_js_1.default(120),
  "2039": new big_js_1.default(60),
  "2040": new big_js_1.default(0)
}; // Tabelle für die Höchstbeträge des Versorgungsfreibetrags
exports.TAB3 = {
  "2005": new big_js_1.default(900),
  "2006": new big_js_1.default(864),
  "2007": new big_js_1.default(828),
  "2008": new big_js_1.default(792),
  "2009": new big_js_1.default(756),
  "2010": new big_js_1.default(720),
  "2011": new big_js_1.default(684),
  "2012": new big_js_1.default(648),
  "2013": new big_js_1.default(612),
  "2014": new big_js_1.default(576),
  "2015": new big_js_1.default(540),
  "2016": new big_js_1.default(504),
  "2017": new big_js_1.default(468),
  "2018": new big_js_1.default(432),
  "2019": new big_js_1.default(396),
  "2020": new big_js_1.default(360),
  "2021": new big_js_1.default(342),
  "2022": new big_js_1.default(324),
  "2023": new big_js_1.default(306),
  "2024": new big_js_1.default(288),
  "2025": new big_js_1.default(270),
  "2026": new big_js_1.default(252),
  "2027": new big_js_1.default(234),
  "2028": new big_js_1.default(216),
  "2029": new big_js_1.default(198),
  "2030": new big_js_1.default(180),
  "2031": new big_js_1.default(162),
  "2032": new big_js_1.default(144),
  "2033": new big_js_1.default(126),
  "2034": new big_js_1.default(108),
  "2035": new big_js_1.default(90),
  "2036": new big_js_1.default(72),
  "2037": new big_js_1.default(54),
  "2038": new big_js_1.default(36),
  "2039": new big_js_1.default(18),
  "2040": new big_js_1.default(0)
}; // Tabelle für die Zuschläge zum Versorgungsfreibetrag
exports.TAB4 = {
  "2005": new big_js_1.default(0.400),
  "2006": new big_js_1.default(0.384),
  "2007": new big_js_1.default(0.368),
  "2008": new big_js_1.default(0.352),
  "2009": new big_js_1.default(0.336),
  "2010": new big_js_1.default(0.320),
  "2011": new big_js_1.default(0.304),
  "2012": new big_js_1.default(0.288),
  "2013": new big_js_1.default(0.272),
  "2014": new big_js_1.default(0.256),
  "2015": new big_js_1.default(0.240),
  "2016": new big_js_1.default(0.224),
  "2017": new big_js_1.default(0.208),
  "2018": new big_js_1.default(0.192),
  "2019": new big_js_1.default(0.176),
  "2020": new big_js_1.default(0.160),
  "2021": new big_js_1.default(0.152),
  "2022": new big_js_1.default(0.144),
  "2023": new big_js_1.default(0.136),
  "2024": new big_js_1.default(0.128),
  "2025": new big_js_1.default(0.120),
  "2026": new big_js_1.default(0.112),
  "2027": new big_js_1.default(0.104),
  "2028": new big_js_1.default(0.096),
  "2029": new big_js_1.default(0.088),
  "2030": new big_js_1.default(0.080),
  "2031": new big_js_1.default(0.072),
  "2032": new big_js_1.default(0.064),
  "2033": new big_js_1.default(0.056),
  "2034": new big_js_1.default(0.048),
  "2035": new big_js_1.default(0.040),
  "2036": new big_js_1.default(0.032),
  "2037": new big_js_1.default(0.024),
  "2038": new big_js_1.default(0.016),
  "2039": new big_js_1.default(0.008),
  "2040": new big_js_1.default(0.000)
}; // Tabelle für die Prozentsätze des Altersentlastungsbetrags
exports.TAB5 = {
  "2005": new big_js_1.default(1900),
  "2006": new big_js_1.default(1824),
  "2007": new big_js_1.default(1748),
  "2008": new big_js_1.default(1672),
  "2009": new big_js_1.default(1596),
  "2010": new big_js_1.default(1520),
  "2011": new big_js_1.default(1444),
  "2012": new big_js_1.default(1368),
  "2013": new big_js_1.default(1292),
  "2014": new big_js_1.default(1216),
  "2015": new big_js_1.default(1140),
  "2016": new big_js_1.default(1064),
  "2017": new big_js_1.default(988),
  "2018": new big_js_1.default(912),
  "2019": new big_js_1.default(836),
  "2020": new big_js_1.default(760),
  "2021": new big_js_1.default(722),
  "2022": new big_js_1.default(684),
  "2023": new big_js_1.default(646),
  "2024": new big_js_1.default(608),
  "2025": new big_js_1.default(570),
  "2026": new big_js_1.default(532),
  "2027": new big_js_1.default(494),
  "2028": new big_js_1.default(456),
  "2029": new big_js_1.default(418),
  "2030": new big_js_1.default(380),
  "2031": new big_js_1.default(342),
  "2032": new big_js_1.default(304),
  "2033": new big_js_1.default(266),
  "2034": new big_js_1.default(228),
  "2035": new big_js_1.default(190),
  "2036": new big_js_1.default(152),
  "2037": new big_js_1.default(114),
  "2038": new big_js_1.default(76),
  "2039": new big_js_1.default(38),
  "2040": new big_js_1.default(0)
}; // Tabelle für die Höchstbeträge des Altersentlastungsbetrags

/***/ }),

/***/ 1701:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = __webpack_unused_export__ = exports.w8 = void 0;
var lst_1 = __webpack_require__(407);
Object.defineProperty(exports, "w8", ({
  enumerable: true,
  get: function () {
    return lst_1.LST;
  }
}));
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return lst_1.LST2022;
  }
});
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return lst_1.LST2023;
  }
});

/***/ }),

/***/ 383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.INPUTS = void 0;
var big_js_1 = __webpack_require__(5395);
var constants_1 = __webpack_require__(2898);
var INPUTS = /** @class */function () {
  function INPUTS(PARAMETER) {
    this.AJAHR = 0;
    this.VJAHR = 0;
    this.STKL = PARAMETER.STKL;
    this.LZZ = PARAMETER.LZZ;
    this.RE4 = PARAMETER.RE4;
    this.AF = undefined === PARAMETER.AF ? false : PARAMETER.AF;
    this.F = undefined === PARAMETER.F ? new big_js_1.default(0) : PARAMETER.F;
    this.R = undefined === PARAMETER.R ? 0 : PARAMETER.R;
    this.ALTER1 = undefined === PARAMETER.ALTER1 ? false : PARAMETER.ALTER1;
    this.AJAHR = undefined === PARAMETER.AJAHR ? 0 : PARAMETER.AJAHR;
    this.VJAHR = undefined === PARAMETER.VJAHR ? 0 : PARAMETER.VJAHR;
    this.ZMVB = undefined === PARAMETER.ZMVB ? 0 : PARAMETER.ZMVB;
    this.PVS = undefined === PARAMETER.PVS ? false : PARAMETER.PVS;
    this.PVZ = undefined === PARAMETER.PVZ ? false : PARAMETER.PVZ;
    this.KRV = undefined === PARAMETER.KRV ? constants_1.KRV.BBGW : PARAMETER.KRV;
    this.PKV = undefined === PARAMETER.PKV ? constants_1.PKV.GKA : PARAMETER.PKV;
    this.PKPV = undefined === PARAMETER.PKPV ? new big_js_1.default(0) : PARAMETER.PKPV;
    this.ZKF = undefined === PARAMETER.ZKF ? new big_js_1.default(0) : PARAMETER.ZKF;
    this.JFREIB = undefined === PARAMETER.JFREIB ? new big_js_1.default(0) : PARAMETER.JFREIB;
    this.JHINZU = undefined === PARAMETER.JHINZU ? new big_js_1.default(0) : PARAMETER.JHINZU;
    this.KVZ = undefined === PARAMETER.KVZ ? new big_js_1.default(0) : PARAMETER.KVZ;
    this.ENTSCH = undefined === PARAMETER.ENTSCH ? new big_js_1.default(0) : PARAMETER.ENTSCH;
    this.LZZHINZU = undefined === PARAMETER.LZZHINZU ? new big_js_1.default(0) : PARAMETER.LZZHINZU;
    this.LZZFREIB = undefined === PARAMETER.LZZFREIB ? new big_js_1.default(0) : PARAMETER.LZZFREIB;
    this.MBV = undefined === PARAMETER.MBV ? new big_js_1.default(0) : PARAMETER.MBV;
    this.JRE4 = undefined === PARAMETER.JRE4 ? new big_js_1.default(0) : PARAMETER.JRE4;
    this.JRE4ENT = undefined === PARAMETER.JRE4ENT ? new big_js_1.default(0) : PARAMETER.JRE4ENT;
    this.VBEZ = undefined === PARAMETER.VBEZ ? new big_js_1.default(0) : PARAMETER.VBEZ;
    this.JVBEZ = undefined === PARAMETER.JVBEZ ? new big_js_1.default(0) : PARAMETER.JVBEZ;
    this.VBEZS = undefined === PARAMETER.VBEZS ? new big_js_1.default(0) : PARAMETER.VBEZS;
    this.VBEZM = undefined === PARAMETER.VBEZM ? new big_js_1.default(0) : PARAMETER.VBEZM;
    this.VKAPA = undefined === PARAMETER.VKAPA ? new big_js_1.default(0) : PARAMETER.VKAPA;
    this.VMT = undefined === PARAMETER.VMT ? new big_js_1.default(0) : PARAMETER.VMT;
    this.SONSTB = undefined === PARAMETER.SONSTB ? new big_js_1.default(0) : PARAMETER.SONSTB;
    this.SONSTENT = undefined === PARAMETER.SONSTENT ? new big_js_1.default(0) : PARAMETER.SONSTENT;
    this.VBS = undefined === PARAMETER.VBS ? new big_js_1.default(0) : PARAMETER.VBS;
    this.STERBE = undefined === PARAMETER.STERBE ? new big_js_1.default(0) : PARAMETER.STERBE;
    return this;
  }
  return INPUTS;
}();
exports.INPUTS = INPUTS;

/***/ }),

/***/ 407:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LST2023 = exports.LST2022 = exports.LST = void 0;
var mpara_1 = __webpack_require__(7716);
var mre4jl_1 = __webpack_require__(4305);
var mre4_1 = __webpack_require__(1289);
var mre4abz_1 = __webpack_require__(5391);
var mberech_1 = __webpack_require__(8840);
var msonst_1 = __webpack_require__(5052);
var mvmt_1 = __webpack_require__(4998);
var input_1 = __webpack_require__(383);
var LST = function (YEAR, INPUT) {
  var INPUTDATA = new input_1.INPUTS(INPUT);
  var CONFIGURATION = (0, mpara_1.MPARA)(YEAR, INPUTDATA);
  var _a = (0, mre4jl_1.MRE4JL)(INPUTDATA),
    ZRE4J = _a.ZRE4J,
    JLHINZU = _a.JLHINZU,
    JLFREIB = _a.JLFREIB,
    ZVBEZJ = _a.ZVBEZJ,
    f = _a.F;
  INPUTDATA.F = f;
  var _b = (0, mre4_1.MRE4)(__assign(__assign({}, INPUTDATA), {
      ZVBEZJ: ZVBEZJ,
      ZRE4J: ZRE4J
    }), CONFIGURATION),
    ALTE = _b.ALTE,
    FVB = _b.FVB,
    FVBZ = _b.FVBZ,
    FVBZSO = _b.FVBZSO;
  var _c = (0, mre4abz_1.MRE4ABZ)(__assign(__assign({}, INPUTDATA), {
      ZRE4J: ZRE4J,
      ZVBEZJ: ZVBEZJ,
      FVB: FVB,
      ALTE: ALTE,
      JLFREIB: JLFREIB,
      JLHINZU: JLHINZU
    }), CONFIGURATION),
    ZRE4 = _c.ZRE4,
    ZRE4VP = _c.ZRE4VP,
    ZVBEZ = _c.ZVBEZ;
  var _d = (0, mberech_1.MBERECH)(__assign(__assign({}, INPUTDATA), {
      ZRE4: ZRE4,
      ZRE4J: ZRE4J,
      ZRE4VP: ZRE4VP,
      ZVBEZ: ZVBEZ,
      ZVBEZJ: ZVBEZJ,
      FVB: FVB,
      FVBZ: FVBZ,
      FVBZSO: FVBZSO,
      ALTE: ALTE,
      JLFREIB: JLFREIB,
      JLHINZU: JLHINZU
    }), CONFIGURATION),
    mberechBK = _d.BK,
    VFRB = _d.VFRB,
    VKVLZZ = _d.VKVLZZ,
    SOLZLZZ = _d.SOLZLZZ,
    LSTLZZ = _d.LSTLZZ,
    JBMG = _d.JBMG,
    KZTAB = _d.KZTAB,
    ZTABFB = _d.ZTABFB,
    WVFRB = _d.WVFRB;
  var _e = (0, msonst_1.MSONST)(__assign(__assign({}, INPUTDATA), {
      BK: mberechBK,
      JLFREIB: JLFREIB,
      JLHINZU: JLHINZU,
      LSTLZZ: LSTLZZ,
      SOLZLZZ: SOLZLZZ
    }), CONFIGURATION),
    VKVSONST = _e.VKVSONST,
    VFRBS1 = _e.VFRBS1,
    VFRBS2 = _e.VFRBS2,
    SOLZS = _e.SOLZS,
    STS = _e.STS,
    BKS = _e.BKS,
    BK = _e.BK,
    LSTSO = _e.LSTSO,
    WVFRBM = _e.WVFRBM,
    WVFRBO = _e.WVFRBO;
  var _f = (0, mvmt_1.MVMT)(__assign(__assign({}, INPUTDATA), {
      LSTSO: LSTSO,
      VFRBS1: VFRBS1,
      KZTAB: KZTAB,
      ZTABFB: ZTABFB,
      ALTE: ALTE,
      JLFREIB: JLFREIB,
      JLHINZU: JLHINZU,
      ZRE4: ZRE4,
      JBMG: JBMG
    }), CONFIGURATION),
    BKV = _f.BKV,
    SOLZV = _f.SOLZV,
    STV = _f.STV;
  return {
    BK: BK.toNumber(),
    BKS: BKS.toNumber(),
    BKV: BKV.toNumber(),
    LSTLZZ: LSTLZZ.toNumber(),
    SOLZLZZ: SOLZLZZ.toNumber(),
    SOLZS: SOLZS.toNumber(),
    SOLZV: SOLZV.toNumber(),
    STS: STS.toNumber(),
    STV: STV.toNumber(),
    VKVLZZ: VKVLZZ.toNumber(),
    VKVSONST: VKVSONST.toNumber(),
    VFRB: VFRB.toNumber(),
    VFRBS1: VFRBS1.toNumber(),
    VFRBS2: VFRBS2.toNumber(),
    WVFRB: WVFRB.toNumber(),
    WVFRBO: WVFRBO.toNumber(),
    WVFRBM: WVFRBM.toNumber()
  };
};
exports.LST = LST;
var LST2022 = function (INPUT) {
  return (0, exports.LST)(2022, INPUT);
};
exports.LST2022 = LST2022;
var LST2023 = function (INPUT) {
  return (0, exports.LST)(2023, INPUT);
};
exports.LST2023 = LST2023;

/***/ }),

/***/ 8840:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = this && this.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MBERECH = void 0;
var big_js_1 = __webpack_require__(5395);
var mztabfb_1 = __webpack_require__(1667);
var mlstjahr_1 = __webpack_require__(7558);
var uplstlzz_1 = __webpack_require__(9505);
var upvklzz_1 = __webpack_require__(2377);
var mre4abz_1 = __webpack_require__(5391);
var msolz_1 = __webpack_require__(3991);
var MBERECH = function (_a, CONFIG) {
  var FVB = _a.FVB,
    FVBZ = _a.FVBZ,
    FVBZSO = _a.FVBZSO,
    ZRE4 = _a.ZRE4,
    ZRE4VP = _a.ZRE4VP,
    ZRE4J = _a.ZRE4J,
    ZVBEZ = _a.ZVBEZ,
    ZVBEZJ = _a.ZVBEZJ,
    ALTE = _a.ALTE,
    JLFREIB = _a.JLFREIB,
    JLHINZU = _a.JLHINZU,
    INPUTDATA = __rest(_a, ["FVB", "FVBZ", "FVBZSO", "ZRE4", "ZRE4VP", "ZRE4J", "ZVBEZ", "ZVBEZJ", "ALTE", "JLFREIB", "JLHINZU"]);
  var WVFRB; // Für die weitergehende Berücksichtigung des Steuerfreibetrags nach dem DBA Türkei verfügbares ZVE über dem Grundfreibetrag bei der Berechnung des laufenden Arbeitslohns, in Cent
  var JBMG; // Jahressteuer nach § 51a EStG, aus der Solidaritätszuschlag und Bemessungsgrundlage für die Kirchenlohnsteuer ermittelt werden, in Euro
  var GFB = CONFIG.GFB,
    SOLZFREI = CONFIG.SOLZFREI;
  var _b = (0, mztabfb_1.MZTABFB)(__assign(__assign({}, INPUTDATA), {
      ZRE4: ZRE4,
      ZVBEZ: ZVBEZ,
      FVBZ: FVBZ,
      FVBZSO: FVBZSO
    }), CONFIG),
    ANP = _b.ANP,
    KFB = _b.KFB,
    ZTABFB = _b.ZTABFB,
    fvbz = _b.FVBZ,
    KZTAB = _b.KZTAB;
  // Verbrauchter Freibetrag bei Berechnung des laufenden Arbeitslohns, in Cent
  var VFRB = ANP.add(FVB).add(fvbz).mul(100);
  var _c = (0, mlstjahr_1.MLSTJAHR)(__assign(__assign({}, INPUTDATA), {
      ZRE4: ZRE4,
      ZRE4VP: ZRE4VP,
      KZTAB: KZTAB,
      ZTABFB: ZTABFB
    }), CONFIG),
    ST = _c.ST,
    ZVE = _c.ZVE,
    VSP2 = _c.VSP2,
    VSP3 = _c.VSP3;
  // WVFRB = (ZVE - GFB) * 100
  WVFRB = ZVE.minus(GFB).mul(100);
  if (WVFRB.lt(0)) {
    WVFRB = new big_js_1.default(0);
  }
  var F = INPUTDATA.F,
    R = INPUTDATA.R,
    ZKF = INPUTDATA.ZKF,
    LZZ = INPUTDATA.LZZ,
    PKV = INPUTDATA.PKV;
  // Jahreslohnsteuer in Euro
  // LSTJAHR = ST * F;
  var LSTJAHR = ST.mul(F).round(0, big_js_1.default.roundDown);
  var LSTLZZ = (0, uplstlzz_1.UPLSTLZZ)({
    LSTJAHR: LSTJAHR,
    LZZ: LZZ
  }).LSTLZZ;
  var VKVLZZ = (0, upvklzz_1.UPVKLZZ)({
    LZZ: LZZ,
    PKV: PKV,
    VSP2: VSP2,
    VSP3: VSP3
  }).VKVLZZ;
  // ZKV > 0
  if (ZKF.gt(0)) {
    // | Ja
    var ztabfb = ZTABFB.add(KFB);
    // MRE4ABZ
    var _d = (0, mre4abz_1.MRE4ABZ)(__assign({
        ZRE4J: ZRE4J,
        ZVBEZJ: ZVBEZJ,
        FVB: FVB,
        ALTE: ALTE,
        JLFREIB: JLFREIB,
        JLHINZU: JLHINZU
      }, INPUTDATA), CONFIG),
      zre4 = _d.ZRE4,
      zre4vp = _d.ZRE4VP;
    // MLSTJAHR
    var ST_1 = (0, mlstjahr_1.MLSTJAHR)(__assign(__assign({}, INPUTDATA), {
      ZRE4: zre4,
      ZRE4VP: zre4vp,
      ZTABFB: ztabfb,
      KZTAB: KZTAB
    }), CONFIG).ST;
    JBMG = ST_1.mul(F).round(0, big_js_1.default.roundDown);
  } else {
    // | Nein
    JBMG = LSTJAHR;
  }
  // MSOLZ
  var _e = (0, msolz_1.MSOLZ)({
      KZTAB: KZTAB,
      LZZ: LZZ,
      R: R,
      JBMG: JBMG,
      SOLZFREI: SOLZFREI
    }),
    SOLZLZZ = _e.SOLZLZZ,
    BK = _e.BK;
  return {
    BK: BK,
    JBMG: JBMG,
    SOLZLZZ: SOLZLZZ,
    LSTLZZ: LSTLZZ,
    VKVLZZ: VKVLZZ,
    VFRB: VFRB,
    WVFRB: WVFRB,
    KZTAB: KZTAB,
    ZTABFB: ZTABFB
  };
};
exports.MBERECH = MBERECH;

/***/ }),

/***/ 7558:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = this && this.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MLSTJAHR = void 0;
var big_js_1 = __webpack_require__(5395);
var upevp_1 = __webpack_require__(7585);
var upmlst_1 = __webpack_require__(5074);
var MLSTJAHR = function (PARAMS, CONFIG) {
  var VKAPA = PARAMS.VKAPA,
    VMT = PARAMS.VMT,
    ZTABFB = PARAMS.ZTABFB,
    ZRE4 = PARAMS.ZRE4,
    STKL = PARAMS.STKL,
    KZTAB = PARAMS.KZTAB,
    UPEVP_INPUT = __rest(PARAMS, ["VKAPA", "VMT", "ZTABFB", "ZRE4", "STKL", "KZTAB"]);
  var ZVE; // Zu versteuerndes Einkommen in Euro, Cent (2 Dezimalstellen)
  var vmt100 = VMT.div(100);
  var vkapa100 = VKAPA.div(100);
  var ST; // Tarifliche Einkommensteuer in Euro
  var STOVMT = new big_js_1.default(0); // Zwischenfeld zur Ermittlung der Steuer auf Vergütungen für mehrjährige Tätigkeit in Euro
  var KENNVMT = CONFIG.KENNVMT;
  var _a = (0, upevp_1.UPEVP)(__assign({
      STKL: STKL
    }, UPEVP_INPUT), CONFIG),
    VSP = _a.VSP,
    VSP2 = _a.VSP2,
    VSP3 = _a.VSP3;
  // KENNVMT <> 1 ?
  if (KENNVMT !== 1) {
    // | Ja
    // ZVE = ZRE4 - ZTABFB - VSP
    ZVE = ZRE4.minus(ZTABFB).minus(VSP).round(2, big_js_1.default.roundDown);
    // UPMLST
    ST = (0, upmlst_1.UPMLST)({
      ZVE: ZVE,
      STKL: STKL,
      KZTAB: KZTAB
    }, CONFIG);
  } else {
    // | Nein
    // ZVE = ZRE4 - ZTABFB - VSP - VMT / 100 - VKAPA / 100
    ZVE = ZRE4.minus(ZTABFB).minus(VSP).minus(vmt100).minus(vkapa100).round(2, big_js_1.default.roundDown);
    if (ZVE.lt(0)) {
      // ZVE = (ZVE + VMT / 100 + VKAPA / 100) / 5
      ZVE = ZVE.add(vmt100).add(vkapa100).div(5).round(2, big_js_1.default.roundDown);
      var tempST = (0, upmlst_1.UPMLST)({
        STKL: STKL,
        KZTAB: KZTAB,
        ZVE: ZVE
      }, CONFIG);
      ST = tempST.mul(5).round(0, big_js_1.default.roundDown);
    } else {
      // UPMLST
      // |
      // STOVMT = ST
      STOVMT = (0, upmlst_1.UPMLST)({
        STKL: STKL,
        KZTAB: KZTAB,
        ZVE: ZVE
      }, CONFIG);
      // ZVE = ZVE + (VMT + VKAPA) / 500
      ZVE = ZVE.add(VMT.add(VKAPA).div(500)).round(2, big_js_1.default.roundDown);
      // UPMLST
      // |
      // ST = (ST - STOVMT) * 5 + STOVMT
      // (((ST.subtract (STOVMT)).multiply (ZAHL5)).add (STOVMT)).setScale (0, BigDecimal.ROUND_DOWN)
      ST = (0, upmlst_1.UPMLST)({
        ZVE: ZVE,
        STKL: STKL,
        KZTAB: KZTAB
      }, CONFIG).minus(STOVMT).mul(5).add(STOVMT).round(0, big_js_1.default.roundDown);
    }
  }
  return {
    ST: ST,
    VSP2: VSP2,
    VSP3: VSP3,
    ZVE: ZVE
  };
};
exports.MLSTJAHR = MLSTJAHR;

/***/ }),

/***/ 3309:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = this && this.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MOSONST = void 0;
var big_js_1 = __webpack_require__(5395);
var mre4_1 = __webpack_require__(1289);
var mre4abz_1 = __webpack_require__(5391);
var mztabfb_1 = __webpack_require__(1667);
var mlstjahr_1 = __webpack_require__(7558);
var MOSONST = function (_a, CONFIG) {
  var INPUTDATA = __rest(_a, []);
  var JRE4 = INPUTDATA.JRE4,
    JRE4ENT = INPUTDATA.JRE4ENT,
    JVBEZ = INPUTDATA.JVBEZ,
    JFREIB = INPUTDATA.JFREIB,
    JHINZU = INPUTDATA.JHINZU;
  // ZRE4J = JRE4 / 100
  var zre4j = JRE4.div(100);
  // ZVBEZJ = JVBEZ / 100
  var zvbezj = JVBEZ.div(100);
  // JLFREIB = JFREIB / 100
  var jlfreib = JFREIB.div(100);
  // JLHINZU = JHINZU / 100
  var jlhinzu = JHINZU.div(100);
  // MRE4
  var _b = (0, mre4_1.MRE4)(__assign(__assign({}, INPUTDATA), {
      ZRE4J: zre4j,
      ZVBEZJ: zvbezj
    }), CONFIG),
    FVB = _b.FVB,
    FVBZ = _b.FVBZ,
    FVBZSO = _b.FVBZSO,
    ALTE = _b.ALTE;
  // MRE4ABZ
  var _c = (0, mre4abz_1.MRE4ABZ)(__assign(__assign({}, INPUTDATA), {
      ZRE4J: zre4j,
      ZVBEZJ: zvbezj,
      JLFREIB: jlfreib,
      JLHINZU: jlhinzu,
      FVB: FVB,
      ALTE: ALTE
    }), CONFIG),
    ZRE4 = _c.ZRE4,
    ZRE4VP = _c.ZRE4VP,
    ZVBEZ = _c.ZVBEZ;
  // ZRE4VP = ZRE4VP - JRE4ENT / 100
  var zre4vp = ZRE4VP.minus(JRE4ENT.div(100));
  // MZTABFB
  var _d = (0, mztabfb_1.MZTABFB)(__assign(__assign({}, INPUTDATA), {
      ZRE4: ZRE4,
      ZVBEZ: ZVBEZ,
      FVBZ: FVBZ,
      FVBZSO: FVBZSO
    }), CONFIG),
    ANP = _d.ANP,
    fvbzNew = _d.FVBZ,
    KZTAB = _d.KZTAB,
    ZTABFB = _d.ZTABFB,
    KFB = _d.KFB;
  // VFRBS1 = (ANP + FVB + FVBZ) * 100
  var VFRBS1 = ANP.add(FVB).add(fvbzNew).mul(100);
  // MLSTJAHR
  var _e = (0, mlstjahr_1.MLSTJAHR)(__assign(__assign({}, INPUTDATA), {
      ZRE4VP: zre4vp,
      ZTABFB: ZTABFB,
      ZRE4: ZRE4,
      KZTAB: KZTAB
    }), CONFIG),
    ST = _e.ST,
    ZVE = _e.ZVE,
    VSP2 = _e.VSP2,
    VSP3 = _e.VSP3;
  var GFB = CONFIG.GFB;
  // WVFRBO = (ZVE - GFB ) * 100
  var WVFRBO = ZVE.minus(GFB).mul(100);
  // WVFRBO < 0 ?
  if (WVFRBO.lt(0)) {
    // | Ja
    // WVFRBO = 0
    WVFRBO = new big_js_1.default(0);
  }
  // LSTOSO = ST * 100
  var LSTOSO = ST.mul(100);
  return {
    VFRBS1: VFRBS1,
    WVFRBO: WVFRBO,
    LSTOSO: LSTOSO,
    VSP2: VSP2,
    VSP3: VSP3,
    KZTAB: KZTAB,
    ZTABFB: ZTABFB,
    KFB: KFB,
    ZRE4: ZRE4,
    ZRE4VP: zre4vp
  };
};
exports.MOSONST = MOSONST;

/***/ }),

/***/ 7716:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MPARA = void 0;
var config_1 = __webpack_require__(1315);
var MPARA = function (YEAR, P) {
  var CONFIGURATION = (0, config_1.PARAMS)(YEAR, P);
  return __assign({}, CONFIGURATION);
};
exports.MPARA = MPARA;

/***/ }),

/***/ 1289:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MRE4 = void 0;
var big_js_1 = __webpack_require__(5395);
var constants_1 = __webpack_require__(2898);
var mre4alte_1 = __webpack_require__(9752);
var MRE4 = function (PARAMS, CONFIG) {
  var LZZ = PARAMS.LZZ,
    VJAHR = PARAMS.VJAHR,
    ZRE4J = PARAMS.ZRE4J,
    ZVBEZJ = PARAMS.ZVBEZJ,
    ZMVB = PARAMS.ZMVB,
    VBEZS = PARAMS.VBEZS,
    VBEZM = PARAMS.VBEZM;
  var FVB = new big_js_1.default(0); // Versorgungsfreibetrag in Euro, Cent (2 Dezimalstellen)
  var FVBZ = new big_js_1.default(0); // Zuschlag zum Versorgungsfreibetrag in Euro
  var FVBSO = new big_js_1.default(0); // Versorgungsfreibetrag in Euro, Cent (2 Dezimalstellen) für die Berechnung der Lohnsteuer für den sonstigen Bezug
  var FVBZSO = new big_js_1.default(0); // Zuschlag zum Versorgungsfreibetrag in Euro für die Berechnung der Lohnsteuer beim sonstigen Bezug
  var VBEZB = new big_js_1.default(0); // Bemessungsgrundlage für den Versorgungsfreibetrag in Cent
  var HFVB = new big_js_1.default(0); // Maßgeblicher maximaler Versorgungsfreibetrag in Euro
  var HFVBZ = new big_js_1.default(0); // Maßgeblicher maximaler Zuschlag zum Versorgungsfreibetrag in Euro, Cent (2 Dezimalstellen)
  var HFVBZSO = new big_js_1.default(0); // Maßgeblicher maximaler Zuschlag zum Versorgungsfreibetrag in Euro, Cent (2 Dezimalstellen) für die Berechnung der Lohnsteuer für den sonstigen Bezug
  var J = ""; // Nummer der Tabellenwerte für Versorgungsparameter
  var vbezm = VBEZM || new big_js_1.default(0);
  var zmvb = ZMVB || new big_js_1.default(0);
  var vbezs = VBEZS || new big_js_1.default(0);
  var VBEZBSO = CONFIG.VBEZBSO;
  // ZVBEZJ = 0 ?
  if (ZVBEZJ.gt(0)) {
    // ZVBEZJ = 0 | Nein
    if (VJAHR && VJAHR.year < 2006) {
      // VJAHR < 2006
      J = "1";
    } else if (VJAHR && VJAHR.year < 2040) {
      J = VJAHR.minus({
        year: 2004
      }).year.toString();
    } else {
      J = "36";
    }
    if (LZZ === 1) {
      // VBEZB = VBEZM * ZMVB + VBEZS
      VBEZB = vbezm.mul(zmvb).add(vbezs);
      // HFVB = TAB2[J] / 12 * ZMVB
      HFVB = constants_1.TAB2[J].div(12).mul(zmvb);
      // FVBZ = TAB3(J) / 12 * ZMVB
      FVBZ = constants_1.TAB3[J].div(12).mul(zmvb).round(0, big_js_1.default.roundUp);
    } else {
      // VBEZB = VBEZM * 12 + VBEZS
      VBEZB = vbezm.mul(12).add(vbezs);
      HFVB = constants_1.TAB2[J];
      FVBZ = constants_1.TAB3[J];
    }
    // FVB = VBEZB * TAB1(J) / 100
    FVB = VBEZB.mul(constants_1.TAB1[J]).div(100).round(2, big_js_1.default.roundUp);
    // FVB > HFVB
    if (FVB.gt(HFVB)) {
      FVB = HFVB;
    }
    // FVB > ZVBEZJ
    if (FVB.gt(ZVBEZJ)) {
      FVB = ZVBEZJ;
    }
    // FVBSO = FVB + VBEZBSO * TAB1(J) / 100
    FVBSO = FVB.add(VBEZBSO.mul(constants_1.TAB1[J].div(100))).round(2, big_js_1.default.roundUp);
    //FVBSO > TAB2(J)
    if (FVBSO.gt(constants_1.TAB2[J])) {
      FVBSO = constants_1.TAB2[J];
    }
    // HFVBZSO = (VBEZB + VBEZBSO) / 100 - FVBSO
    HFVBZSO = VBEZB.add(VBEZBSO).div(100).minus(FVBSO);
    // FVBZSO = FVBZ + VBEZBSO / 100
    FVBZSO = FVBZ.add(VBEZBSO.div(100)).round(0, big_js_1.default.roundUp);
    //FVBZSO > HFVBZSO
    if (FVBZSO.gt(HFVBZSO)) {
      FVBZSO = HFVBZSO.round(0, big_js_1.default.roundUp);
    }
    // FVBZSO > TAB3(J)
    if (FVBZSO.gt(constants_1.TAB3[J])) {
      FVBZSO = constants_1.TAB3[J];
    }
    //HFVBZ = VBEZB/100 - FVB
    HFVBZ = VBEZB.div(100).minus(FVB);
    // FVBZ > HFVBZ
    if (FVBZ.gt(HFVBZ)) {
      FVBZ = HFVBZ.round(0, big_js_1.default.roundUp);
    }
  }
  var ALTE = (0, mre4alte_1.MRE4ALTE)(__assign(__assign({}, PARAMS), {
    ZRE4J: ZRE4J,
    ZVBEZJ: ZVBEZJ
  }), __assign({}, PARAMS)).ALTE;
  return {
    ALTE: ALTE,
    FVB: FVB,
    FVBSO: FVBSO,
    FVBZ: FVBZ,
    FVBZSO: FVBZSO
  };
};
exports.MRE4 = MRE4;

/***/ }),

/***/ 5391:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MRE4ABZ = void 0;
var big_js_1 = __webpack_require__(5395);
var MRE4ABZ = function (_a, CONFIG) {
  var ZRE4J = _a.ZRE4J,
    ZVBEZJ = _a.ZVBEZJ,
    FVB = _a.FVB,
    ALTE = _a.ALTE,
    JLFREIB = _a.JLFREIB,
    JLHINZU = _a.JLHINZU,
    ENTSCH = _a.ENTSCH;
  var ZRE4; // Auf einen Jahreslohn hochgerechnetes RE4 in Euro, Cent (2 Dezimalstellen) nach Abzug der Freibeträge nach § 39b Absatz 2 Satz 3 und 4 EStG
  var ZRE4VP; // Auf einen Jahreslohn hochgerechnetes RE4, ggf. nach Abzug der Entschädigungen i.S.d. § 24 Nummer 1 EStG in Euro, Cent (2 Dezimalstellen)
  var ZVBEZ; // Auf einen Jahreslohn hochgerechnetes VBEZ abzüglich FVB in Euro, Cent (2 Dezimalstellen)
  var KENNVMT = CONFIG.KENNVMT;
  // ZRE4 = ZRE4J - FVB - ALTE - JLFREIB + JLHINZU
  ZRE4 = ZRE4J.minus(FVB).minus(ALTE).minus(JLFREIB).add(JLHINZU).round(2, big_js_1.default.roundDown);
  // ZRE4 < 0
  if (ZRE4.lt(0)) {
    ZRE4 = new big_js_1.default(0);
  }
  // ZRE4VP = ZRE4J
  ZRE4VP = ZRE4J;
  // KENNVMT = 2 ?
  // JA ->
  // ZRE4VP = ZRE4VP - ENTSCH /100
  if (KENNVMT === 2) {
    ZRE4VP = ZRE4VP.minus(ENTSCH.div(100)).round(2, big_js_1.default.roundDown);
  }
  // ZVBEZ = ZVBEZJ - FVB
  ZVBEZ = ZVBEZJ.minus(FVB);
  // ZVBEZ < 0 ?
  if (ZVBEZ.lt(0)) {
    ZVBEZ = new big_js_1.default(0);
  }
  return {
    ZRE4: ZRE4,
    ZRE4VP: ZRE4VP,
    ZVBEZ: ZVBEZ
  };
};
exports.MRE4ABZ = MRE4ABZ;

/***/ }),

/***/ 9752:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MRE4ALTE = void 0;
var big_js_1 = __webpack_require__(5395);
var constants_1 = __webpack_require__(2898);
var MRE4ALTE = function (_a, INPUTDATA) {
  var ZRE4J = _a.ZRE4J,
    ZVBEZJ = _a.ZVBEZJ;
  var ALTER1 = INPUTDATA.ALTER1,
    AJAHR = INPUTDATA.AJAHR;
  var ALTE = new big_js_1.default(0); // Altersentlastungsbetrag in Euro, Cent (2 Dezimalstellen)
  var HBALTE = new big_js_1.default(0); // Maximaler Altersentlastungsbetrag in Euro
  var K = "36"; // Nummer der Tabellenwerte für Parameter bei Altersentlastungsbetrag
  var BMG = new big_js_1.default(0); // Bemessungsgrundlage für Altersentlastungsbetrag in Euro, Cent (2 Dezimalstellen)
  // ALTER1 = 0 | false
  if (ALTER1) {
    if (AJAHR && AJAHR.year < 2006) {
      K = "1";
    } else if (AJAHR && AJAHR.year < 2040) {
      K = AJAHR.minus({
        year: 2004
      }).year.toString();
    }
    // BMG = ZRE4J - ZVBEZJ
    BMG = ZRE4J.minus(ZVBEZJ);
    // ALTE = BMG * TAB4(K)
    ALTE = BMG.mul(constants_1.TAB4[K]).round(-1, big_js_1.default.roundUp);
    // HBALTE = TAB5(K)
    HBALTE = constants_1.TAB5[K];
    if (ALTE.gt(HBALTE)) {
      ALTE = HBALTE;
    }
  }
  return {
    ALTE: ALTE
  };
};
exports.MRE4ALTE = MRE4ALTE;

/***/ }),

/***/ 4305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MRE4JL = void 0;
var big_js_1 = __webpack_require__(5395);
var MRE4JL = function (_a) {
  var AF = _a.AF,
    F = _a.F,
    LZZ = _a.LZZ,
    RE4 = _a.RE4,
    VBEZ = _a.VBEZ,
    LZZFREIB = _a.LZZFREIB,
    LZZHINZU = _a.LZZHINZU;
  var jahr = function (input) {
    return input.div(100);
  };
  var monat = function (input) {
    return input.mul(12).div(100);
  };
  var woche = function (input) {
    return input.mul(360).div(7).div(100);
  };
  var tag = function (input) {
    return input.mul(360).div(100);
  };
  var ZRE4J = new big_js_1.default(0); // Auf einen Jahreslohn hochgerechnetes RE4 in Euro, Cent (2 Dezimalstellen)
  var ZVBEZJ = new big_js_1.default(0); // Auf einen Jahreslohn hochgerechnetes VBEZ in Euro, Cent (2 Dezimalstellen)
  var JLFREIB = new big_js_1.default(0); // Auf einen Jahreslohn hochgerechneter LZZFREIB in Euro, Cent (2 Dezimalstellen)
  var JLHINZU = new big_js_1.default(0); // Auf einen Jahreslohn hochgerechneter LZZHINZU in Euro, Cent (2 Dezimalstellen)
  var f = F;
  var re4 = RE4 || new big_js_1.default(0);
  var vbez = VBEZ || new big_js_1.default(0);
  var lzzfreib = LZZFREIB || new big_js_1.default(0);
  var lzzhinzu = LZZHINZU || new big_js_1.default(0);
  if (LZZ === 1) {
    // JAHR
    ZRE4J = jahr(re4);
    ZVBEZJ = jahr(vbez);
    JLFREIB = jahr(lzzfreib);
    JLHINZU = jahr(lzzhinzu);
  }
  if (LZZ === 2) {
    // MONAT
    ZRE4J = monat(re4);
    ZVBEZJ = monat(vbez);
    JLFREIB = monat(lzzfreib);
    JLHINZU = monat(lzzhinzu);
  }
  if (LZZ === 3) {
    // WOCHE
    ZRE4J = woche(re4);
    ZVBEZJ = woche(vbez);
    JLFREIB = woche(lzzfreib);
    JLHINZU = woche(lzzhinzu);
  }
  if (LZZ === 4) {
    // TAG
    ZRE4J = tag(re4);
    ZVBEZJ = tag(vbez);
    JLFREIB = tag(lzzfreib);
    JLHINZU = tag(lzzhinzu);
  }
  // AF = 0 ? => AF === false => AF !== true =>
  if (!AF) {
    f = new big_js_1.default(1);
  }
  return {
    ZRE4J: ZRE4J,
    ZVBEZJ: ZVBEZJ,
    JLFREIB: JLFREIB,
    JLHINZU: JLHINZU,
    F: f
  };
};
exports.MRE4JL = MRE4JL;

/***/ }),

/***/ 9502:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MRE4SONST = void 0;
var mre4_1 = __webpack_require__(1289);
var mre4abz_1 = __webpack_require__(5391);
var mztabfb_1 = __webpack_require__(1667);
var MRE4SONST = function (PARAMS, CONFIG) {
  var STKL = PARAMS.STKL,
    ZKF = PARAMS.ZKF,
    ZRE4J = PARAMS.ZRE4J,
    ZVBEZJ = PARAMS.ZVBEZJ,
    JLFREIB = PARAMS.JLFREIB,
    JLHINZU = PARAMS.JLHINZU,
    JRE4ENT = PARAMS.JRE4ENT,
    MBV = PARAMS.MBV,
    SONSTENT = PARAMS.SONSTENT,
    VFRBS1 = PARAMS.VFRBS1;
  var mbv100 = MBV.div(100);
  var jre4ent100 = JRE4ENT.div(100);
  var sonstent100 = SONSTENT.div(100);
  // MRE4
  var _a = (0, mre4_1.MRE4)(PARAMS, CONFIG),
    FVBSO = _a.FVBSO,
    ALTE = _a.ALTE,
    FVBZSO = _a.FVBZSO;
  // FVB = FVBSO
  var fvb = FVBSO;
  // MRE4ABZ
  var _b = (0, mre4abz_1.MRE4ABZ)(__assign(__assign({}, PARAMS), {
      FVB: fvb,
      ZRE4J: ZRE4J,
      ZVBEZJ: ZVBEZJ,
      ALTE: ALTE,
      JLFREIB: JLFREIB,
      JLHINZU: JLHINZU
    }), CONFIG),
    ZRE4 = _b.ZRE4,
    ZVBEZ = _b.ZVBEZ,
    ZRE4VP = _b.ZRE4VP;
  // ZRE4VP = ZRE4VP + MBV / 100 - JRE4ENT / 100 - SONSTENT / 100
  var zre4vp = ZRE4VP.add(mbv100).minus(jre4ent100).minus(sonstent100);
  // FVBZ = FVBZSO
  var fvbz = FVBZSO;
  // MZTABFB
  var ANP = (0, mztabfb_1.MZTABFB)({
    ZRE4: ZRE4,
    ZVBEZ: ZVBEZ,
    FVBZ: fvbz,
    FVBZSO: FVBZSO,
    ZKF: ZKF,
    STKL: STKL
  }, CONFIG).ANP;
  // VFRBS2 = (ANP + FVB +FVBZ) * 100 - VFRBS1
  var VFRBS2 = ANP.add(fvb).add(fvbz).mul(100).minus(VFRBS1);
  return {
    VFRBS2: VFRBS2,
    FVB: fvb,
    FVBZ: fvbz,
    ZRE4VP: zre4vp
  };
};
exports.MRE4SONST = MRE4SONST;

/***/ }),

/***/ 3991:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MSOLZ = void 0;
var big_js_1 = __webpack_require__(5395);
var upanteil_1 = __webpack_require__(1179);
var MSOLZ = function (_a) {
  var KZTAB = _a.KZTAB,
    LZZ = _a.LZZ,
    R = _a.R,
    JBMG = _a.JBMG,
    SOLZFREI = _a.SOLZFREI;
  var solzfrei = SOLZFREI.mul(KZTAB);
  var JW;
  var SOLZLZZ;
  var BK;
  if (JBMG.gt(solzfrei)) {
    // SOLZJ = JBMG * 5,5 / 100
    var SOLZJ = JBMG.mul(5.5).div(100);
    var SOLZMIN = JBMG.add(solzfrei).mul(11.9).div(100);
    if (SOLZMIN.lt(SOLZJ)) {
      SOLZJ = SOLZMIN;
    }
    JW = SOLZJ.mul(100);
    var ANTEIL1 = (0, upanteil_1.UPANTEIL)({
      JW: JW,
      LZZ: LZZ
    }).ANTEIL1;
    SOLZLZZ = ANTEIL1;
  } else {
    SOLZLZZ = new big_js_1.default(0);
  }
  if (R > 0) {
    JW = JBMG.mul(100);
    var ANTEIL1 = (0, upanteil_1.UPANTEIL)({
      JW: JW,
      LZZ: LZZ
    }).ANTEIL1;
    BK = ANTEIL1;
  } else {
    BK = new big_js_1.default(0);
  }
  return {
    SOLZLZZ: SOLZLZZ,
    BK: BK
  };
};
exports.MSOLZ = MSOLZ;

/***/ }),

/***/ 8527:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MSOLZSTS = void 0;
var big_js_1 = __webpack_require__(5395);
var uptab_1 = __webpack_require__(2129);
var mst56_1 = __webpack_require__(8906);
var MSOLZSTS = function (_a, CONFIG) {
  var F = _a.F,
    STS = _a.STS,
    ZKF = _a.ZKF,
    STKL = _a.STKL,
    ZVE = _a.ZVE,
    KFB = _a.KFB,
    KZTAB = _a.KZTAB;
  var SOLZS;
  var SOLZSZVE; // Zu versteuerndes Einkommen für die Ermittlung der Bemessungsgrundlage des Solidaritätszuschlags zur Prüfung der Freigrenze beim Solidaritätszuschlag für sonstige Bezüge (ohne Vergütung für mehrjährige Tätigkeit) in Euro, Cent (2 Dezimalstellen)
  var X;
  var ST;
  var SOLZFREI = CONFIG.SOLZFREI;
  // ZKF > 0
  if (ZKF.gt(0)) {
    // | Ja
    // | SOLZSZVE = ZVE - KFB
    SOLZSZVE = ZVE.minus(KFB);
  } else {
    // | Nein
    // | SOLZSZVE = ZVE
    SOLZSZVE = ZVE;
  }
  // SOLZSZVE < 1
  if (SOLZSZVE.lt(1)) {
    // | Ja
    // | SOLZSZVE = 0
    // | X = 0
    SOLZSZVE = new big_js_1.default(0);
    X = new big_js_1.default(0);
  } else {
    // | Nein
    // | X = SOLZSZVE / KZTAB (-1, roundDown)
    X = SOLZSZVE.div(KZTAB).round(-1, big_js_1.default.roundDown);
  }
  // STKL < 5
  if (STKL < 5) {
    // | Ja
    // | | UPTAB22/UPTAB23
    ST = (0, uptab_1.UPTAB)({
      X: X,
      KZTAB: KZTAB
    }, CONFIG);
  } else {
    // | Nein
    // | | MST5_6
    ST = (0, mst56_1.MST56)({
      X: X,
      KZTAB: KZTAB
    }, CONFIG);
  }
  // SOLZSBMG = ST * F (-1, roundDown)
  // Bemessungsgrundlage des Solidaritätszuschlags zur Prüfung der Freigrenze beim Solidaritätszuschlag für sonstige Bezüge (ohne Vergütung für mehrjährige Tätigkeit) in Euro
  var SOLZSBMG = ST.mul(F).round(-1, big_js_1.default.roundDown);
  // SOLZSBMG > SOLZFREI
  if (SOLZSBMG.gt(SOLZFREI)) {
    // | Ja
    // | | SOLZS = STS * 5.5 / 100 (2, roundDown)
    SOLZS = STS.mul("5.5").div(100).round(2, big_js_1.default.roundDown);
  } else {
    // | Nein
    // | | SOLZS = 0
    SOLZS = new big_js_1.default(0);
  }
  return {
    SOLZS: SOLZS,
    SOLZSBMG: SOLZSBMG,
    SOLZSZVE: SOLZSZVE
  };
};
exports.MSOLZSTS = MSOLZSTS;

/***/ }),

/***/ 5052:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = this && this.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MSONST = void 0;
var big_js_1 = __webpack_require__(5395);
var mosonst_1 = __webpack_require__(3309);
var upvkv_1 = __webpack_require__(8593);
var mre4sonst_1 = __webpack_require__(9502);
var mlstjahr_1 = __webpack_require__(7558);
var stsmin_1 = __webpack_require__(986);
var MSONST = function (_a, CONFIG) {
  var MOSONSTCONFIG = __rest(_a, []);
  var BK = MOSONSTCONFIG.BK,
    F = MOSONSTCONFIG.F,
    ZMVB = MOSONSTCONFIG.ZMVB,
    MBV = MOSONSTCONFIG.MBV,
    SONSTB = MOSONSTCONFIG.SONSTB,
    JRE4 = MOSONSTCONFIG.JRE4,
    PKV = MOSONSTCONFIG.PKV,
    VBS = MOSONSTCONFIG.VBS,
    JVBEZ = MOSONSTCONFIG.JVBEZ,
    STERBE = MOSONSTCONFIG.STERBE;
  var lzz = 1;
  var VKVSONST;
  var LSTSO;
  var STS;
  var SOLZS;
  var BKS;
  var WVFRBO = new big_js_1.default(0);
  var WVFRBM = new big_js_1.default(0);
  var VFRBS1 = new big_js_1.default(0);
  var VFRBS2 = new big_js_1.default(0);
  var bkNeu = BK;
  var GFB = CONFIG.GFB;
  // ZMVB = 0 ?
  // |
  // ZMVB = 12
  var zmvb = ZMVB === 0 ? 12 : ZMVB;
  if (SONSTB.eq(0) && MBV.eq(0)) {
    VKVSONST = new big_js_1.default(0);
    LSTSO = new big_js_1.default(0);
    STS = new big_js_1.default(0);
    SOLZS = new big_js_1.default(0);
    BKS = new big_js_1.default(0);
  } else {
    // MOSONST
    var _b = (0, mosonst_1.MOSONST)(__assign(__assign({}, MOSONSTCONFIG), {
        LZZ: lzz,
        ZMVB: zmvb
      }), CONFIG),
      vfrbs1 = _b.VFRBS1,
      wvfrbo = _b.WVFRBO,
      LSTOSO = _b.LSTOSO,
      vsp2mosonst = _b.VSP2,
      vsp3mosonst = _b.VSP3,
      KZTAB = _b.KZTAB,
      ZTABFB = _b.ZTABFB,
      ZRE4 = _b.ZRE4,
      KFB = _b.KFB;
    VFRBS1 = vfrbs1;
    WVFRBO = wvfrbo;
    // UPVKV
    var vkv1 = (0, upvkv_1.UPVKV)({
      PKV: PKV,
      VSP2: vsp2mosonst,
      VSP3: vsp3mosonst
    }).VKV;
    // VKVSONST = VKV
    VKVSONST = vkv1;
    // ZRE4J = (JRE4 + SONSTB) / 100
    var zre4j = JRE4.add(SONSTB).div(100);
    // ZVBEZJ = (JVBEZ + VBS) / 100
    var zvbezj = JVBEZ.add(VBS).div(100);
    // VBEZBSO = STERBE
    // |
    // MRE4SONST
    var _c = (0, mre4sonst_1.MRE4SONST)(__assign(__assign({}, MOSONSTCONFIG), {
        LZZ: lzz,
        VFRBS1: vfrbs1,
        ZRE4J: zre4j,
        ZVBEZJ: zvbezj,
        ZMVB: zmvb
      }), __assign(__assign({}, CONFIG), {
        VBEZBSO: STERBE
      })),
      vfrbs2 = _c.VFRBS2,
      ZRE4VP = _c.ZRE4VP;
    VFRBS2 = vfrbs2;
    // MLSTJAHR
    var _d = (0, mlstjahr_1.MLSTJAHR)(__assign(__assign({}, MOSONSTCONFIG), {
        ZTABFB: ZTABFB,
        ZRE4: ZRE4,
        ZRE4VP: ZRE4VP,
        KZTAB: KZTAB
      }), __assign(__assign({}, CONFIG), {
        VBEZBSO: STERBE
      })),
      ST = _d.ST,
      ZVE = _d.ZVE,
      vsp2mlstjahr = _d.VSP2,
      vsp3mlstjahr = _d.VSP3;
    // WVFRBM = (ZVE - GFB) * 100
    var WVFRBM_1 = ZVE.minus(GFB).mul(100);
    // WVFRBM < 0 ?
    if (WVFRBM_1.lt(0)) {
      // | ja
      // WVFRBM = 0
      WVFRBM_1 = new big_js_1.default(0);
    }
    // UPVKV
    var vkv2 = (0, upvkv_1.UPVKV)({
      PKV: PKV,
      VSP2: vsp2mlstjahr,
      VSP3: vsp3mlstjahr
    }).VKV;
    // VKVSONST = VKV - VKVSONST
    VKVSONST = vkv2.minus(VKVSONST);
    // LSTSO = ST * 100
    LSTSO = ST.mul(100);
    // STS = (LSTSO - LSTOSO) * F
    STS = LSTSO.minus(LSTOSO).mul(F);
    // STSMIN
    var _e = (0, stsmin_1.STSMIN)(__assign(__assign({}, MOSONSTCONFIG), {
        KZTAB: KZTAB,
        STS: STS,
        ZVE: ZVE,
        KFB: KFB
      }), CONFIG),
      bk = _e.BK,
      bks = _e.BKS,
      solzs = _e.SOLZS;
    bkNeu = bk;
    BKS = bks;
    SOLZS = solzs;
  }
  return {
    VKVSONST: VKVSONST,
    VFRBS1: VFRBS1,
    VFRBS2: VFRBS2,
    STS: STS,
    BKS: BKS,
    BK: bkNeu,
    SOLZS: SOLZS,
    LSTSO: LSTSO,
    WVFRBM: WVFRBM,
    WVFRBO: WVFRBO
  };
};
exports.MSONST = MSONST;

/***/ }),

/***/ 8906:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = this && this.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MST56 = void 0;
var big_js_1 = __webpack_require__(5395);
var up56_1 = __webpack_require__(8227);
var MST56 = function (_a, CONFIG) {
  var X = _a.X,
    rest = __rest(_a, ["X"]);
  var ZX; // Zwischenfeld zu X für die Berechnung der Steuer nach § 39b Absatz 2 Satz 7 EStG in Euro
  var VERGL; // Zwischenfeld zu X für die Berechnung der Steuer nach § 39b Absatz 2 Satz 7 EStG in Euro
  var st = new big_js_1.default(0);
  var ZZX = X; // Zwischenfeld zu X für die Berechnung der Steuer nach § 39b Absatz 2 Satz 7 EStG in Euro
  var W1STKL5 = CONFIG.W1STKL5,
    W2STKL5 = CONFIG.W2STKL5,
    W3STKL5 = CONFIG.W3STKL5;
  if (ZZX.gt(W2STKL5)) {
    ZX = W2STKL5;
    var stup56 = (0, up56_1.UP56)(__assign({
      X: X,
      ZX: ZX
    }, rest), CONFIG);
    if (ZZX.gt(W3STKL5)) {
      // ST = ST + (W3STKL5 - W2STKL5) * 0,42
      st = stup56.add(W3STKL5.minus(W2STKL5).mul(0.42)).round(0, big_js_1.default.roundDown);
      // ST = ST + (ZZX - W3STKL5) * 0,45
      st = st.add(ZZX.minus(W3STKL5).mul(0.45)).round(0, big_js_1.default.roundDown);
    } else {
      // ST = ST + (ZZX - W2STKL5) * 0,42
      st = stup56.add(ZZX.minus(W2STKL5).mul(0.42)).round(0, big_js_1.default.roundDown);
    }
  } else {
    ZX = ZZX;
    st = (0, up56_1.UP56)(__assign({
      X: X,
      ZX: ZX
    }, rest), CONFIG);
    if (ZZX.gt(W1STKL5)) {
      VERGL = st;
      ZX = W1STKL5;
      var stvergl = (0, up56_1.UP56)(__assign({
        X: X,
        ZX: ZX
      }, rest), CONFIG);
      // HOCH = ST  + ( ZZX - W1STKL5) * 0,42
      var HOCH = stvergl.add(ZZX.minus(W1STKL5).mul(0.42)).round(0, big_js_1.default.roundDown);
      st = HOCH.lt(VERGL) ? HOCH : VERGL;
    }
  }
  return st;
};
exports.MST56 = MST56;

/***/ }),

/***/ 4998:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = this && this.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MVMT = void 0;
var big_js_1 = __webpack_require__(5395);
var mosonst_1 = __webpack_require__(3309);
var constants_1 = __webpack_require__(2898);
var mre4sonst_1 = __webpack_require__(9502);
var mlstjahr_1 = __webpack_require__(7558);
var mre4abz_1 = __webpack_require__(5391);
var MVMT = function (_a, CONFIG) {
  var MOSONSTCONFIG = __rest(_a, []);
  var R = MOSONSTCONFIG.R,
    F = MOSONSTCONFIG.F,
    VFRBS1 = MOSONSTCONFIG.VFRBS1,
    JRE4 = MOSONSTCONFIG.JRE4,
    JRE4ENT = MOSONSTCONFIG.JRE4ENT,
    JVBEZ = MOSONSTCONFIG.JVBEZ,
    ZRE4 = MOSONSTCONFIG.ZRE4,
    ZTABFB = MOSONSTCONFIG.ZTABFB,
    VKAPA = MOSONSTCONFIG.VKAPA,
    VMT = MOSONSTCONFIG.VMT,
    VBS = MOSONSTCONFIG.VBS,
    LSTSO = MOSONSTCONFIG.LSTSO,
    STERBE = MOSONSTCONFIG.STERBE,
    SONSTB = MOSONSTCONFIG.SONSTB,
    SONSTENT = MOSONSTCONFIG.SONSTENT,
    JBMG = MOSONSTCONFIG.JBMG,
    KZTAB = MOSONSTCONFIG.KZTAB;
  var SOLZVBMG; // Bemessungsgrundlage des Solidaritätszuschlags für die Prüfung der Freigrenze beim Solidaritätszuschlag für die Vergütung für mehrjährige Tätigkeit in Euro
  var STV;
  var SOLZV;
  var BKV;
  var vbezbso;
  var zre4j;
  var zre4vp;
  var zvbezj;
  var kennvmt;
  var vfrbs1 = VFRBS1;
  var kztab = KZTAB;
  var zre4 = ZRE4;
  var ztabfb = ZTABFB;
  var LST1 = new big_js_1.default(0); // Zwischenfelder der Jahreslohnsteuer in Cent
  var LST2 = new big_js_1.default(0); // Zwischenfelder der Jahreslohnsteuer in Cent
  var LST3 = new big_js_1.default(0); // Zwischenfelder der Jahreslohnsteuer in Cent
  var vkapa = VKAPA;
  var SOLZFREI = CONFIG.SOLZFREI;
  // VKAPA < 0 ?
  if (VKAPA.lt(0)) {
    // | Ja
    // | VKAPA = 0
    vkapa = new big_js_1.default(0);
  }
  // VMT + VKAPA > 0 ?
  if (VMT.add(vkapa).gt(0)) {
    // | Ja
    // | | LSTSO = 0 ?
    if (LSTSO.eq(0)) {
      // | | | Ja
      // | | | | MOSONST
      var _b = (0, mosonst_1.MOSONST)(__assign(__assign({}, MOSONSTCONFIG), {
          VKAPA: vkapa
        }), CONFIG),
        LSTOSO = _b.LSTOSO,
        VFRBS1_1 = _b.VFRBS1,
        ZTABFB_1 = _b.ZTABFB,
        KZTAB_1 = _b.KZTAB,
        ZRE4_1 = _b.ZRE4;
      vfrbs1 = VFRBS1_1;
      kztab = KZTAB_1;
      zre4 = ZRE4_1;
      ztabfb = ZTABFB_1;
      // | | | | LST1 = LSTOSO
      LST1 = LSTOSO;
    } else {
      // | | | Nein
      // | | | | LST1 = LSTSO
      LST1 = LSTSO;
    }
    // | | VBEZBSO = STERBE + VKAPA
    vbezbso = STERBE.add(VKAPA);
    // | | ZRE4J = (JRE4 + SONSTB + VMT + VKAPA) / 100
    zre4j = JRE4.add(SONSTB).add(VMT).add(VKAPA).div(100);
    // | | ZVBEZJ = (JVBEZ + VBS + VKAPA) / 100
    zvbezj = JVBEZ.add(VBS).add(VKAPA).div(100);
    // | | KENNVMT = 2
    kennvmt = constants_1.KENNVMT.VORPAU;
    // | | MRE4SONST
    var _c = (0, mre4sonst_1.MRE4SONST)(__assign(__assign({}, MOSONSTCONFIG), {
        VFRBS1: vfrbs1,
        ZRE4J: zre4j,
        ZVBEZJ: zvbezj,
        VKAPA: vkapa
      }), __assign(__assign({}, CONFIG), {
        VBEZBSO: vbezbso,
        KENNVMT: kennvmt
      })),
      zrevp1 = _c.ZRE4VP,
      FVB = _c.FVB;
    // | | MLSTJAHR
    var st1 = (0, mlstjahr_1.MLSTJAHR)(__assign(__assign({}, MOSONSTCONFIG), {
      KZTAB: kztab,
      VKAPA: vkapa,
      ZRE4VP: zrevp1,
      ZRE4: zre4,
      ZTABFB: ztabfb
    }), CONFIG).ST;
    // | | LST3 = ST * 100
    LST3 = st1.mul(100);
    // | | MRE4ABZ
    var zre4vp2 = (0, mre4abz_1.MRE4ABZ)(__assign(__assign({}, MOSONSTCONFIG), {
      ZRE4J: zre4j,
      ZVBEZJ: zvbezj,
      FVB: FVB
    }), __assign(__assign({}, CONFIG), {
      VBEZBSO: vbezbso,
      KENNVMT: kennvmt
    })).ZRE4VP;
    // | | ZRE4VP = ZRE4VP - JRE4ENT / 100 - SONSTENT / 100
    zre4vp = zre4vp2.minus(JRE4ENT.div(100)).minus(SONSTENT.div(100));
    // | | KENNVMT = 1
    kennvmt = constants_1.KENNVMT.MJTAT;
    // | | MLSTJAHR
    var st2 = (0, mlstjahr_1.MLSTJAHR)(__assign(__assign({}, MOSONSTCONFIG), {
      KZTAB: kztab,
      ZRE4VP: zre4vp,
      ZRE4: zre4,
      ZTABFB: ztabfb,
      VKAPA: VKAPA,
      VMT: VMT
    }), __assign(__assign({}, CONFIG), {
      VBEZBSO: vbezbso,
      KENNVMT: kennvmt
    })).ST;
    // | | LST2 = ST * 100
    LST2 = st2.mul(100);
    // | | STV = LST2 - LST1
    STV = LST2.minus(LST1);
    // | | LST3 = LST3 - LST1
    LST3 = LST3.minus(LST1);
    // | | LST3 < STV ?
    if (LST3.lt(STV)) {
      // | | | Ja
      // | | | STV = LST3
      STV = LST3;
    }
    // | | STV < 0 ?
    if (STV.lt(0)) {
      // | | | Ja
      // | | | | STV = 0
      STV = new big_js_1.default(0);
    } else {
      // | | | Nein
      // | | | | STV = STV * F (-1, roundDown)
      STV = STV.mul(F).round(-1, big_js_1.default.roundDown);
    }
    // | | SOLZVBMG = STV / 100 + JBMG
    SOLZVBMG = STV.div(100).add(JBMG);
    // | | SOLZVBMG > SOLZFREI ?
    if (SOLZVBMG.gt(SOLZFREI)) {
      // | | | Ja
      // | | | | SOLZV = STV * 5,5 / 100 (2, roundDown)
      SOLZV = STV.mul("5,5").div(100).round(2, big_js_1.default.roundDown);
    } else {
      // | | | Nein
      // | | | | SOLZV = 0
      SOLZV = new big_js_1.default(0);
    }
    // | | R > 0
    if (R > 0) {
      // | | | Ja
      // | | | | BKV = STV
      BKV = STV;
    } else {
      // | | | Nein
      // | | | | BKV = 0
      BKV = new big_js_1.default(0);
    }
  } else {
    // | Nein
    // | | STV = 0
    STV = new big_js_1.default(0);
    // | | SOLZV = 0
    SOLZV = new big_js_1.default(0);
    // | | BKV = 0
    BKV = new big_js_1.default(0);
  }
  return {
    STV: STV,
    BKV: BKV,
    SOLZV: SOLZV
  };
};
exports.MVMT = MVMT;

/***/ }),

/***/ 6582:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MVSP = void 0;
var big_js_1 = __webpack_require__(5395);
var MVSP = function (_a, CONFIG) {
  var VSP1 = _a.VSP1,
    PKV = _a.PKV,
    STKL = _a.STKL,
    PKPV = _a.PKPV,
    ZRE4VP = _a.ZRE4VP;
  var zre4vp = ZRE4VP;
  var VSP3; // Vorsorgepauschale mit Teilbeträgen für die gesetzliche Kranken- und soziale Pflegeversicherung nach fiktiven Beträgen oder ggf. für die private Basiskrankenversicherung und private Pflege-Pflichtversicherung in Euro, Cent (2 Dezimalstellen)
  var VSP; // Vorsorgepauschale mit Teilbeträgen für die Rentenversicherung sowie die gesetzliche Kranken- und soziale Pflegeversicherung nach fiktiven Beträgen oder ggf. für die private Basiskrankenversicherung und private Pflege-Pflichtversicherung in Euro, Cent (2 Dezimalstellen)
  var BBGKVPV = CONFIG.BBGKVPV,
    KVSATZAG = CONFIG.KVSATZAG,
    PVSATZAG = CONFIG.PVSATZAG,
    KVSATZAN = CONFIG.KVSATZAN,
    PVSATZAN = CONFIG.PVSATZAN;
  if (ZRE4VP.gt(BBGKVPV)) {
    zre4vp = BBGKVPV;
  }
  // PKV > 0
  if (PKV > 0) {
    if (STKL === 6) {
      VSP3 = new big_js_1.default(0);
    } else {
      VSP3 = PKPV.mul(12).div(100);
      if (PKV === 2) {
        VSP3 = VSP3.minus(zre4vp.mul(KVSATZAG.add(PVSATZAG)));
      }
    }
  } else {
    VSP3 = zre4vp.mul(KVSATZAN.add(PVSATZAN));
  }
  VSP = VSP3.add(VSP1).round(0, big_js_1.default.roundUp);
  return {
    VSP: VSP,
    VSP3: VSP3
  };
};
exports.MVSP = MVSP;

/***/ }),

/***/ 1667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MZTABFB23 = exports.MZTABFB22 = exports.MZTABFB = void 0;
var big_js_1 = __webpack_require__(5395);
var constants_1 = __webpack_require__(2898);
var MZTABFB = function (P, CONFIG) {
  var BJAHR = CONFIG.BJAHR,
    PATCH = CONFIG.PATCH;
  if (BJAHR === 2023) {
    return (0, exports.MZTABFB23)(P);
  }
  return (0, exports.MZTABFB22)(P, PATCH);
};
exports.MZTABFB = MZTABFB;
var MZTABFB22 = function (_a, patch) {
  var ZRE4 = _a.ZRE4,
    ZVBEZ = _a.ZVBEZ,
    FVBZ = _a.FVBZ,
    FVBZSO = _a.FVBZSO,
    STKL = _a.STKL,
    ZKF = _a.ZKF;
  var ANP = new big_js_1.default(0); // Arbeitnehmer-Pauschbetrag/Werbungskosten-Pauschbetrag in Euro
  var fvbz = FVBZ;
  var fvbzso = FVBZSO;
  var kztab = constants_1.KZTAB.GRUND;
  var KFB = new big_js_1.default(0); // Summe der Freibeträge für Kinder in Euro
  var EFA = new big_js_1.default(0); // Entlastungsbetrag für Alleinerziehende in Euro
  var SAP; // Sonderausgaben-Pauschbetrag in Euro
  // const ZTABFB:Big;   // Feste Tabellenfreibeträge (ohne Vorsorgepauschale) in Euro, Cent (2 Dezimalstellen)
  // ZVBEZ >= 0
  // | JA
  // ZVBEZ < FVBZ
  // | JA
  if (ZVBEZ.gte(0) && ZVBEZ.lt(FVBZ)) {
    fvbz = ZVBEZ;
  }
  // STKL < 6
  if (STKL < 6) {
    // | Ja
    // ZVBEZ > 0
    if (ZVBEZ.gt(0)) {
      // ZVBEZ - FVBZ < 102
      if (ZVBEZ.minus(fvbz).lt(102)) {
        ANP = ZVBEZ.minus(fvbz).round(0, big_js_1.default.roundUp);
      } else {
        ANP = new big_js_1.default(102);
      }
    }
  } else {
    fvbz = new big_js_1.default(0);
    fvbzso = new big_js_1.default(0);
  }
  // STKL < 6
  if (STKL < 6) {
    // | Ja
    // ZRE4 > ZVBEZ
    if (ZRE4.gt(ZVBEZ)) {
      //                                        2022 : 2022.2
      if (ZRE4.minus(ZVBEZ).lt(patch === "1" ? 1000 : 1200)) {
        ANP = ANP.add(ZRE4).minus(ZVBEZ).round(0, big_js_1.default.roundUp);
      } else {
        ANP = ANP.add(1200);
      }
    }
  }
  switch (STKL) {
    case 1:
      SAP = new big_js_1.default(36);
      KFB = ZKF.mul(8388).round(0, big_js_1.default.roundDown);
      break;
    case 2:
      EFA = new big_js_1.default(4008);
      SAP = new big_js_1.default(36);
      KFB = ZKF.mul(8388).round(0, big_js_1.default.roundDown);
      break;
    case 3:
      kztab = constants_1.KZTAB.SPLIT;
      SAP = new big_js_1.default(36);
      KFB = ZKF.mul(8388).round(0, big_js_1.default.roundDown);
      break;
    case 4:
      SAP = new big_js_1.default(36);
      KFB = ZKF.mul(4194).round(0, big_js_1.default.roundDown);
      break;
    case 5:
      SAP = new big_js_1.default(36);
      KFB = new big_js_1.default(0);
      break;
    default:
      SAP = new big_js_1.default(0);
      break;
  }
  var ZTABFB = EFA.add(ANP).add(SAP).add(fvbz);
  return {
    ANP: ANP,
    KFB: KFB,
    FVBZ: fvbz,
    FVBZSO: fvbzso,
    KZTAB: kztab,
    ZTABFB: ZTABFB
  };
};
exports.MZTABFB22 = MZTABFB22;
var MZTABFB23 = function (_a) {
  var ZRE4 = _a.ZRE4,
    ZVBEZ = _a.ZVBEZ,
    FVBZ = _a.FVBZ,
    FVBZSO = _a.FVBZSO,
    STKL = _a.STKL,
    ZKF = _a.ZKF;
  var ANP = new big_js_1.default(0); // Arbeitnehmer-Pauschbetrag/Werbungskosten-Pauschbetrag in Euro
  var fvbz = FVBZ;
  var fvbzso = FVBZSO;
  var kztab = constants_1.KZTAB.GRUND;
  var KFB = new big_js_1.default(0); // Summe der Freibeträge für Kinder in Euro
  var EFA = new big_js_1.default(0); // Entlastungsbetrag für Alleinerziehende in Euro
  var SAP; // Sonderausgaben-Pauschbetrag in Euro
  // ZVBEZ >= 0
  // | JA
  // ZVBEZ < FVBZ
  // | JA
  if (ZVBEZ.gte(0) && ZVBEZ.lt(FVBZ)) {
    fvbz = ZVBEZ;
  }
  // STKL < 6
  if (STKL < 6) {
    // | Ja
    // ZVBEZ > 0
    if (ZVBEZ.gt(0)) {
      // ZVBEZ - FVBZ < 102
      if (ZVBEZ.minus(fvbz).lt(102)) {
        ANP = ZVBEZ.minus(fvbz).round(0, big_js_1.default.roundUp);
      } else {
        ANP = new big_js_1.default(102);
      }
    }
  } else {
    fvbz = new big_js_1.default(0);
    fvbzso = new big_js_1.default(0);
  }
  // STKL < 6
  if (STKL < 6) {
    // | Ja
    // ZRE4 > ZVBEZ
    if (ZRE4.gt(ZVBEZ)) {
      if (ZRE4.minus(ZVBEZ).lt(1230)) {
        ANP = ANP.add(ZRE4).minus(ZVBEZ).round(0, big_js_1.default.roundUp);
      } else {
        ANP = ANP.add(1230);
      }
    }
  }
  switch (STKL) {
    case 1:
      SAP = new big_js_1.default(36);
      KFB = ZKF.mul(8952).round(0, big_js_1.default.roundDown);
      break;
    case 2:
      EFA = new big_js_1.default(4260);
      SAP = new big_js_1.default(36);
      KFB = ZKF.mul(8952).round(0, big_js_1.default.roundDown);
      break;
    case 3:
      kztab = constants_1.KZTAB.SPLIT;
      SAP = new big_js_1.default(36);
      KFB = ZKF.mul(8952).round(0, big_js_1.default.roundDown);
      break;
    case 4:
      SAP = new big_js_1.default(36);
      KFB = ZKF.mul(4476).round(0, big_js_1.default.roundDown);
      break;
    case 5:
      SAP = new big_js_1.default(36);
      KFB = new big_js_1.default(0);
      break;
    default:
      SAP = new big_js_1.default(0);
      break;
  }
  // Feste Tabellenfreibeträge (ohne Vorsorgepauschale) in Euro, Cent (2 Dezimalstellen)
  var ZTABFB = EFA.add(ANP).add(SAP).add(fvbz);
  return {
    ANP: ANP,
    KFB: KFB,
    FVBZ: fvbz,
    FVBZSO: fvbzso,
    KZTAB: kztab,
    ZTABFB: ZTABFB
  };
};
exports.MZTABFB23 = MZTABFB23;

/***/ }),

/***/ 986:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.STSMIN = void 0;
var big_js_1 = __webpack_require__(5395);
var msolzsts_1 = __webpack_require__(8527);
var STSMIN = function (_a, CONFIG) {
  var R = _a.R,
    F = _a.F,
    STKL = _a.STKL,
    STS = _a.STS,
    MBV = _a.MBV,
    BK = _a.BK,
    LSTLZZ = _a.LSTLZZ,
    SOLZLZZ = _a.SOLZLZZ,
    ZKF = _a.ZKF,
    ZVE = _a.ZVE,
    KZTAB = _a.KZTAB,
    KFB = _a.KFB;
  var BKS;
  var SOLZS;
  var sts = STS;
  var solzlzz = SOLZLZZ;
  var lstlzz = LSTLZZ;
  var bk = BK;
  // STS < 0 ?
  if (STS.lt(0)) {
    // | Ja
    // MBV = 0 ?
    if (!MBV.eq(0)) {
      // | Nein
      lstlzz = LSTLZZ.add(STS);
      if (lstlzz.lt(0)) {
        lstlzz = new big_js_1.default(0);
      }
      solzlzz = SOLZLZZ.add(STS.mul("5,5").div(100)).round(2, big_js_1.default.roundDown);
      if (solzlzz.lt(0)) {
        solzlzz = new big_js_1.default(0);
      }
      bk = BK.add(STS);
      if (bk.lt(0)) {
        bk = new big_js_1.default(0);
      }
    }
    // STS = 0
    // SOLZS = 0
    sts = new big_js_1.default(0);
    SOLZS = new big_js_1.default(0);
  } else {
    // | Nein
    // | MSOLZSTS ()
    var solzs = (0, msolzsts_1.MSOLZSTS)({
      F: F,
      STS: STS,
      ZKF: ZKF,
      STKL: STKL,
      ZVE: ZVE,
      KFB: KFB,
      KZTAB: KZTAB
    }, CONFIG).SOLZS;
    SOLZS = solzs;
  }
  // R > 0
  if (R > 0) {
    // | Ja
    // | BKS = STS
    BKS = sts;
  } else {
    // | Nein
    // | BSK = 0
    BKS = new big_js_1.default(0);
  }
  return {
    BK: bk,
    BKS: BKS,
    STS: sts,
    SOLZS: SOLZS,
    LSTLZZ: lstlzz,
    SOLZLZZ: solzlzz
  };
};
exports.STSMIN = STSMIN;

/***/ }),

/***/ 8227:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = this && this.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UP56 = void 0;
var big_js_1 = __webpack_require__(5395);
var uptab_1 = __webpack_require__(2129);
var UP56 = function (_a, CONFIG) {
  var ZX = _a.ZX,
    rest = __rest(_a, ["ZX"]);
  // X = ZX * 1,25 || UPTAB22 || ST1 = ST
  var ST1 = (0, uptab_1.UPTAB)(__assign(__assign({}, rest), {
    X: ZX.mul(1.25).round(2, big_js_1.default.roundDown)
  }), CONFIG);
  // X = ZX * 0,75 || UPTAB22 || ST2 = ST
  var ST2 = (0, uptab_1.UPTAB)(__assign(__assign({}, rest), {
    X: ZX.mul(0.75).round(2, big_js_1.default.roundDown)
  }), CONFIG);
  var DIFF = ST1.minus(ST2).mul(2);
  var MIST = ZX.mul(0.14).round(0, big_js_1.default.roundDown);
  return MIST.gt(DIFF) ? MIST : DIFF;
};
exports.UP56 = UP56;

/***/ }),

/***/ 1179:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UPANTEIL = void 0;
var big_js_1 = __webpack_require__(5395);
var UPANTEIL = function (_a) {
  var JW = _a.JW,
    LZZ = _a.LZZ;
  var ANTEIL1; // Auf den Lohnzahlungszeitraum entfallender Anteil von Jahreswerten auf ganze Cent abgerundet
  switch (LZZ) {
    case 1:
      ANTEIL1 = JW;
      break;
    case 2:
      ANTEIL1 = JW.div(12).round(0, big_js_1.default.roundDown);
      break;
    case 3:
      ANTEIL1 = JW.mul(7).div(360).round(0, big_js_1.default.roundDown);
      break;
    default:
      ANTEIL1 = JW.div(360).round(0, big_js_1.default.roundDown);
  }
  return {
    ANTEIL1: ANTEIL1
  };
};
exports.UPANTEIL = UPANTEIL;

/***/ }),

/***/ 7585:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UPEVP = void 0;
var big_js_1 = __webpack_require__(5395);
var mvsp_1 = __webpack_require__(6582);
var UPEVP = function (_a, CONFIG) {
  var PKV = _a.PKV,
    KRV = _a.KRV,
    STKL = _a.STKL,
    PKPV = _a.PKPV,
    ZRE4VP = _a.ZRE4VP;
  var VSP1; // Zwischenwert 1 bei der Berechnung der Vorsorgepauschale in Euro, Cent (2 Dezimalstellen)
  var VSP2; // Zwischenwert 2 bei der Berechnung der Vorsorgepauschale in Euro, Cent (2 Dezimalstellen)
  var VHB; // Höchstbetrag der Mindestvorsorgepauschale für die Kranken- und Pflegeversicherung in Euro, Cent (2 Dezimalstellen)
  var VSPN; // Vorsorgepauschale mit Teilbeträgen für die Rentenversicherung sowie der Mindestvorsorgepauschale für die Kranken- und Pflegeversicherung in Euro, Cent (2 Dezimalstellen)
  var BBGRV = CONFIG.BBGRV,
    RVSATZAN = CONFIG.RVSATZAN,
    TBSVORV = CONFIG.TBSVORV;
  var zre4vp = ZRE4VP;
  // KRV > 1
  if (KRV > 1) {
    VSP1 = new big_js_1.default(0);
  } else {
    if (zre4vp.gt(BBGRV)) {
      zre4vp = BBGRV;
    }
    VSP1 = TBSVORV.mul(zre4vp);
    VSP1 = VSP1.mul(RVSATZAN);
  }
  VSP2 = zre4vp.mul(0.12);
  if (STKL === 3) {
    VHB = new big_js_1.default(3000);
  } else {
    VHB = new big_js_1.default(1900);
  }
  if (VSP2.gt(VHB)) {
    VSP2 = VHB;
  }
  VSPN = VSP1.add(VSP2).round(0, big_js_1.default.roundUp);
  // RUN MVSP
  var _b = (0, mvsp_1.MVSP)({
      VSP1: VSP1,
      PKV: PKV,
      STKL: STKL,
      PKPV: PKPV,
      ZRE4VP: zre4vp
    }, CONFIG),
    VSP = _b.VSP,
    VSP3 = _b.VSP3;
  var vsp = VSP;
  // VSPN > VSP ?
  if (VSPN.gt(VSP)) {
    vsp = VSPN;
  }
  return {
    VSP2: VSP2,
    VSP3: VSP3,
    VSP: vsp
  };
};
exports.UPEVP = UPEVP;

/***/ }),

/***/ 9505:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UPLSTLZZ = void 0;
var upanteil_1 = __webpack_require__(1179);
var UPLSTLZZ = function (_a) {
  var LSTJAHR = _a.LSTJAHR,
    LZZ = _a.LZZ;
  var JW = LSTJAHR.mul(100);
  var LSTLZZ = (0, upanteil_1.UPANTEIL)({
    JW: JW,
    LZZ: LZZ
  }).ANTEIL1;
  return {
    LSTLZZ: LSTLZZ
  };
};
exports.UPLSTLZZ = UPLSTLZZ;

/***/ }),

/***/ 5074:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UPMLST = void 0;
var big_js_1 = __webpack_require__(5395);
var uptab_1 = __webpack_require__(2129);
var mst56_1 = __webpack_require__(8906);
var UPMLST = function (_a, CONFIG) {
  var STKL = _a.STKL,
    ZVE = _a.ZVE,
    KZTAB = _a.KZTAB;
  var X; // Zu versteuerndes Einkommen gem. § 32a Absatz 1 und 5 EStG in Euro, Cent (2 Dezimalstellen)
  if (ZVE.lt(1)) {
    X = new big_js_1.default(0);
  } else {
    X = ZVE.div(KZTAB).round(0, big_js_1.default.roundDown);
  }
  //                  STKL < 5          // UPTAB22                                  // MST5-6
  return STKL !== 5 && STKL !== 6 ? (0, uptab_1.UPTAB)({
    X: X,
    KZTAB: KZTAB
  }, CONFIG) : (0, mst56_1.MST56)({
    X: X,
    KZTAB: KZTAB
  }, CONFIG);
};
exports.UPMLST = UPMLST;

/***/ }),

/***/ 2129:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UPTAB23 = exports.UPTAB22 = exports.UPTAB = void 0;
var big_js_1 = __webpack_require__(5395);
var UPTAB = function (INPUT_DATA, CONFIG) {
  var BJAHR = CONFIG.BJAHR;
  if (BJAHR === 2023) {
    return (0, exports.UPTAB23)(INPUT_DATA, CONFIG);
  }
  return (0, exports.UPTAB22)(INPUT_DATA, CONFIG);
};
exports.UPTAB = UPTAB;
var UPTAB22 = function (_a, CONFIG) {
  var X = _a.X,
    KZTAB = _a.KZTAB;
  var ST;
  var Y; // Gem. § 32a Absatz 1 EStG (6 Dezimalstellen)
  var RW; // Rechenwert in Gleitkommadarstellung
  var GFB = CONFIG.GFB,
    PATCH = CONFIG.PATCH;
  // X < GFB + 1
  if (X.lt(GFB.add(1))) {
    ST = new big_js_1.default(0);
  } else {
    // | Nein
    // | X < 14927 ?
    if (X.lt(new big_js_1.default(14927))) {
      // Y = (X - GFB) / 10000
      Y = X.minus(GFB).div(10000).round(6, big_js_1.default.roundDown);
      // RW = Y*1008,70
      RW = Y.mul(new big_js_1.default(PATCH === "1" ? 1008.7 : 1088.67));
      // RW = RW + 1400
      RW = RW.add(1400);
      // ST = RW * Y
      ST = RW.mul(Y).round(0, big_js_1.default.roundDown);
    }
    // | X < 58597 ?
    else if (X.lt(new big_js_1.default(58597))) {
      // Y = (X - 14926) / 10000
      Y = X.minus(14926).div(10000).round(6, big_js_1.default.roundDown);
      // RW = Y * 206,43
      RW = Y.mul(206.43);
      // RW = RW + 2397
      RW = RW.add(2397);
      // RW = RW * Y
      RW = RW.mul(Y);
      // ST = RW + 938,24
      ST = RW.add(PATCH === "1" ? 938.24 : 869.32).round(0, big_js_1.default.roundDown); // XML Wert
    }
    // | X < 277826 ?
    else if (X.lt(new big_js_1.default(277826))) {
      // ST = X * 0,42 - 9267,53
      ST = X.mul(0.42).minus(PATCH === "1" ? 9267.53 : 9336.45).round(0, big_js_1.default.roundDown);
    } else {
      // ST = X * 0,45 - 17602,28
      ST = X.mul(0.45).minus(PATCH === "1" ? 17602.28 : 17671.2).round(0, big_js_1.default.roundDown);
    }
  }
  ST = ST.mul(KZTAB);
  return ST;
};
exports.UPTAB22 = UPTAB22;
var UPTAB23 = function (_a, CONFIG) {
  var X = _a.X,
    KZTAB = _a.KZTAB;
  var ST;
  var Y; // Gem. § 32a Absatz 1 EStG (6 Dezimalstellen)
  var RW; // Rechenwert in Gleitkommadarstellung
  var GFB = CONFIG.GFB;
  // X < GFB + 1
  if (X.lt(GFB.add(1))) {
    ST = new big_js_1.default(0);
  } else {
    // | Nein
    // | X < 14927 ?
    if (X.lt(new big_js_1.default(16000))) {
      // Y = (X - GFB) / 10000
      Y = X.minus(GFB).div(10000).round(6, big_js_1.default.roundDown);
      // RW = Y*1008,70
      RW = Y.mul(new big_js_1.default(979.18));
      // RW = RW + 1400
      RW = RW.add(1400);
      // ST = RW * Y
      ST = RW.mul(Y).round(0, big_js_1.default.roundDown);
    }
    // | X < 58597 ?
    else if (X.lt(new big_js_1.default(62810))) {
      // Y = (X - 14926) / 10000
      Y = X.minus(15999).div(10000).round(6, big_js_1.default.roundDown);
      // RW = Y * 206,43
      RW = Y.mul(192.59);
      // RW = RW + 2397
      RW = RW.add(2397);
      // RW = RW * Y
      RW = RW.mul(Y);
      // ST = RW + 938,24
      ST = RW.add(966.53).round(0, big_js_1.default.roundDown); // .XML Wert
    }
    // | X < 277826 ?
    else if (X.lt(new big_js_1.default(277826))) {
      // ST = X * 0,42 - 9267,53
      ST = X.mul(0.42).minus(9972.98).round(0, big_js_1.default.roundDown);
    } else {
      // ST = X * 0,45 - 17602,28
      ST = X.mul(0.45).minus(18307.73).round(0, big_js_1.default.roundDown);
    }
  }
  ST = ST.mul(KZTAB);
  return ST;
};
exports.UPTAB23 = UPTAB23;

/***/ }),

/***/ 2377:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UPVKLZZ = void 0;
var upvkv_1 = __webpack_require__(8593);
var upanteil_1 = __webpack_require__(1179);
var UPVKLZZ = function (_a) {
  var LZZ = _a.LZZ,
    PKV = _a.PKV,
    VSP2 = _a.VSP2,
    VSP3 = _a.VSP3;
  // UPVKV
  // |
  // JW = VKV
  var JW = (0, upvkv_1.UPVKV)({
    PKV: PKV,
    VSP2: VSP2,
    VSP3: VSP3
  }).VKV;
  // UPANTEIL
  // |
  // VKVLZZ = ANTEIL1
  var VKVLZZ = (0, upanteil_1.UPANTEIL)({
    JW: JW,
    LZZ: LZZ
  }).ANTEIL1;
  return {
    VKVLZZ: VKVLZZ
  };
};
exports.UPVKLZZ = UPVKLZZ;

/***/ }),

/***/ 8593:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UPVKV = void 0;
var big_js_1 = __webpack_require__(5395);
var UPVKV = function (_a) {
  var PKV = _a.PKV,
    VSP2 = _a.VSP2,
    VSP3 = _a.VSP3;
  var VKV; // Jahreswert der berücksichtigten Beiträge zur privaten Basis-Krankenversicherung und privaten Pflege-Pflichtversicherung (ggf. auch die Mindestvorsorgepauschale) in Cent
  if (PKV > 0) {
    if (VSP2.gt(VSP3)) {
      VKV = VSP2.mul(100);
    } else {
      VKV = VSP3.mul(100);
    }
  } else {
    VKV = new big_js_1.default(0);
  }
  return {
    VKV: VKV
  };
};
exports.UPVKV = UPVKV;

/***/ }),

/***/ 9602:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var jsx_runtime_1 = __webpack_require__(184);
var SvgClose = function (props) {
  return (0, jsx_runtime_1.jsxs)("svg", __assign({
    xmlns: "http://www.w3.org/2000/svg",
    height: 24,
    viewBox: "0 0 24 24",
    width: 24,
    "data-testid": "CloseIcon",
    role: "graphics-symbol img",
    focusable: "false",
    "aria-hidden": "true"
  }, props, {
    children: [(0, jsx_runtime_1.jsx)("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), (0, jsx_runtime_1.jsx)("path", {
      d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    })]
  }));
};
exports["default"] = SvgClose;

/***/ }),

/***/ 8096:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var jsx_runtime_1 = __webpack_require__(184);
var SvgExpandLess = function (props) {
  return (0, jsx_runtime_1.jsxs)("svg", __assign({
    xmlns: "http://www.w3.org/2000/svg",
    height: 24,
    viewBox: "0 0 24 24",
    width: 24,
    "data-testid": "ExpandLessIcon",
    role: "graphics-symbol img",
    focusable: "false",
    "aria-hidden": "true"
  }, props, {
    children: [(0, jsx_runtime_1.jsx)("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), (0, jsx_runtime_1.jsx)("path", {
      d: "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
    })]
  }));
};
exports["default"] = SvgExpandLess;

/***/ }),

/***/ 9068:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var jsx_runtime_1 = __webpack_require__(184);
var SvgExpandMore = function (props) {
  return (0, jsx_runtime_1.jsxs)("svg", __assign({
    xmlns: "http://www.w3.org/2000/svg",
    height: 24,
    viewBox: "0 0 24 24",
    width: 24,
    "data-testid": "ExpandMoreIcon",
    role: "graphics-symbol img",
    focusable: "false",
    "aria-hidden": "true"
  }, props, {
    children: [(0, jsx_runtime_1.jsx)("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), (0, jsx_runtime_1.jsx)("path", {
      d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
    })]
  }));
};
exports["default"] = SvgExpandMore;

/***/ }),

/***/ 3228:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var jsx_runtime_1 = __webpack_require__(184);
var SvgInfoOutlined = function (props) {
  return (0, jsx_runtime_1.jsxs)("svg", __assign({
    xmlns: "http://www.w3.org/2000/svg",
    height: 24,
    viewBox: "0 0 24 24",
    width: 24,
    "data-testid": "InfoOutlinedIcon",
    role: "graphics-symbol img",
    focusable: "false",
    "aria-hidden": "true"
  }, props, {
    children: [(0, jsx_runtime_1.jsx)("path", {
      d: "M0 0h24v24H0V0z",
      fill: "none"
    }), (0, jsx_runtime_1.jsx)("path", {
      d: "M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"
    })]
  }));
};
exports["default"] = SvgInfoOutlined;

/***/ }),

/***/ 8056:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var jsx_runtime_1 = __webpack_require__(184);
var SvgPermIdentity = function (props) {
  return (0, jsx_runtime_1.jsxs)("svg", __assign({
    xmlns: "http://www.w3.org/2000/svg",
    height: 24,
    viewBox: "0 0 24 24",
    width: 24,
    "data-testid": "PermIdentityIcon",
    role: "graphics-symbol img",
    focusable: "false",
    "aria-hidden": "true"
  }, props, {
    children: [(0, jsx_runtime_1.jsx)("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), (0, jsx_runtime_1.jsx)("path", {
      d: "M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"
    })]
  }));
};
exports["default"] = SvgPermIdentity;

/***/ }),

/***/ 1539:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var jsx_runtime_1 = __webpack_require__(184);
var SvgPersonOutline = function (props) {
  return (0, jsx_runtime_1.jsxs)("svg", __assign({
    xmlns: "http://www.w3.org/2000/svg",
    height: 24,
    viewBox: "0 0 24 24",
    width: 24,
    "data-testid": "PersonOutlineIcon",
    role: "graphics-symbol img",
    focusable: "false",
    "aria-hidden": "true"
  }, props, {
    children: [(0, jsx_runtime_1.jsx)("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), (0, jsx_runtime_1.jsx)("path", {
      d: "M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"
    })]
  }));
};
exports["default"] = SvgPersonOutline;

/***/ }),

/***/ 4606:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var jsx_runtime_1 = __webpack_require__(184);
var SvgSaveAlt = function (props) {
  return (0, jsx_runtime_1.jsxs)("svg", __assign({
    xmlns: "http://www.w3.org/2000/svg",
    height: 24,
    viewBox: "0 0 24 24",
    width: 24,
    "data-testid": "SaveAltIcon",
    role: "graphics-symbol img",
    focusable: "false",
    "aria-hidden": "true"
  }, props, {
    children: [(0, jsx_runtime_1.jsx)("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), (0, jsx_runtime_1.jsx)("path", {
      d: "M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"
    })]
  }));
};
exports["default"] = SvgSaveAlt;

/***/ }),

/***/ 8278:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ep: () => (/* binding */ createPath),
/* harmony export */   J0: () => (/* binding */ invariant),
/* harmony export */   PP: () => (/* binding */ createMemoryHistory),
/* harmony export */   RQ: () => (/* binding */ joinPaths),
/* harmony export */   WK: () => (/* binding */ isRouteErrorResponse),
/* harmony export */   X3: () => (/* binding */ AbortedDeferredError),
/* harmony export */   Zn: () => (/* binding */ stripBasename),
/* harmony export */   aU: () => (/* binding */ Action),
/* harmony export */   cP: () => (/* binding */ parsePath),
/* harmony export */   cm: () => (/* binding */ getResolveToMatches),
/* harmony export */   fp: () => (/* binding */ matchRoutes),
/* harmony export */   pC: () => (/* binding */ resolveTo)
/* harmony export */ });
/* unused harmony exports IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, UNSAFE_DeferredData, UNSAFE_ErrorResponseImpl, UNSAFE_convertRouteMatchToUiMatch, UNSAFE_convertRoutesToDataRoutes, UNSAFE_warning, createBrowserHistory, createHashHistory, createRouter, createStaticHandler, defer, generatePath, getStaticContextFromError, getToPathname, isDeferredData, json, matchPath, normalizePathname, redirect, redirectDocument, resolvePath */
/**
 * @remix-run/router v1.15.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////
/**
 * Actions represent the type of change to a location value.
 */
var Action;
(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */
  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */
  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */
function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation
  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = Action.Pop;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = Action.Pop;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));
    // Hash URL should always have a leading / just like window.location.pathname
    // does, so if an app ends up at a route like /#something then we add a
    // leading slash so all of our path-matching behaves the same as if it would
    // in a browser router.  This is particularly important when there exists a
    // root splat route (<Route path="*">) since that matches internally against
    // "/*" and we'd expect /#something to 404 in a hash router app.
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience, so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message);
      // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  // Index should only be null when we initialize. If not, it's because the
  // user called history.pushState or history.replaceState directly, in which
  // case we should log a warning as it will result in bugs.
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    // try...catch because iOS limits us to 100 pushState calls :/
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // If the exception is because `state` can't be serialized, let that throw
      // outwards just like a replace call would so the dev knows the cause
      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps
      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    // window.location.origin is "null" (the literal string value) in Firefox
    // under certain conditions, notably when serving from a local HTML file
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    // Treating this as a full URL will strip any trailing spaces so we need to
    // pre-encode them since they might be part of a matching splat param from
    // an ancestor route
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window, to);
    },
    createURL,
    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}
//#endregion

var ResultType;
(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
// Walk the route tree generating unique IDs where necessary, so we are working
// solely with AgnosticDataRouteObject's within the Router
function convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index) => {
    let treePath = [...parentPath, index];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id], "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, mapRouteProperties(route), {
        id
      });
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {
        id,
        children: undefined
      });
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i], decoded);
  }
  return matches;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    // Add the children before adding this route to the array, so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.
    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  // Optional path segments are denoted by a trailing `?`
  let isOptional = first.endsWith("?");
  // Compute the corresponding required segment: `foo?` -> `foo`
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  // All child paths with the prefix.  Do this for all children before the
  // optional version for all children, so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explode _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue
  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/")));
  // Then, if this is an optional value, add all child versions without
  if (isOptional) {
    result.push(...restExploded);
  }
  // for absolute paths, ensure `/` instead of empty segment
  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */
function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  }
  // ensure `/` is added at the beginning if the path is absolute
  const prefix = path.startsWith("/") ? "/" : "";
  const stringify = p => p == null ? "" : typeof p === "string" ? p : String(p);
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1;
    // only apply the splat if it's the last segment
    if (isLastSegment && segment === "*") {
      const star = "*";
      // Apply the splat
      return stringify(params[star]);
    }
    const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      invariant(optional === "?" || param != null, "Missing \":" + key + "\" param");
      return stringify(param);
    }
    // Remove any optional markers from optional static segments
    return segment.replace(/\?$/g, "");
  })
  // Remove empty segments
  .filter(segment => !!segment);
  return prefix + segments.join("/");
}
/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo, _ref, index) => {
    let {
      paramName,
      isOptional
    } = _ref;
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo[paramName] = undefined;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^${}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex, so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map(v => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
// Return the array of pathnames for the current route matches - used to
// generate the routePathnames input for resolveTo()
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf
  // match so we include splat values for "." links.  See:
  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329
  if (v7_relativeSplatPath) {
    return pathMatches.map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);
  }
  return pathMatches.map(match => match.pathnameBase);
}
/**
 * @private
 */
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    // With relative="route" (the default), each leading .. segment means
    // "go up one route" instead of "go up one URL segment".  This is a key
    // difference from how <a href> works and a major reason we call this a
    // "to" value instead of a "href".
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  // Ensure the pathname has a trailing slash if the original "to" had one
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  // Or if this was a link to the current path which has a trailing slash
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
/**
 * @private
 */
function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
/**
 * @private
 */
const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */
const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */
const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */
const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */
const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data, responseInit) {
    this.pendingKeysSet = new Set();
    this.subscribers = new Set();
    this.deferredKeys = [];
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects");
    // Set up an AbortController + Promise we can race against to exit early
    // cancellation
    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
    if (this.done) {
      // All incoming values were resolved
      this.unlistenAbortSignal();
    }
    this.init = responseInit;
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.deferredKeys.push(key);
    this.pendingKeysSet.add(key);
    // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject
    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));
    // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values
    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeysSet.delete(key);
    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }
    // If the promise was resolved/rejected with undefined, we'll throw an error as you
    // should always resolve with a value or null
    if (error === undefined && data === undefined) {
      let undefinedError = new Error("Deferred data for key \"" + key + "\" resolved/rejected with `undefined`, " + "you must resolve/reject with a value or `null`.");
      Object.defineProperty(promise, "_error", {
        get: () => undefinedError
      });
      this.emit(false, key);
      return Promise.reject(undefinedError);
    }
    if (data === undefined) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      this.emit(false, key);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    this.emit(false, key);
    return data;
  }
  emit(aborted, settledKey) {
    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  }
  subscribe(fn) {
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }
  cancel() {
    this.controller.abort();
    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
    this.emit(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);
          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref3) => {
      let [key, value] = _ref3;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
const defer = function defer(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  return new DeferredData(data, responseInit);
};
/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};
/**
 * A redirect response that will force a document reload to the new location.
 * Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirectDocument = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Reload-Document", "true");
  return response;
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 *
 * We don't export the class for public use since it's an implementation
 * detail, but we export the interface above so folks can build their own
 * abstractions around instances via isRouteErrorResponse()
 */
class ErrorResponseImpl {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 */
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
  json: undefined,
  text: undefined
};
const IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
  json: undefined,
  text: undefined
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const defaultMapRouteProperties = route => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////
/**
 * Create a router and listen to history POP navigations
 */
function createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : undefined;
  const isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer = !isBrowser;
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties;
  if (init.mapRouteProperties) {
    mapRouteProperties = init.mapRouteProperties;
  } else if (init.detectErrorBoundary) {
    // If they are still using the deprecated version, wrap it with the new API
    let detectErrorBoundary = init.detectErrorBoundary;
    mapRouteProperties = route => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties = defaultMapRouteProperties;
  }
  // Routes keyed by ID
  let manifest = {};
  // Routes in tree format for matching
  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  // Config driven behavior flags
  let future = _extends({
    v7_fetcherPersist: false,
    v7_normalizeFormMethod: false,
    v7_partialHydration: false,
    v7_prependBasename: false,
    v7_relativeSplatPath: false
  }, init.future);
  // Cleanup function for history
  let unlistenHistory = null;
  // Externally-provided functions to call on all state changes
  let subscribers = new Set();
  // Externally-provided object to hold scroll restoration locations during routing
  let savedScrollPositions = null;
  // Externally-provided function to get scroll restoration keys
  let getScrollRestorationKey = null;
  // Externally-provided function to get current scroll position
  let getScrollPosition = null;
  // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialErrors = null;
  if (initialMatches == null) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized;
  let hasLazyRoutes = initialMatches.some(m => m.route.lazy);
  let hasLoaders = initialMatches.some(m => m.route.loader);
  if (hasLazyRoutes) {
    // All initialMatches need to be loaded before we're ready.  If we have lazy
    // functions around still then we'll need to run them in initialize()
    initialized = false;
  } else if (!hasLoaders) {
    // If we've got no loaders to run, then we're good to go
    initialized = true;
  } else if (future.v7_partialHydration) {
    // If partial hydration is enabled, we're initialized so long as we were
    // provided with hydrationData for every route with a loader, and no loaders
    // were marked for explicit hydration
    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
    let errors = init.hydrationData ? init.hydrationData.errors : null;
    let isRouteInitialized = m => {
      // No loader, nothing to initialize
      if (!m.route.loader) return true;
      // Explicitly opting-in to running on hydration
      if (m.route.loader.hydrate === true) return false;
      // Otherwise, initialized if hydrated with data or an error
      return loaderData && loaderData[m.route.id] !== undefined || errors && errors[m.route.id] !== undefined;
    };
    // If errors exist, don't consider routes below the boundary
    if (errors) {
      let idx = initialMatches.findIndex(m => errors[m.route.id] !== undefined);
      initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);
    } else {
      initialized = initialMatches.every(isRouteInitialized);
    }
  } else {
    // Without partial hydration - we're initialized if we were provided any
    // hydrationData - which is expected to be complete
    initialized = init.hydrationData != null;
  }
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map(),
    blockers: new Map()
  };
  // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)
  let pendingAction = Action.Pop;
  // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?
  let pendingPreventScrollReset = false;
  // AbortController for the active navigation
  let pendingNavigationController;
  // Should the current navigation enable document.startViewTransition?
  let pendingViewTransitionEnabled = false;
  // Store applied view transitions so we can apply them on POP
  let appliedViewTransitions = new Map();
  // Cleanup function for persisting applied transitions to sessionStorage
  let removePageHideEventListener = null;
  // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted
  let isUninterruptedRevalidation = false;
  // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidator()
  //  - X-Remix-Revalidate (from redirect)
  let isRevalidationRequired = false;
  // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission
  let cancelledDeferredRoutes = [];
  // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation
  let cancelledFetcherLoads = [];
  // AbortControllers for any in-flight fetchers
  let fetchControllers = new Map();
  // Track loads based on the order in which they started
  let incrementingLoadId = 0;
  // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation
  let pendingNavigationLoadId = -1;
  // Fetchers that triggered data reloads as a result of their actions
  let fetchReloadIds = new Map();
  // Fetchers that triggered redirect navigations
  let fetchRedirectIds = new Set();
  // Most recent href/match for fetcher.load calls for fetchers
  let fetchLoadMatches = new Map();
  // Ref-count mounted fetchers so we know when it's ok to clean them up
  let activeFetchers = new Map();
  // Fetchers that have requested a delete when using v7_fetcherPersist,
  // they'll be officially removed after they return to idle
  let deletedFetchers = new Set();
  // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.
  let activeDeferreds = new Map();
  // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change
  let blockerFunctions = new Map();
  // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state
  let ignoreNextHistoryUpdate = false;
  // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();
  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      // Ignore this event if it was just us resetting the URL from a
      // blocked POP navigation
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        // Restore the URL to match the current UI, but don't update router state
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1);
        // Put the blocker into a blocked state
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location
            });
            // Re-do the same POP navigation we just blocked
            init.history.go(delta);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (isBrowser) {
      // FIXME: This feels gross.  How can we cleanup the lines between
      // scrollRestoration/appliedTransitions persistance?
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    // Kick off initial data load if needed.  Use Pop to avoid modifying history
    // Note we don't do any handling of lazy here.  For SPA's it'll get handled
    // in the normal navigation flow.  For SSR it's expected that lazy modules are
    // resolved prior to router creation since we can't go into a fallbackElement
    // UI for SSR'd apps
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location, {
        initialHydration: true
      });
    }
    return router;
  }
  // Clean up a router and it's side effects
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  }
  // Subscribe to state updates for the router
  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  // Update our state and notify the calling context of the change
  function updateState(newState, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state = _extends({}, state, newState);
    // Prep fetcher cleanup so we can tell the UI which fetcher data entries
    // can be removed
    let completedFetchers = [];
    let deletedFetchersKeys = [];
    if (future.v7_fetcherPersist) {
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (deletedFetchers.has(key)) {
            // Unmounted from the UI and can be totally removed
            deletedFetchersKeys.push(key);
          } else {
            // Returned to idle but still mounted in the UI, so semi-remains for
            // revalidations and such
            completedFetchers.push(key);
          }
        }
      });
    }
    // Iterate over a local copy so that if flushSync is used and we end up
    // removing and adding a new subscriber due to the useCallback dependencies,
    // we don't get ourselves into a loop calling the new subscriber immediately
    [...subscribers].forEach(subscriber => subscriber(state, {
      deletedFetchers: deletedFetchersKeys,
      unstable_viewTransitionOpts: opts.viewTransitionOpts,
      unstable_flushSync: opts.flushSync === true
    }));
    // Remove idle fetchers from state since we only care about in-flight fetchers.
    if (future.v7_fetcherPersist) {
      completedFetchers.forEach(key => state.fetchers.delete(key));
      deletedFetchersKeys.forEach(key => deleteFetcher(key));
    }
  }
  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState
  function completeNavigation(location, newState, _temp) {
    var _location$state, _location$state2;
    let {
      flushSync
    } = _temp === void 0 ? {} : _temp;
    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    }
    // Always preserve any existing loaderData from re-used routes
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    // On a successful navigation we can assume we got through all blockers
    // so we can start fresh
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
    }
    // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = undefined;
    }
    if (isUninterruptedRevalidation) ;else if (pendingAction === Action.Pop) ;else if (pendingAction === Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location, location.state);
    }
    let viewTransitionOpts;
    // On POP, enable transitions if they were enabled on the original navigation
    if (pendingAction === Action.Pop) {
      // Forward takes precedence so they behave like the original navigation
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        // If we don't have a previous forward nav, assume we're popping back to
        // the new location and enable if that location previously enabled
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      // Store the applied transition on PUSH/REPLACE
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(_extends({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }), {
      viewTransitionOpts,
      flushSync: flushSync === true
    });
    // Reset stateful navigation vars
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  }
  // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history
    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation
          });
          // Send the same navigation through
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.unstable_viewTransition,
      flushSync
    });
  }
  // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders
    if (state.navigation.state === "submitting") {
      return;
    }
    // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  }
  // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation
  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, basename);
    let flushSync = (opts && opts.flushSync) === true;
    // Short circuit with a 404 on the root error boundary if we match nothing
    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse);
      // Cancel all pending deferred on 404s since we don't keep any routes
      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      }, {
        flushSync
      });
      return;
    }
    // Short circuit if it's only a hash change and not a revalidation or
    // mutation submission.
    //
    // Ignore on initial page loads because since the initial load will always
    // be "same hash".  For example, on /page#hash and submit a <Form method="post">
    // which will default to a navigation to /page
    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      }, {
        flushSync
      });
      return;
    }
    // Create a controller/Request for this navigation
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace,
        flushSync
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync = false;
      // Create a GET request for the loaders
      request = new Request(request.url, {
        signal: request.signal
      });
    }
    // Call loaders
    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    }
    // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation
    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  }
  // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors
  async function handleAction(request, location, submission, matches, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();
    // Put us in a submitting state
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    }, {
      flushSync: opts.flushSync === true
    });
    // Call our action and get the result
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        replace = result.location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(state, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  }
  // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.
  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);
    // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op
    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;
    // Short circuit if we have no loaders to run
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers = markFetchRedirectsDone();
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}, updatedFetchers ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
      return {
        shortCircuited: true
      };
    }
    // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)
    // If we have partialHydration enabled, then don't update the state for the
    // initial data load since it's not a "navigation"
    if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {
      revalidatingFetchers.forEach(rf => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
    }
    revalidatingFetchers.forEach(rf => {
      if (fetchControllers.has(rf.key)) {
        abortFetcher(rf.key);
      }
      if (rf.controller) {
        // Fetchers use an independent AbortController so that aborting a fetcher
        // (via deleteFetcher) does not abort the triggering navigation that
        // triggered the revalidation
        fetchControllers.set(rf.key, rf.controller);
      }
    });
    // Proxy navigation abort through to revalidation fetchers
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));
    // If any loaders returned a redirect Response, start a new REPLACE navigation
    let redirect = findRedirect(results);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        // If this redirect came from a fetcher make sure we mark it in
        // fetchRedirectIds so it doesn't get revalidated on the next set of
        // loader executions
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      await startRedirectNavigation(state, redirect.result, {
        replace
      });
      return {
        shortCircuited: true
      };
    }
    // Process and commit output from loaders
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
    // Wire up subscribers to update loaderData as promises settle
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    // During partial hydration, preserve SSR errors for routes that don't re-run
    if (future.v7_partialHydration && initialHydration && state.errors) {
      Object.entries(state.errors).filter(_ref2 => {
        let [id] = _ref2;
        return !matchesToLoad.some(m => m.route.id === id);
      }).forEach(_ref3 => {
        let [routeId, error] = _ref3;
        errors = Object.assign(errors || {}, {
          [routeId]: error
        });
      });
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends({
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  // Trigger a fetcher load/submit for the given fetcher key
  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key)) abortFetcher(key);
    let flushSync = (opts && opts.unstable_flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync
      });
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);
      return;
    }
    // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);
  }
  // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation
  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match.route.action && !match.route.lazy) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId: routeId
      });
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    // Put this fetcher into it's submitting state
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    // Call the action for the fetcher
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);
    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI
    // or redirects processed for unmounted fetchers so we just revert them to
    // idle
    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(undefined));
        return;
      }
      // Let SuccessResult's fall through for revalidation
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          // A new navigation was kicked off after our action started, so that
          // should take precedence over this redirect navigation.  We already
          // set isRevalidationRequired so all loaders for the new route should
          // fire unless opted out via shouldRevalidate
          updateFetcherState(key, getDoneFetcher(undefined));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(state, actionResult, {
            fetcherSubmission: submission
          });
        }
      }
      // Process any non-redirect errors thrown
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {
      [match.route.id]: actionResult.data
    }, undefined // No need to send through errors since we short circuit above
    );
    // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data
    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);
      state.fetchers.set(staleKey, revalidatingFetcher);
      if (fetchControllers.has(staleKey)) {
        abortFetcher(staleKey);
      }
      if (rf.controller) {
        fetchControllers.set(staleKey, rf.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect = findRedirect(results);
    if (redirect) {
      if (redirect.idx >= matchesToLoad.length) {
        // If this redirect came from a fetcher make sure we mark it in
        // fetchRedirectIds so it doesn't get revalidated on the next set of
        // loader executions
        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      return startRedirectNavigation(state, redirect.result);
    }
    // Process and commit output from loaders
    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
    // Since we let revalidations complete even if the submitting fetcher was
    // deleted, only put it back to idle if it hasn't been deleted
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.
  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {
      flushSync
    });
    // Call the loader for this fetcher route match
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);
    // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens
    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    }
    // We can delete this so long as we weren't aborted by our our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    // We don't want errors bubbling up or redirects followed for unmounted
    // fetchers, so short circuit here if it was removed from the UI
    if (deletedFetchers.has(key)) {
      updateFetcherState(key, getDoneFetcher(undefined));
      return;
    }
    // If the loader threw a redirect Response, start a new REPLACE navigation
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        // A new navigation was kicked off after our loader started, so that
        // should take precedence over this redirect navigation
        updateFetcherState(key, getDoneFetcher(undefined));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(state, result);
        return;
      }
    }
    // Process any non-redirect errors thrown
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
    // Put the fetcher back into an idle state
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */
  async function startRedirectNavigation(state, redirect, _temp2) {
    let {
      submission,
      fetcherSubmission,
      replace
    } = _temp2 === void 0 ? {} : _temp2;
    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }
    let redirectLocation = createLocation(state.location, redirect.location, {
      _isRedirect: true
    });
    invariant(redirectLocation, "Expected a location on the redirect navigation");
    if (isBrowser) {
      let isDocumentReload = false;
      if (redirect.reloadDocument) {
        // Hard reload if the response contained X-Remix-Reload-Document
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {
        const url = init.history.createURL(redirect.location);
        isDocumentReload =
        // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin ||
        // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace) {
          routerWindow.location.replace(redirect.location);
        } else {
          routerWindow.location.assign(redirect.location);
        }
        return;
      }
    }
    // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled
    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;
    // Use the incoming submission if provided, fallback on the active one in
    // state.navigation
    let {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, activeSubmission, {
          formAction: redirect.location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      // If we have a navigation submission, we will preserve it through the
      // redirect navigation
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    // Call all navigation loaders and revalidating fetcher loaders in parallel,
    // then slice off the results into separate arrays so we can handle them
    // accordingly
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath)), ...fetchersToLoad.map(f => {
      if (f.matches && f.match && f.controller) {
        return callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);
      } else {
        let error = {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f.path
          })
        };
        return error;
      }
    })]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true;
    // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    // Abort in-flight fetcher loads
    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function updateFetcherState(key, fetcher, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function setFetcherError(key, routeId, error, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function getFetcher(key) {
    if (future.v7_fetcherPersist) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      // If this fetcher was previously marked for deletion, unmark it since we
      // have a new instance
      if (deletedFetchers.has(key)) {
        deletedFetchers.delete(key);
      }
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    // Don't abort the controller if this is a deletion of a fetcher.submit()
    // in it's loading phase since - we don't want to abort the corresponding
    // revalidation and want them to complete and land
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    deletedFetchers.delete(key);
    state.fetchers.delete(key);
  }
  function deleteFetcherAndUpdateState(key) {
    if (future.v7_fetcherPersist) {
      let count = (activeFetchers.get(key) || 0) - 1;
      if (count <= 0) {
        activeFetchers.delete(key);
        deletedFetchers.add(key);
      } else {
        activeFetchers.set(key, count);
      }
    } else {
      deleteFetcher(key);
    }
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  // Utility function to update blockers, ensuring valid state transitions
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref4) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref4;
    if (blockerFunctions.size === 0) {
      return;
    }
    // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
    }
    // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || null;
    // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions) {
      let key = getScrollKey(location, matches);
      let y = savedScrollPositions[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);
  }
  router = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: deleteFetcherAndUpdateState,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////
const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {};
  let basename = (opts ? opts.basename : null) || "/";
  let mapRouteProperties;
  if (opts != null && opts.mapRouteProperties) {
    mapRouteProperties = opts.mapRouteProperties;
  } else if (opts != null && opts.detectErrorBoundary) {
    // If they are still using the deprecated version, wrap it with the new API
    let detectErrorBoundary = opts.detectErrorBoundary;
    mapRouteProperties = route => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties = defaultMapRouteProperties;
  }
  // Config driven behavior flags
  let future = _extends({
    v7_relativeSplatPath: false,
    v7_throwAbortReason: false
  }, opts ? opts.future : null);
  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);
  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   */
  async function query(request, _temp3) {
    let {
      requestContext
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request, location, matches, requestContext);
    if (isResponse(result)) {
      return result;
    }
    // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location
    return _extends({
      location,
      basename
    }, result);
  }
  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   */
  async function queryRoute(request, _temp4) {
    let {
      routeId,
      requestContext
    } = _temp4 === void 0 ? {} : _temp4;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let result = await queryImpl(request, location, matches, requestContext, match);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    }
    // Pick off the right state value to return
    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      var _result$activeDeferre;
      let data = Object.values(result.loaderData)[0];
      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      }
      return data;
    }
    return undefined;
  }
  async function queryImpl(request, location, matches, requestContext, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
        return result;
      }
      let result = await loadRouteData(request, matches, requestContext, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction, we throw
      // it to bail out and then return or throw here based on whether the user
      // returned or threw
      if (isQueryRouteResponse(e)) {
        if (e.type === ResultType.error) {
          throw e.response;
        }
        return e.response;
      }
      // Redirects are always returned since they don't propagate to catch
      // boundaries
      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {
        isStaticRequest: true,
        isRouteRequest,
        requestContext
      });
      if (request.signal.aborted) {
        throwStaticHandlerAbortedError(request, isRouteRequest, future);
      }
    }
    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.status,
        headers: {
          Location: result.location
        }
      });
    }
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(request, matches, requestContext, undefined, {
        [boundaryMatch.route.id]: result.error
      });
      // action status codes take precedence over loader status codes
      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    }
    // Create a GET request for the loaders
    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    let context = await loadRouteData(loaderRequest, matches, requestContext);
    return _extends({}, context, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionData: {
        [actionMatch.route.id]: result.data
      },
      actionHeaders: _extends({}, result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {})
    });
  }
  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
    let isRouteRequest = routeMatch != null;
    // Short circuit if we have no loaders to run (queryRoute())
    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);
    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);
    // Short circuit if we have no loaders to run (query())
    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    }
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {
      isStaticRequest: true,
      isRouteRequest,
      requestContext
    }))]);
    if (request.signal.aborted) {
      throwStaticHandlerAbortedError(request, isRouteRequest, future);
    }
    // Process and commit output from loaders
    let activeDeferreds = new Map();
    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);
    // Add a null for any non-loader matches for proper revalidation on the client
    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}
//#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////
/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */
function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: isRouteErrorResponse(error) ? error.status : 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });
  return newContext;
}
function throwStaticHandlerAbortedError(request, isRouteRequest, future) {
  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {
    throw request.signal.reason;
  }
  let method = isRouteRequest ? "queryRoute" : "query";
  throw new Error(method + "() call aborted: " + request.method + " " + request.url);
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== undefined);
}
function normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    // Grab matches up to the calling route so our route-relative logic is
    // relative to the correct source route
    contextualMatches = [];
    for (let match of matches) {
      contextualMatches.push(match);
      if (match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  // Resolve the relative path
  let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  // When `to` is not specified we inherit search/hash from the current
  // location, unlike when to="." and we just inherit the path.
  // See https://github.com/remix-run/remix/issues/927
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  // Add an ?index param for matched index routes if we don't already have one
  if ((to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  // If we're operating within a basename, prepend it to the pathname.  If
  // this is a root navigation, then just use the raw basename which allows
  // the basename to have full control over the presence of a trailing slash
  // on root actions
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
// Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  // Return location verbatim on non-submission navigations
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });
  // Create a Submission on non-GET navigations
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== undefined) {
    if (opts.formEncType === "text/plain") {
      // text only support POST/PUT/PATCH/DELETE submissions
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?
      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
      Array.from(opts.body.entries()).reduce((acc, _ref5) => {
        let [name, value] = _ref5;
        return "" + acc + name + "=" + value + "\n";
      }, "") : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: undefined,
          json: undefined,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      // json only supports POST/PUT/PATCH/DELETE submissions
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: undefined,
            json,
            text: undefined
          }
        };
      } catch (e) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: undefined,
    text: undefined
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  // Flatten submission onto URLSearchParams for GET submissions
  let parsedPath = parsePath(path);
  // On GET navigation submissions we can drop the ?index param from the
  // resulting location since all loaders will run.  But fetcher GET submissions
  // only run a single loader so we need to preserve any incoming ?index params
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
}
// Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);
    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  // Pick navigation matches that are net-new or qualify for revalidation
  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match, index) => {
    let {
      route
    } = match;
    if (route.lazy) {
      // We haven't loaded this route yet so we don't know if it's got a loader!
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (isInitialLoad) {
      if (route.loader.hydrate) {
        return true;
      }
      return state.loaderData[route.id] === undefined && (
      // Don't re-run if the loader ran and threw an error
      !state.errors || state.errors[route.id] === undefined);
    }
    // Always call the loader on new route instances and pending defer cancellations
    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
      return true;
    }
    // This is the default implementation for when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases
    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate:
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      isRevalidationRequired ||
      // Clicked the same link, resubmitted a GET form
      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||
      // Search params affect all loaders
      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  });
  // Pick fetcher.loads that need to be revalidated
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    // Don't revalidate:
    //  - on initial load (shouldn't be any fetchers then anyway)
    //  - if fetcher won't be present in the subsequent render
    //    - no longer matches the URL (v7_fetcherPersist=false)
    //    - was unmounted but persisted due to v7_fetcherPersist=true
    if (isInitialLoad || !matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
    // If the fetcher path no longer matches, push it in with null matches so
    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is
    // currently only a use-case for Remix HMR where the route tree can change
    // at runtime and remove a route previously loaded via a fetcher
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    // Revalidating fetchers are decoupled from the route matches since they
    // load from a static href.  They revalidate based on explicit revalidation
    // (submission, useRevalidator, or X-Remix-Revalidate)
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      // Never trigger a revalidation of an actively redirecting fetcher
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.includes(key)) {
      // Always revalidate if the fetcher was cancelled
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === undefined) {
      // If the fetcher hasn't ever completed loading yet, then this isn't a
      // revalidation, it would just be a brand new load if an explicit
      // revalidation is required
      shouldRevalidate = isRevalidationRequired;
    } else {
      // Otherwise fall back on any user-defined shouldRevalidate, defaulting
      // to explicit revalidations only
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        defaultShouldRevalidate: isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id;
  // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred
  let isMissingData = currentLoaderData[match.route.id] === undefined;
  // Always load if this is a net-new route or we don't yet have data
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
/**
 * Execute route.lazy() methods to lazily load route modules (loader, action,
 * shouldRevalidate) and update the routeManifest in place which shares objects
 * with dataRoutes so those get updated as well.
 */
async function loadLazyRouteModule(route, mapRouteProperties, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  // If the lazy route function was executed and removed by another parallel
  // call then we can return - first lazy() to finish wins because the return
  // value of lazy is expected to be static
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  // Update the route in place.  This should be safe because there's no way
  // we could yet be sitting on this route as we can't get there without
  // resolving lazy() first.
  //
  // This is different than the HMR "update" use-case where we may actively be
  // on the route being updated.  The main concern boils down to "does this
  // mutation affect any ongoing navigations or any current state.matches
  // values?".  If not, it should be safe to update in place.
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&
    // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, "Route \"" + routeToUpdate.id + "\" has a static property \"" + lazyRouteProperty + "\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \"" + lazyRouteProperty + "\" will be ignored."));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  // Mutate the route with the provided updates.  Do this first so we pass
  // the updated version to mapRouteProperties
  Object.assign(routeToUpdate, routeUpdates);
  // Mutate the `hasErrorBoundary` property on the route based on the route
  // updates and remove the `lazy` function so we don't resolve the lazy
  // route again.
  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {
    lazy: undefined
  }));
}
async function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, v7_relativeSplatPath, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let resultType;
  let result;
  let onReject;
  let runHandler = handler => {
    // Setup a promise we can race against so that abort signals short circuit
    let reject;
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    return Promise.race([handler({
      request,
      params: match.params,
      context: opts.requestContext
    }), abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (match.route.lazy) {
      if (handler) {
        // Run statically defined handler in parallel with lazy()
        let handlerError;
        let values = await Promise.all([
        // If the handler throws, don't let it immediately bubble out,
        // since we need to let the lazy() execution finish so we know if this
        // route has a boundary that can handle the error
        runHandler(handler).catch(e => {
          handlerError = e;
        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);
        if (handlerError) {
          throw handlerError;
        }
        result = values[0];
      } else {
        // Load lazy route module, then run any returned handler
        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);
        handler = match.route[type];
        if (handler) {
          // Handler still run even if we got interrupted to maintain consistency
          // with un-abortable behavior of handler execution on non-lazy or
          // previously-lazy-loaded routes
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match.route.id
          });
        } else {
          // lazy() route has no loader to run.  Short circuit here so we don't
          // hit the invariant below that errors on returning undefined.
          return {
            type: ResultType.data,
            data: undefined
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    resultType = ResultType.error;
    result = e;
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  if (isResponse(result)) {
    let status = result.status;
    // Process redirects
    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
      // Support relative routing in internal redirects
      if (!ABSOLUTE_URL_REGEX.test(location)) {
        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);
      } else if (!opts.isStaticRequest) {
        // Strip off the protocol+origin for same-origin + same-basename absolute
        // redirects. If this is a static request, we can let it go back to the
        // browser as-is
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
        let isSameBasename = stripBasename(url.pathname, basename) != null;
        if (url.origin === currentUrl.origin && isSameBasename) {
          location = url.pathname + url.search + url.hash;
        }
      }
      // Don't process redirects in the router during static requests requests.
      // Instead, throw the Response and let the server handle it with an HTTP
      // redirect.  We also update the Location header in place in this flow so
      // basename and relative routing is taken into account
      if (opts.isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null,
        reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null
      };
    }
    // For SSR single-route requests, we want to hand Responses back directly
    // without unwrapping.  We do this with the QueryRouteResponse wrapper
    // interface so we can know whether it was returned or thrown
    if (opts.isRouteRequest) {
      let queryRouteResponse = {
        type: resultType === ResultType.error ? ResultType.error : ResultType.data,
        response: result
      };
      throw queryRouteResponse;
    }
    let data;
    try {
      let contentType = result.headers.get("Content-Type");
      // Check between word boundaries instead of startsWith() due to the last
      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data = null;
        } else {
          data = await result.json();
        }
      } else {
        data = await result.text();
      }
    } catch (e) {
      return {
        type: ResultType.error,
        error: e
      };
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponseImpl(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (isDeferredData(result)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
}
// Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    // Didn't think we needed this but it turns out unlike other methods, patch
    // won't be properly normalized to uppercase and results in a 405 error.
    // See: https://fetch.spec.whatwg.org/#concept-method
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({
        "Content-Type": formEncType
      });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
      init.body = submission.formData;
    }
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  // Process loader results into state.loaderData/state.errors
  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      // Look upwards from the matched route for the closest ancestor
      // error boundary, defaulting to the root match
      let boundaryMatch = findNearestBoundary(matches, id);
      let error = result.error;
      // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed
      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = undefined;
      }
      errors = errors || {};
      // Prefer higher error values if lower errors bubble to the same boundary
      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      }
      // Clear our any prior loaderData for the throwing route
      loaderData[id] = undefined;
      // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
      } else {
        loaderData[id] = result.data;
      }
      // Error status codes always override success status codes, but if all
      // loaders are successful we take the deepest status code.
      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  });
  // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route
  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = undefined;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
  // Process results from our revalidating fetchers
  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      match,
      controller
    } = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index];
    // Process fetcher non-redirect errors
    if (controller && controller.signal.aborted) {
      // Nothing to do for aborted fetchers
      continue;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined && match.route.loader) {
      // Preserve existing keys not included in newLoaderData and where a loader
      // wasn't removed by HMR
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }
  return mergedLoaderData;
}
// Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp5) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp5 === void 0 ? {} : _temp5;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }
  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
}
// Find any returned redirect errors, starting from the lowest match
function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return {
        result,
        idx: i
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  if (a.pathname !== b.pathname || a.search !== b.search) {
    return false;
  }
  if (a.hash === "") {
    // /page -> /page#hash
    return b.hash !== "";
  } else if (a.hash === b.hash) {
    // /page#hash -> /page#hash
    return true;
  } else if (b.hash !== "") {
    // /page#hash -> /page#other
    return true;
  }
  // If the hash is removed the browser will re-perform a request to the server
  // /page#hash -> /page
  return false;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }
  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isQueryRouteResponse(obj) {
  return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index];
    // If we don't have a match, then we can have a deferred result to do
    // anything with.  This is for revalidating fetchers where the route was
    // removed during HMR
    if (!match) {
      continue;
    }
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      let signal = signals[index];
      invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  }
  // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: undefined,
      json: undefined,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: undefined,
      text: undefined
    };
  } else if (json !== undefined) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: undefined,
      json,
      text: undefined
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      json: undefined,
      text: undefined
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      json: undefined,
      text: undefined,
      data
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : undefined
  };
  return fetcher;
}
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: undefined,
    formAction: undefined,
    formEncType: undefined,
    formData: undefined,
    json: undefined,
    text: undefined,
    data
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k, v] of Object.entries(json || {})) {
        if (v && Array.isArray(v)) {
          transitions.set(k, new Set(v || []));
        }
      }
    }
  } catch (e) {
    // no-op, use default empty object
  }
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k, v] of transitions) {
      json[k] = [...v];
    }
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));
    } catch (error) {
      warning(false, "Failed to save applied view transitions in sessionStorage (" + error + ").");
    }
  }
}
//#endregion



/***/ }),

/***/ 5395:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 *  big.js v6.2.1
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2022 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */
;
(function (GLOBAL) {
  'use strict';

  var Big,
    /************************************** EDITABLE DEFAULTS *****************************************/

    // The default values below must be integers within the stated ranges.

    /*
     * The maximum number of decimal places (DP) of the results of operations involving division:
     * div and sqrt, and pow with negative exponents.
     */
    DP = 20,
    // 0 to MAX_DP

    /*
     * The rounding mode (RM) used when rounding to the above decimal places.
     *
     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
     *  3  Away from zero.                                  (ROUND_UP)
     */
    RM = 1,
    // 0, 1, 2 or 3

    // The maximum value of DP and Big.DP.
    MAX_DP = 1E6,
    // 0 to 1000000

    // The maximum magnitude of the exponent argument to the pow method.
    MAX_POWER = 1E6,
    // 1 to 1000000

    /*
     * The negative exponent (NE) at and beneath which toString returns exponential notation.
     * (JavaScript numbers: -7)
     * -1000000 is the minimum recommended exponent value of a Big.
     */
    NE = -7,
    // 0 to -1000000

    /*
     * The positive exponent (PE) at and above which toString returns exponential notation.
     * (JavaScript numbers: 21)
     * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
     */
    PE = 21,
    // 0 to 1000000

    /*
     * When true, an error will be thrown if a primitive number is passed to the Big constructor,
     * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
     * primitive number without a loss of precision.
     */
    STRICT = false,
    // true or false

    /**************************************************************************************************/

    // Error messages.
    NAME = '[big.js] ',
    INVALID = NAME + 'Invalid ',
    INVALID_DP = INVALID + 'decimal places',
    INVALID_RM = INVALID + 'rounding mode',
    DIV_BY_ZERO = NAME + 'Division by zero',
    // The shared prototype object.
    P = {},
    UNDEFINED = void 0,
    NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

  /*
   * Create and return a Big constructor.
   */
  function _Big_() {
    /*
     * The Big constructor and exported function.
     * Create and return a new instance of a Big number object.
     *
     * n {number|string|Big} A numeric value.
     */
    function Big(n) {
      var x = this;

      // Enable constructor usage without new.
      if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

      // Duplicate.
      if (n instanceof Big) {
        x.s = n.s;
        x.e = n.e;
        x.c = n.c.slice();
      } else {
        if (typeof n !== 'string') {
          if (Big.strict === true && typeof n !== 'bigint') {
            throw TypeError(INVALID + 'value');
          }

          // Minus zero?
          n = n === 0 && 1 / n < 0 ? '-0' : String(n);
        }
        parse(x, n);
      }

      // Retain a reference to this Big constructor.
      // Shadow Big.prototype.constructor which points to Object.
      x.constructor = Big;
    }
    Big.prototype = P;
    Big.DP = DP;
    Big.RM = RM;
    Big.NE = NE;
    Big.PE = PE;
    Big.strict = STRICT;
    Big.roundDown = 0;
    Big.roundHalfUp = 1;
    Big.roundHalfEven = 2;
    Big.roundUp = 3;
    return Big;
  }

  /*
   * Parse the number or string value passed to a Big constructor.
   *
   * x {Big} A Big number instance.
   * n {number|string} A numeric value.
   */
  function parse(x, n) {
    var e, i, nl;
    if (!NUMERIC.test(n)) {
      throw Error(INVALID + 'number');
    }

    // Determine sign.
    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

    // Decimal point?
    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

    // Exponential form?
    if ((i = n.search(/e/i)) > 0) {
      // Determine exponent.
      if (e < 0) e = i;
      e += +n.slice(i + 1);
      n = n.substring(0, i);
    } else if (e < 0) {
      // Integer.
      e = n.length;
    }
    nl = n.length;

    // Determine leading zeros.
    for (i = 0; i < nl && n.charAt(i) == '0';) ++i;
    if (i == nl) {
      // Zero.
      x.c = [x.e = 0];
    } else {
      // Determine trailing zeros.
      for (; nl > 0 && n.charAt(--nl) == '0';);
      x.e = e - i - 1;
      x.c = [];

      // Convert string to array of digits without leading/trailing zeros.
      for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
    }
    return x;
  }

  /*
   * Round Big x to a maximum of sd significant digits using rounding mode rm.
   *
   * x {Big} The Big to round.
   * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
   * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   * [more] {boolean} Whether the result of division was truncated.
   */
  function round(x, sd, rm, more) {
    var xc = x.c;
    if (rm === UNDEFINED) rm = x.constructor.RM;
    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
      throw Error(INVALID_RM);
    }
    if (sd < 1) {
      more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
      xc.length = 1;
      if (more) {
        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
        x.e = x.e - sd + 1;
        xc[0] = 1;
      } else {
        // Zero.
        xc[0] = x.e = 0;
      }
    } else if (sd < xc.length) {
      // xc[sd] is the digit after the digit that may be rounded up.
      more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);

      // Remove any digits after the required precision.
      xc.length = sd;

      // Round up?
      if (more) {
        // Rounding up may mean the previous digit has to be rounded up.
        for (; ++xc[--sd] > 9;) {
          xc[sd] = 0;
          if (sd === 0) {
            ++x.e;
            xc.unshift(1);
            break;
          }
        }
      }

      // Remove trailing zeros.
      for (sd = xc.length; !xc[--sd];) xc.pop();
    }
    return x;
  }

  /*
   * Return a string representing the value of Big x in normal or exponential notation.
   * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
   */
  function stringify(x, doExponential, isNonzero) {
    var e = x.e,
      s = x.c.join(''),
      n = s.length;

    // Exponential notation?
    if (doExponential) {
      s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

      // Normal notation.
    } else if (e < 0) {
      for (; ++e;) s = '0' + s;
      s = '0.' + s;
    } else if (e > 0) {
      if (++e > n) {
        for (e -= n; e--;) s += '0';
      } else if (e < n) {
        s = s.slice(0, e) + '.' + s.slice(e);
      }
    } else if (n > 1) {
      s = s.charAt(0) + '.' + s.slice(1);
    }
    return x.s < 0 && isNonzero ? '-' + s : s;
  }

  // Prototype/instance methods

  /*
   * Return a new Big whose value is the absolute value of this Big.
   */
  P.abs = function () {
    var x = new this.constructor(this);
    x.s = 1;
    return x;
  };

  /*
   * Return 1 if the value of this Big is greater than the value of Big y,
   *       -1 if the value of this Big is less than the value of Big y, or
   *        0 if they have the same value.
   */
  P.cmp = function (y) {
    var isneg,
      x = this,
      xc = x.c,
      yc = (y = new x.constructor(y)).c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either zero?
    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;
    isneg = i < 0;

    // Compare exponents.
    if (k != l) return k > l ^ isneg ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = -1; ++i < j;) {
      if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
    }

    // Compare lengths.
    return k == l ? 0 : k > l ^ isneg ? 1 : -1;
  };

  /*
   * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
   * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
   */
  P.div = function (y) {
    var x = this,
      Big = x.constructor,
      a = x.c,
      // dividend
      b = (y = new Big(y)).c,
      // divisor
      k = x.s == y.s ? 1 : -1,
      dp = Big.DP;
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }

    // Divisor is zero?
    if (!b[0]) {
      throw Error(DIV_BY_ZERO);
    }

    // Dividend is 0? Return +-0.
    if (!a[0]) {
      y.s = k;
      y.c = [y.e = 0];
      return y;
    }
    var bl,
      bt,
      n,
      cmp,
      ri,
      bz = b.slice(),
      ai = bl = b.length,
      al = a.length,
      r = a.slice(0, bl),
      // remainder
      rl = r.length,
      q = y,
      // quotient
      qc = q.c = [],
      qi = 0,
      p = dp + (q.e = x.e - y.e) + 1; // precision of the result

    q.s = k;
    k = p < 0 ? 0 : p;

    // Create version of divisor with leading zero.
    bz.unshift(0);

    // Add zeros to make remainder as long as divisor.
    for (; rl++ < bl;) r.push(0);
    do {
      // n is how many times the divisor goes into current remainder.
      for (n = 0; n < 10; n++) {
        // Compare divisor and remainder.
        if (bl != (rl = r.length)) {
          cmp = bl > rl ? 1 : -1;
        } else {
          for (ri = -1, cmp = 0; ++ri < bl;) {
            if (b[ri] != r[ri]) {
              cmp = b[ri] > r[ri] ? 1 : -1;
              break;
            }
          }
        }

        // If divisor < remainder, subtract divisor from remainder.
        if (cmp < 0) {
          // Remainder can't be more than 1 digit longer than divisor.
          // Equalise lengths using divisor with extra leading zero?
          for (bt = rl == bl ? b : bz; rl;) {
            if (r[--rl] < bt[rl]) {
              ri = rl;
              for (; ri && !r[--ri];) r[ri] = 9;
              --r[ri];
              r[rl] += 10;
            }
            r[rl] -= bt[rl];
          }
          for (; !r[0];) r.shift();
        } else {
          break;
        }
      }

      // Add the digit n to the result array.
      qc[qi++] = cmp ? n : ++n;

      // Update the remainder.
      if (r[0] && cmp) r[rl] = a[ai] || 0;else r = [a[ai]];
    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

    // Leading zero? Do not remove if result is simply zero (qi == 1).
    if (!qc[0] && qi != 1) {
      // There can't be more than one zero.
      qc.shift();
      q.e--;
      p--;
    }

    // Round?
    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);
    return q;
  };

  /*
   * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
   */
  P.eq = function (y) {
    return this.cmp(y) === 0;
  };

  /*
   * Return true if the value of this Big is greater than the value of Big y, otherwise return
   * false.
   */
  P.gt = function (y) {
    return this.cmp(y) > 0;
  };

  /*
   * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
   * return false.
   */
  P.gte = function (y) {
    return this.cmp(y) > -1;
  };

  /*
   * Return true if the value of this Big is less than the value of Big y, otherwise return false.
   */
  P.lt = function (y) {
    return this.cmp(y) < 0;
  };

  /*
   * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
   * return false.
   */
  P.lte = function (y) {
    return this.cmp(y) < 1;
  };

  /*
   * Return a new Big whose value is the value of this Big minus the value of Big y.
   */
  P.minus = P.sub = function (y) {
    var i,
      j,
      t,
      xlty,
      x = this,
      Big = x.constructor,
      a = x.s,
      b = (y = new Big(y)).s;

    // Signs differ?
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xc = x.c.slice(),
      xe = x.e,
      yc = y.c,
      ye = y.e;

    // Either zero?
    if (!xc[0] || !yc[0]) {
      if (yc[0]) {
        y.s = -b;
      } else if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = 1;
      }
      return y;
    }

    // Determine which is the bigger number. Prepend zeros to equalise exponents.
    if (a = xe - ye) {
      if (xlty = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--;) t.push(0);
      t.reverse();
    } else {
      // Exponents equal. Check digit by digit.
      j = ((xlty = xc.length < yc.length) ? xc : yc).length;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xlty = xc[b] < yc[b];
          break;
        }
      }
    }

    // x < y? Point xc to the array of the bigger number.
    if (xlty) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }

    /*
     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
     * needs to start at yc.length.
     */
    if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

    // Subtract yc from xc.
    for (b = i; j > a;) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i];) xc[i] = 9;
        --xc[i];
        xc[j] += 10;
      }
      xc[j] -= yc[j];
    }

    // Remove trailing zeros.
    for (; xc[--b] === 0;) xc.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xc[0] === 0;) {
      xc.shift();
      --ye;
    }
    if (!xc[0]) {
      // n - n = +0
      y.s = 1;

      // Result must be zero.
      xc = [ye = 0];
    }
    y.c = xc;
    y.e = ye;
    return y;
  };

  /*
   * Return a new Big whose value is the value of this Big modulo the value of Big y.
   */
  P.mod = function (y) {
    var ygtx,
      x = this,
      Big = x.constructor,
      a = x.s,
      b = (y = new Big(y)).s;
    if (!y.c[0]) {
      throw Error(DIV_BY_ZERO);
    }
    x.s = y.s = 1;
    ygtx = y.cmp(x) == 1;
    x.s = a;
    y.s = b;
    if (ygtx) return new Big(x);
    a = Big.DP;
    b = Big.RM;
    Big.DP = Big.RM = 0;
    x = x.div(y);
    Big.DP = a;
    Big.RM = b;
    return this.minus(x.times(y));
  };

  /*
   * Return a new Big whose value is the value of this Big negated.
   */
  P.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s;
    return x;
  };

  /*
   * Return a new Big whose value is the value of this Big plus the value of Big y.
   */
  P.plus = P.add = function (y) {
    var e,
      k,
      t,
      x = this,
      Big = x.constructor;
    y = new Big(y);

    // Signs differ?
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }
    var xe = x.e,
      xc = x.c,
      ye = y.e,
      yc = y.c;

    // Either zero?
    if (!xc[0] || !yc[0]) {
      if (!yc[0]) {
        if (xc[0]) {
          y = new Big(x);
        } else {
          y.s = x.s;
        }
      }
      return y;
    }
    xc = xc.slice();

    // Prepend zeros to equalise exponents.
    // Note: reverse faster than unshifts.
    if (e = xe - ye) {
      if (e > 0) {
        ye = xe;
        t = yc;
      } else {
        e = -e;
        t = xc;
      }
      t.reverse();
      for (; e--;) t.push(0);
      t.reverse();
    }

    // Point xc to the longer array.
    if (xc.length - yc.length < 0) {
      t = yc;
      yc = xc;
      xc = t;
    }
    e = yc.length;

    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
    for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

    // No need to check for zero, as +x + +y != 0 && -x + -y != 0

    if (k) {
      xc.unshift(k);
      ++ye;
    }

    // Remove trailing zeros.
    for (e = xc.length; xc[--e] === 0;) xc.pop();
    y.c = xc;
    y.e = ye;
    return y;
  };

  /*
   * Return a Big whose value is the value of this Big raised to the power n.
   * If n is negative, round to a maximum of Big.DP decimal places using rounding
   * mode Big.RM.
   *
   * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
   */
  P.pow = function (n) {
    var x = this,
      one = new x.constructor('1'),
      y = one,
      isneg = n < 0;
    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
      throw Error(INVALID + 'exponent');
    }
    if (isneg) n = -n;
    for (;;) {
      if (n & 1) y = y.times(x);
      n >>= 1;
      if (!n) break;
      x = x.times(x);
    }
    return isneg ? one.div(y) : y;
  };

  /*
   * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
   * significant digits using rounding mode rm, or Big.RM if rm is not specified.
   *
   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */
  P.prec = function (sd, rm) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    return round(new this.constructor(this), sd, rm);
  };

  /*
   * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
   * using rounding mode rm, or Big.RM if rm is not specified.
   * If dp is negative, round to an integer which is a multiple of 10**-dp.
   * If dp is not specified, round to 0 decimal places.
   *
   * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */
  P.round = function (dp, rm) {
    if (dp === UNDEFINED) dp = 0;else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    return round(new this.constructor(this), dp + this.e + 1, rm);
  };

  /*
   * Return a new Big whose value is the square root of the value of this Big, rounded, if
   * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
   */
  P.sqrt = function () {
    var r,
      c,
      t,
      x = this,
      Big = x.constructor,
      s = x.s,
      e = x.e,
      half = new Big('0.5');

    // Zero?
    if (!x.c[0]) return new Big(x);

    // Negative?
    if (s < 0) {
      throw Error(NAME + 'No square root');
    }

    // Estimate.
    s = Math.sqrt(x + '');

    // Math.sqrt underflow/overflow?
    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
    if (s === 0 || s === 1 / 0) {
      c = x.c.join('');
      if (!(c.length + e & 1)) c += '0';
      s = Math.sqrt(c);
      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
      r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
    } else {
      r = new Big(s + '');
    }
    e = r.e + (Big.DP += 4);

    // Newton-Raphson iteration.
    do {
      t = r;
      r = half.times(t.plus(x.div(t)));
    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));
    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);
  };

  /*
   * Return a new Big whose value is the value of this Big times the value of Big y.
   */
  P.times = P.mul = function (y) {
    var c,
      x = this,
      Big = x.constructor,
      xc = x.c,
      yc = (y = new Big(y)).c,
      a = xc.length,
      b = yc.length,
      i = x.e,
      j = y.e;

    // Determine sign of result.
    y.s = x.s == y.s ? 1 : -1;

    // Return signed 0 if either 0.
    if (!xc[0] || !yc[0]) {
      y.c = [y.e = 0];
      return y;
    }

    // Initialise exponent of result as x.e + y.e.
    y.e = i + j;

    // If array xc has fewer digits than yc, swap xc and yc, and lengths.
    if (a < b) {
      c = xc;
      xc = yc;
      yc = c;
      j = a;
      a = b;
      b = j;
    }

    // Initialise coefficient array of result with zeros.
    for (c = new Array(j = a + b); j--;) c[j] = 0;

    // Multiply.

    // i is initially xc.length.
    for (i = b; i--;) {
      b = 0;

      // a is yc.length.
      for (j = a + i; j > i;) {
        // Current sum of products at this digit position, plus carry.
        b = c[j] + yc[i] * xc[j - i - 1] + b;
        c[j--] = b % 10;

        // carry
        b = b / 10 | 0;
      }
      c[j] = b;
    }

    // Increment result exponent if there is a final carry, otherwise remove leading zero.
    if (b) ++y.e;else c.shift();

    // Remove trailing zeros.
    for (i = c.length; !c[--i];) c.pop();
    y.c = c;
    return y;
  };

  /*
   * Return a string representing the value of this Big in exponential notation rounded to dp fixed
   * decimal places using rounding mode rm, or Big.RM if rm is not specified.
   *
   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */
  P.toExponential = function (dp, rm) {
    var x = this,
      n = x.c[0];
    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x = round(new x.constructor(x), ++dp, rm);
      for (; x.c.length < dp;) x.c.push(0);
    }
    return stringify(x, true, !!n);
  };

  /*
   * Return a string representing the value of this Big in normal notation rounded to dp fixed
   * decimal places using rounding mode rm, or Big.RM if rm is not specified.
   *
   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   */
  P.toFixed = function (dp, rm) {
    var x = this,
      n = x.c[0];
    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x = round(new x.constructor(x), dp + x.e + 1, rm);

      // x.e may have changed if the value is rounded up.
      for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
    }
    return stringify(x, false, !!n);
  };

  /*
   * Return a string representing the value of this Big.
   * Return exponential notation if this Big has a positive exponent equal to or greater than
   * Big.PE, or a negative exponent equal to or less than Big.NE.
   * Omit the sign for negative zero.
   */
  P.toJSON = P.toString = function () {
    var x = this,
      Big = x.constructor;
    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
  };

  /*
   * Return the value of this Big as a primitve number.
   */
  P.toNumber = function () {
    var n = Number(stringify(this, true, true));
    if (this.constructor.strict === true && !this.eq(n.toString())) {
      throw Error(NAME + 'Imprecise conversion');
    }
    return n;
  };

  /*
   * Return a string representing the value of this Big rounded to sd significant digits using
   * rounding mode rm, or Big.RM if rm is not specified.
   * Use exponential notation if sd is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */
  P.toPrecision = function (sd, rm) {
    var x = this,
      Big = x.constructor,
      n = x.c[0];
    if (sd !== UNDEFINED) {
      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
        throw Error(INVALID + 'precision');
      }
      x = round(new Big(x), sd, rm);
      for (; x.c.length < sd;) x.c.push(0);
    }
    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
  };

  /*
   * Return a string representing the value of this Big.
   * Return exponential notation if this Big has a positive exponent equal to or greater than
   * Big.PE, or a negative exponent equal to or less than Big.NE.
   * Include the sign for negative zero.
   */
  P.valueOf = function () {
    var x = this,
      Big = x.constructor;
    if (Big.strict === true) {
      throw Error(NAME + 'valueOf disallowed');
    }
    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
  };

  // Export

  Big = _Big_();
  Big['default'] = Big.Big = Big;

  //AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return Big;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

    // Node and other CommonJS-like environments that support module.exports.
  } else {}
})(this);

/***/ }),

/***/ 4463:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var aa = __webpack_require__(2791),
  ca = __webpack_require__(5296);
function p(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = new Set(),
  ea = {};
function fa(a, b) {
  ha(a, b);
  ha(a + "Capture", b);
}
function ha(a, b) {
  ea[a] = b;
  for (a = 0; a < b.length; a++) da.add(b[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
  ja = Object.prototype.hasOwnProperty,
  ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  la = {},
  ma = {};
function oa(a) {
  if (ja.call(ma, a)) return !0;
  if (ja.call(la, a)) return !1;
  if (ka.test(a)) return ma[a] = !0;
  la[a] = !0;
  return !1;
}
function pa(a, b, c, d) {
  if (null !== c && 0 === c.type) return !1;
  switch (typeof b) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      if (d) return !1;
      if (null !== c) return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return !1;
  }
}
function qa(a, b, c, d) {
  if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return !0;
  if (d) return !1;
  if (null !== c) switch (c.type) {
    case 3:
      return !b;
    case 4:
      return !1 === b;
    case 5:
      return isNaN(b);
    case 6:
      return isNaN(b) || 1 > b;
  }
  return !1;
}
function v(a, b, c, d, e, f, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f;
  this.removeEmptyString = g;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
  z[a] = new v(a, 0, !1, a, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
  var b = a[0];
  z[b] = new v(b, 1, !1, a[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
  z[a] = new v(a, 2, !1, a.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
  z[a] = new v(a, 2, !1, a, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
  z[a] = new v(a, 3, !1, a.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function (a) {
  z[a] = new v(a, 3, !0, a, null, !1, !1);
});
["capture", "download"].forEach(function (a) {
  z[a] = new v(a, 4, !1, a, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (a) {
  z[a] = new v(a, 6, !1, a, null, !1, !1);
});
["rowSpan", "start"].forEach(function (a) {
  z[a] = new v(a, 5, !1, a.toLowerCase(), null, !1, !1);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (a) {
  z[a] = new v(a, 1, !1, a.toLowerCase(), null, !1, !1);
});
z.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (a) {
  z[a] = new v(a, 1, !1, a.toLowerCase(), null, !0, !0);
});
function ta(a, b, c, d) {
  var e = z.hasOwnProperty(b) ? z[b] : null;
  if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  va = Symbol.for("react.element"),
  wa = Symbol.for("react.portal"),
  ya = Symbol.for("react.fragment"),
  za = Symbol.for("react.strict_mode"),
  Aa = Symbol.for("react.profiler"),
  Ba = Symbol.for("react.provider"),
  Ca = Symbol.for("react.context"),
  Da = Symbol.for("react.forward_ref"),
  Ea = Symbol.for("react.suspense"),
  Fa = Symbol.for("react.suspense_list"),
  Ga = Symbol.for("react.memo"),
  Ha = Symbol.for("react.lazy");
Symbol.for("react.scope");
Symbol.for("react.debug_trace_mode");
var Ia = Symbol.for("react.offscreen");
Symbol.for("react.legacy_hidden");
Symbol.for("react.cache");
Symbol.for("react.tracing_marker");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A = Object.assign,
  La;
function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c) {
    var b = c.stack.trim().match(/\n( *(at )?)/);
    La = b && b[1] || "";
  }
  return "\n" + La + a;
}
var Na = !1;
function Oa(a, b) {
  if (!a || Na) return "";
  Na = !0;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b) {
      if (b = function () {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", {
        set: function () {
          throw Error();
        }
      }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }
        a.call(b.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (l) {
        d = l;
      }
      a();
    }
  } catch (l) {
    if (l && d && "string" === typeof l.stack) {
      for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) h--;
      for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
        if (1 !== g || 1 !== h) {
          do if (g--, h--, 0 > h || e[g] !== f[h]) {
            var k = "\n" + e[g].replace(" at new ", " at ");
            a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
            return k;
          } while (1 <= g && 0 <= h);
        }
        break;
      }
    }
  } finally {
    Na = !1, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, !1), a;
    case 11:
      return a = Oa(a.type.render, !1), a;
    case 1:
      return a = Oa(a.type, !0), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";
    case Ba:
      return (a._context.displayName || "Context") + ".Provider";
    case Da:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga:
      return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
    case Ha:
      b = a._payload;
      a = a._init;
      try {
        return Qa(a(b));
      } catch (c) {}
  }
  return null;
}
function Ra(a) {
  var b = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b.displayName || "Context") + ".Consumer";
    case 10:
      return (b._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b);
    case 8:
      return b === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b) return b.displayName || b.name || null;
      if ("string" === typeof b) return b;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value",
    c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
    d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get,
      f = c.set;
    Object.defineProperty(a, b, {
      configurable: !0,
      get: function () {
        return e.call(this);
      },
      set: function (a) {
        d = "" + a;
        f.call(this, a);
      }
    });
    Object.defineProperty(a, b, {
      enumerable: c.enumerable
    });
    return {
      getValue: function () {
        return d;
      },
      setValue: function (a) {
        d = "" + a;
      },
      stopTracking: function () {
        a._valueTracker = null;
        delete a[b];
      }
    };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a) return !1;
  var b = a._valueTracker;
  if (!b) return !0;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), !0) : !1;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return A({}, b, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: null != c ? c : a._wrapperState.initialChecked
  });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue,
    d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = {
    initialChecked: d,
    initialValue: c,
    controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
  };
}
function ab(a, b) {
  b = b.checked;
  null != b && ta(a, "checked", b, !1);
}
function bb(a, b) {
  ab(a, b);
  var c = Sa(b.value),
    d = b.type;
  if (null != c) {
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function db(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb = Array.isArray;
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;
    for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;
        d && (a[e].defaultSelected = !0);
        return;
      }
      null !== b || a[e].disabled || (b = a[e]);
    }
    null !== b && (b.selected = !0);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
  return A({}, b, {
    value: void 0,
    defaultValue: void 0,
    children: "" + a._wrapperState.initialValue
  });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b) throw Error(p(92));
      if (eb(c)) {
        if (1 < c.length) throw Error(p(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = {
    initialValue: Sa(c)
  };
}
function ib(a, b) {
  var c = Sa(b.value),
    d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var mb,
  nb = function (a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function () {
        return a(b, c, d, e);
      });
    } : a;
  }(function (a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild;) a.removeChild(a.firstChild);
      for (; b.firstChild;) a.appendChild(b.firstChild);
    }
  });
function ob(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
  qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function (a) {
  qb.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b] = pb[a];
  });
});
function rb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
}
function sb(a, b) {
  a = a.style;
  for (var c in b) if (b.hasOwnProperty(c)) {
    var d = 0 === c.indexOf("--"),
      e = rb(c, b[c], d);
    "float" === c && (c = "cssFloat");
    d ? a.setProperty(c, e) : a[c] = e;
  }
}
var tb = A({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});
function ub(a, b) {
  if (b) {
    if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children) throw Error(p(60));
      if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
    }
    if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
  }
}
function vb(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null,
  zb = null,
  Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb,
      b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb() {}
var Ib = !1;
function Jb(a, b, c) {
  if (Ib) return a(b, c);
  Ib = !0;
  try {
    return Gb(a, b, c);
  } finally {
    if (Ib = !1, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a, b) {
  var c = a.stateNode;
  if (null === c) return null;
  var d = Db(c);
  if (null === d) return null;
  c = d[b];
  a: switch (b) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d;
      break a;
    default:
      a = !1;
  }
  if (a) return null;
  if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
  return c;
}
var Lb = !1;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", {
    get: function () {
      Lb = !0;
    }
  });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = !1;
}
function Nb(a, b, c, d, e, f, g, h, k) {
  var l = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l);
  } catch (m) {
    this.onError(m);
  }
}
var Ob = !1,
  Pb = null,
  Qb = !1,
  Rb = null,
  Sb = {
    onError: function (a) {
      Ob = !0;
      Pb = a;
    }
  };
function Tb(a, b, c, d, e, f, g, h, k) {
  Ob = !1;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b, c, d, e, f, g, h, k) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l = Pb;
      Ob = !1;
      Pb = null;
    } else throw Error(p(198));
    Qb || (Qb = !0, Rb = l);
  }
}
function Vb(a) {
  var b = a,
    c = a;
  if (a.alternate) for (; b.return;) b = b.return;else {
    a = b;
    do b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return; while (a);
  }
  return 3 === b.tag ? c : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b) return b.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a) throw Error(p(188));
}
function Yb(a) {
  var b = a.alternate;
  if (!b) {
    b = Vb(a);
    if (null === b) throw Error(p(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b;;) {
    var e = c.return;
    if (null === e) break;
    var f = e.alternate;
    if (null === f) {
      d = e.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f.child) {
      for (f = e.child; f;) {
        if (f === c) return Xb(e), a;
        if (f === d) return Xb(e), b;
        f = f.sibling;
      }
      throw Error(p(188));
    }
    if (c.return !== d.return) c = e, d = f;else {
      for (var g = !1, h = e.child; h;) {
        if (h === c) {
          g = !0;
          c = e;
          d = f;
          break;
        }
        if (h === d) {
          g = !0;
          d = e;
          c = f;
          break;
        }
        h = h.sibling;
      }
      if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;
            c = f;
            d = e;
            break;
          }
          if (h === d) {
            g = !0;
            d = f;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g) throw Error(p(189));
      }
    }
    if (c.alternate !== d) throw Error(p(190));
  }
  if (3 !== c.tag) throw Error(p(188));
  return c.stateNode.current === c ? a : b;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a;) {
    var b = $b(a);
    if (null !== b) return b;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback,
  bc = ca.unstable_cancelCallback,
  cc = ca.unstable_shouldYield,
  dc = ca.unstable_requestPaint,
  B = ca.unstable_now,
  ec = ca.unstable_getCurrentPriorityLevel,
  fc = ca.unstable_ImmediatePriority,
  gc = ca.unstable_UserBlockingPriority,
  hc = ca.unstable_NormalPriority,
  ic = ca.unstable_LowPriority,
  jc = ca.unstable_IdlePriority,
  kc = null,
  lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b) {}
}
var oc = Math.clz32 ? Math.clz32 : nc,
  pc = Math.log,
  qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64,
  sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c) return 0;
  var d = 0,
    e = a.suspendedLanes,
    f = a.pingedLanes,
    g = c & 268435455;
  if (0 !== g) {
    var h = g & ~e;
    0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
  } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
  if (0 === d) return 0;
  if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
  0 !== (d & 4) && (d |= c & 16);
  b = a.entangledLanes;
  if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function vc(a, b) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b + 5E3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f;) {
    var g = 31 - oc(f),
      h = 1 << g,
      k = e[g];
    if (-1 === k) {
      if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
    } else k <= b && (a.expiredLanes |= h);
    f &= ~h;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b = [], c = 0; 31 > c; c++) b.push(a);
  return b;
}
function Ac(a, b, c) {
  a.pendingLanes |= b;
  536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b = 31 - oc(b);
  a[b] = c;
}
function Bc(a, b) {
  var c = a.pendingLanes & ~b;
  a.pendingLanes = b;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b;
  a.mutableReadLanes &= b;
  a.entangledLanes &= b;
  b = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c;) {
    var e = 31 - oc(c),
      f = 1 << e;
    b[e] = 0;
    d[e] = -1;
    a[e] = -1;
    c &= ~f;
  }
}
function Cc(a, b) {
  var c = a.entangledLanes |= b;
  for (a = a.entanglements; c;) {
    var d = 31 - oc(c),
      e = 1 << d;
    e & b | a[d] & b && (a[d] |= b);
    c &= ~e;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec,
  Fc,
  Gc,
  Hc,
  Ic,
  Jc = !1,
  Kc = [],
  Lc = null,
  Mc = null,
  Nc = null,
  Oc = new Map(),
  Pc = new Map(),
  Qc = [],
  Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b.pointerId);
  }
}
function Tc(a, b, c, d, e, f) {
  if (null === a || a.nativeEvent !== f) return a = {
    blockedOn: b,
    domEventName: c,
    eventSystemFlags: d,
    nativeEvent: f,
    targetContainers: [e]
  }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}
function Uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return Lc = Tc(Lc, a, b, c, d, e), !0;
    case "dragenter":
      return Mc = Tc(Mc, a, b, c, d, e), !0;
    case "mouseover":
      return Nc = Tc(Nc, a, b, c, d, e), !0;
    case "pointerover":
      var f = e.pointerId;
      Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
      return !0;
    case "gotpointercapture":
      return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), !0;
  }
  return !1;
}
function Vc(a) {
  var b = Wc(a.target);
  if (null !== b) {
    var c = Vb(b);
    if (null !== c) if (b = c.tag, 13 === b) {
      if (b = Wb(c), null !== b) {
        a.blockedOn = b;
        Ic(a.priority, function () {
          Gc(c);
        });
        return;
      }
    } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
      a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
      return;
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn) return !1;
  for (var b = a.targetContainers; 0 < b.length;) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb = d;
      c.target.dispatchEvent(d);
      wb = null;
    } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, !1;
    b.shift();
  }
  return !0;
}
function Zc(a, b, c) {
  Xc(a) && c.delete(b);
}
function $c() {
  Jc = !1;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b) {
  a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b(b) {
    return ad(b, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c = 1; c < Kc.length; c++) {
      var d = Kc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b);
  Pc.forEach(b);
  for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn);) Vc(c), null === c.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig,
  dd = !0;
function ed(a, b, c, d) {
  var e = C,
    f = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f;
  }
}
function gd(a, b, c, d) {
  var e = C,
    f = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f;
  }
}
function fd(a, b, c, d) {
  if (dd) {
    var e = Yc(a, b, c, d);
    if (null === e) hd(a, b, d, id, c), Sc(a, d);else if (Uc(e, a, b, c, d)) d.stopPropagation();else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e;) {
        var f = Cb(e);
        null !== f && Ec(f);
        f = Yc(a, b, c, d);
        null === f && hd(a, b, d, id, c);
        if (f === e) break;
        e = f;
      }
      null !== e && d.stopPropagation();
    } else hd(a, b, d, null, c);
  }
}
var id = null;
function Yc(a, b, c, d) {
  id = null;
  a = xb(d);
  a = Wc(a);
  if (null !== a) if (b = Vb(a), null === b) a = null;else if (c = b.tag, 13 === c) {
    a = Wb(b);
    if (null !== a) return a;
    a = null;
  } else if (3 === c) {
    if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
    a = null;
  } else b !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null,
  ld = null,
  md = null;
function nd() {
  if (md) return md;
  var a,
    b = ld,
    c = b.length,
    d,
    e = "value" in kd ? kd.value : kd.textContent,
    f = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++);
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f - d]; d++);
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return !0;
}
function qd() {
  return !1;
}
function rd(a) {
  function b(b, d, e, f, g) {
    this._reactName = b;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f;
    this.target = g;
    this.currentTarget = null;
    for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
    this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var a = this.nativeEvent;
      a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = pd);
    },
    stopPropagation: function () {
      var a = this.nativeEvent;
      a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = pd);
    },
    persist: function () {},
    isPersistent: pd
  });
  return b;
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (a) {
      return a.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  td = rd(sd),
  ud = A({}, sd, {
    view: 0,
    detail: 0
  }),
  vd = rd(ud),
  wd,
  xd,
  yd,
  Ad = A({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function (a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    },
    movementX: function (a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    },
    movementY: function (a) {
      return "movementY" in a ? a.movementY : xd;
    }
  }),
  Bd = rd(Ad),
  Cd = A({}, Ad, {
    dataTransfer: 0
  }),
  Dd = rd(Cd),
  Ed = A({}, ud, {
    relatedTarget: 0
  }),
  Fd = rd(Ed),
  Gd = A({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  Hd = rd(Gd),
  Id = A({}, sd, {
    clipboardData: function (a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }
  }),
  Jd = rd(Id),
  Kd = A({}, sd, {
    data: 0
  }),
  Ld = rd(Kd),
  Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, {
    key: function (a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function (a) {
      return "keypress" === a.type ? od(a) : 0;
    },
    keyCode: function (a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    },
    which: function (a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }
  }),
  Rd = rd(Qd),
  Sd = A({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  Td = rd(Sd),
  Ud = A({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
  }),
  Vd = rd(Ud),
  Wd = A({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  Xd = rd(Wd),
  Yd = A({}, Ad, {
    deltaX: function (a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function (a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  Zd = rd(Yd),
  $d = [9, 13, 27, 32],
  ae = ia && "CompositionEvent" in window,
  be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be,
  de = ia && (!ae || be && 8 < be && 11 >= be),
  ee = String.fromCharCode(32),
  fe = !1;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = !1;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which) return null;
      fe = !0;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;
        if (b.which) return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
    event: c,
    listeners: b
  }));
}
var pe = null,
  qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b)) return a;
}
function ve(a, b) {
  if ("change" === a) return b;
}
var we = !1;
if (ia) {
  var xe;
  if (ia) {
    var ye = ("oninput" in document);
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = !1;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    Jb(re, b);
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b) {
  if ("click" === a) return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a) return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b) {
  if (He(a, b)) return !0;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
  var c = Object.keys(a),
    d = Object.keys(b);
  if (c.length !== d.length) return !1;
  for (d = 0; d < c.length; d++) {
    var e = c[d];
    if (!ja.call(b, e) || !He(a[e], b[e])) return !1;
  }
  return !0;
}
function Je(a) {
  for (; a && a.firstChild;) a = a.firstChild;
  return a;
}
function Ke(a, b) {
  var c = Je(a);
  a = 0;
  for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b) return {
        node: c,
        offset: b - a
      };
      a = d;
    }
    a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je(c);
  }
}
function Le(a, b) {
  return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
}
function Me() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = !1;
    }
    if (c) a = b.contentWindow;else break;
    b = Xa(a.document);
  }
  return b;
}
function Ne(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
function Oe(a) {
  var b = Me(),
    c = a.focusedElem,
    d = a.selectionRange;
  if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
      a = a.getSelection();
      var e = c.textContent.length,
        f = Math.min(d.start, e);
      d = void 0 === d.end ? f : Math.min(d.end, e);
      !a.extend && f > d && (e = d, d = f, f = e);
      e = Ke(c, f);
      var g = Ke(c, d);
      e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
    }
    b = [];
    for (a = c; a = a.parentNode;) 1 === a.nodeType && b.push({
      element: a,
      left: a.scrollLeft,
      top: a.scrollTop
    });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
  Qe = null,
  Re = null,
  Se = null,
  Te = !1;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = {
    start: d.selectionStart,
    end: d.selectionEnd
  } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
    anchorNode: d.anchorNode,
    anchorOffset: d.anchorOffset,
    focusNode: d.focusNode,
    focusOffset: d.focusOffset
  }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
    event: b,
    listeners: d
  }), b.target = Qe)));
}
function Ve(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
  },
  Xe = {},
  Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b = We[a],
    c;
  for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
  return a;
}
var $e = Ze("animationend"),
  af = Ze("animationiteration"),
  bf = Ze("animationstart"),
  cf = Ze("transitionend"),
  df = new Map(),
  ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b) {
  df.set(a, b);
  fa(b, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf],
    jf = hf.toLowerCase(),
    kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
  mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c],
      e = d.event;
    d = d.listeners;
    a: {
      var f = void 0;
      if (b) for (var g = d.length - 1; 0 <= g; g--) {
        var h = d[g],
          k = h.instance,
          l = h.currentTarget;
        h = h.listener;
        if (k !== f && e.isPropagationStopped()) break a;
        nf(e, h, l);
        f = k;
      } else for (g = 0; g < d.length; g++) {
        h = d[g];
        k = h.instance;
        l = h.currentTarget;
        h = h.listener;
        if (k !== f && e.isPropagationStopped()) break a;
        nf(e, h, l);
        f = k;
      }
    }
  }
  if (Qb) throw a = Rb, Qb = !1, Rb = null, a;
}
function D(a, b) {
  var c = b[of];
  void 0 === c && (c = b[of] = new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b, a, 2, !1), c.add(d));
}
function qf(a, b, c) {
  var d = 0;
  b && (d |= 4);
  pf(c, a, d, b);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = !0;
    da.forEach(function (b) {
      "selectionchange" !== b && (mf.has(b) || qf(b, !1, a), qf(b, !0, a));
    });
    var b = 9 === a.nodeType ? a : a.ownerDocument;
    null === b || b[rf] || (b[rf] = !0, qf("selectionchange", !1, b));
  }
}
function pf(a, b, c, d) {
  switch (jd(b)) {
    case 1:
      var e = ed;
      break;
    case 4:
      e = gd;
      break;
    default:
      e = fd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);
  d ? void 0 !== e ? a.addEventListener(b, c, {
    capture: !0,
    passive: e
  }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, {
    passive: e
  }) : a.addEventListener(b, c, !1);
}
function hd(a, b, c, d, e) {
  var f = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
    if (null === d) return;
    var g = d.tag;
    if (3 === g || 4 === g) {
      var h = d.stateNode.containerInfo;
      if (h === e || 8 === h.nodeType && h.parentNode === e) break;
      if (4 === g) for (g = d.return; null !== g;) {
        var k = g.tag;
        if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
        g = g.return;
      }
      for (; null !== h;) {
        g = Wc(h);
        if (null === g) return;
        k = g.tag;
        if (5 === k || 6 === k) {
          d = f = g;
          continue a;
        }
        h = h.parentNode;
      }
    }
    d = d.return;
  }
  Jb(function () {
    var d = f,
      e = xb(c),
      g = [];
    a: {
      var h = df.get(a);
      if (void 0 !== h) {
        var k = td,
          n = a;
        switch (a) {
          case "keypress":
            if (0 === od(c)) break a;
          case "keydown":
          case "keyup":
            k = Rd;
            break;
          case "focusin":
            n = "focus";
            k = Fd;
            break;
          case "focusout":
            n = "blur";
            k = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k = Fd;
            break;
          case "click":
            if (2 === c.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k = Vd;
            break;
          case $e:
          case af:
          case bf:
            k = Hd;
            break;
          case cf:
            k = Xd;
            break;
          case "scroll":
            k = vd;
            break;
          case "wheel":
            k = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k = Td;
        }
        var t = 0 !== (b & 4),
          J = !t && "scroll" === a,
          x = t ? null !== h ? h + "Capture" : null : h;
        t = [];
        for (var w = d, u; null !== w;) {
          u = w;
          var F = u.stateNode;
          5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
          if (J) break;
          w = w.return;
        }
        0 < t.length && (h = new k(h, n, null, c, e), g.push({
          event: h,
          listeners: t
        }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h = "mouseover" === a || "pointerover" === a;
        k = "mouseout" === a || "pointerout" === a;
        if (h && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
        if (k || h) {
          h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;
          if (k) {
            if (n = c.relatedTarget || c.toElement, k = d, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
          } else k = null, n = d;
          if (k !== n) {
            t = Bd;
            F = "onMouseLeave";
            x = "onMouseEnter";
            w = "mouse";
            if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
            J = null == k ? h : ue(k);
            u = null == n ? h : ue(n);
            h = new t(F, w + "leave", k, c, e);
            h.target = J;
            h.relatedTarget = u;
            F = null;
            Wc(e) === d && (t = new t(x, w + "enter", n, c, e), t.target = u, t.relatedTarget = J, F = t);
            J = F;
            if (k && n) b: {
              t = k;
              x = n;
              w = 0;
              for (u = t; u; u = vf(u)) w++;
              u = 0;
              for (F = x; F; F = vf(F)) u++;
              for (; 0 < w - u;) t = vf(t), w--;
              for (; 0 < u - w;) x = vf(x), u--;
              for (; w--;) {
                if (t === x || null !== x && t === x.alternate) break b;
                t = vf(t);
                x = vf(x);
              }
              t = null;
            } else t = null;
            null !== k && wf(g, h, k, t, !1);
            null !== n && null !== J && wf(g, J, n, t, !0);
          }
        }
      }
      a: {
        h = d ? ue(d) : window;
        k = h.nodeName && h.nodeName.toLowerCase();
        if ("select" === k || "input" === k && "file" === h.type) var na = ve;else if (me(h)) {
          if (we) na = Fe;else {
            na = De;
            var xa = Ce;
          }
        } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (na = Ee);
        if (na && (na = na(a, d))) {
          ne(g, na, c, e);
          break a;
        }
        xa && xa(a, h, d);
        "focusout" === a && (xa = h._wrapperState) && xa.controlled && "number" === h.type && cb(h, "number", h.value);
      }
      xa = d ? ue(d) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = !1;
          Ue(g, c, e);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g, c, e);
      }
      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      } else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), xa = oe(d, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e), g.push({
        event: ba,
        listeners: xa
      }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
        event: e,
        listeners: d
      }), e.data = $a);
    }
    se(g, b);
  });
}
function tf(a, b, c) {
  return {
    instance: a,
    listener: b,
    currentTarget: c
  };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a;) {
    var e = a,
      f = e.stateNode;
    5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
    a = a.return;
  }
  return d;
}
function vf(a) {
  if (null === a) return null;
  do a = a.return; while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; null !== c && c !== d;) {
    var h = c,
      k = h.alternate,
      l = h.stateNode;
    if (null !== k && k === d) break;
    5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
    c = c.return;
  }
  0 !== g.length && a.push({
    event: b,
    listeners: g
  });
}
var xf = /\r\n?/g,
  yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b, c) {
  b = zf(b);
  if (zf(a) !== b && c) throw Error(p(425));
}
function Bf() {}
var Cf = null,
  Df = null;
function Ef(a, b) {
  return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0,
  Gf = "function" === typeof clearTimeout ? clearTimeout : void 0,
  Hf = "function" === typeof Promise ? Promise : void 0,
  Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function (a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
function If(a) {
  setTimeout(function () {
    throw a;
  });
}
function Kf(a, b) {
  var c = b,
    d = 0;
  do {
    var e = c.nextSibling;
    a.removeChild(c);
    if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
      if (0 === d) {
        a.removeChild(e);
        bd(b);
        return;
      }
      d--;
    } else "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e;
  } while (c);
  bd(b);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b) break;
    if (8 === b) {
      b = a.data;
      if ("$" === b || "$!" === b || "$?" === b) break;
      if ("/$" === b) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b = 0; a;) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b) return a;
        b--;
      } else "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2),
  Of = "__reactFiber$" + Nf,
  Pf = "__reactProps$" + Nf,
  uf = "__reactContainer$" + Nf,
  of = "__reactEvents$" + Nf,
  Qf = "__reactListeners$" + Nf,
  Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b = a[Of];
  if (b) return b;
  for (var c = a.parentNode; c;) {
    if (b = c[uf] || c[Of]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a;) {
        if (c = a[Of]) return c;
        a = Mf(a);
      }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [],
  Tf = -1;
function Uf(a) {
  return {
    current: a
  };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b;
}
var Vf = {},
  H = Uf(Vf),
  Wf = Uf(!1),
  Xf = Vf;
function Yf(a, b) {
  var c = a.type.contextTypes;
  if (!c) return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
  var e = {},
    f;
  for (f in c) e[f] = b[f];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b, c) {
  if (H.current !== Vf) throw Error(p(168));
  G(H, b);
  G(Wf, c);
}
function bg(a, b, c) {
  var d = a.stateNode;
  b = b.childContextTypes;
  if ("function" !== typeof d.getChildContext) return c;
  d = d.getChildContext();
  for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
  return A({}, c, d);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return !0;
}
function dg(a, b, c) {
  var d = a.stateNode;
  if (!d) throw Error(p(169));
  c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c);
}
var eg = null,
  fg = !1,
  gg = !1;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = !0;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = !0;
    var a = 0,
      b = C;
    try {
      var c = eg;
      for (C = 1; a < c.length; a++) {
        var d = c[a];
        do d = d(!0); while (null !== d);
      }
      eg = null;
      fg = !1;
    } catch (e) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
    } finally {
      C = b, gg = !1;
    }
  }
  return null;
}
var kg = [],
  lg = 0,
  mg = null,
  ng = 0,
  og = [],
  pg = 0,
  qg = null,
  rg = 1,
  sg = "";
function tg(a, b) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b;
}
function ug(a, b, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e = 32 - oc(d) - 1;
  d &= ~(1 << e);
  c += 1;
  var f = 32 - oc(b) + e;
  if (30 < f) {
    var g = e - e % 5;
    f = (d & (1 << g) - 1).toString(32);
    d >>= g;
    e -= g;
    rg = 1 << 32 - oc(b) + e | c << e | d;
    sg = f + a;
  } else rg = 1 << f | c << e | d, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg;) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg;) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null,
  yg = null,
  I = !1,
  zg = null;
function Ag(a, b) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b;
  c.return = a;
  b = a.deletions;
  null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
}
function Cg(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), !0) : !1;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, !0) : !1;
    case 13:
      return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
        id: rg,
        overflow: sg
      } : null, a.memoizedState = {
        dehydrated: b,
        treeContext: c,
        retryLane: 1073741824
      }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, !0) : !1;
    default:
      return !1;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b = yg;
    if (b) {
      var c = b;
      if (!Cg(a, b)) {
        if (Dg(a)) throw Error(p(418));
        b = Lf(c.nextSibling);
        var d = xg;
        b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = !1, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p(418));
      a.flags = a.flags & -4097 | 2;
      I = !1;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return !1;
  if (!I) return Fg(a), I = !0, !1;
  var b;
  (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
  if (b && (b = yg)) {
    if (Dg(a)) throw Hg(), Error(p(418));
    for (; b;) Ag(a, b), b = Lf(b.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a;) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b--;
          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return !0;
}
function Hg() {
  for (var a = yg; a;) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = !1;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b) {
  if (a && a.defaultProps) {
    b = A({}, b);
    a = a.defaultProps;
    for (var c in a) void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
var Mg = Uf(null),
  Ng = null,
  Og = null,
  Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a) {
  var b = Mg.current;
  E(Mg);
  a._currentValue = b;
}
function Sg(a, b, c) {
  for (; null !== a;) {
    var d = a.alternate;
    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
    if (a === c) break;
    a = a.return;
  }
}
function Tg(a, b) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = !0), a.firstContext = null);
}
function Vg(a) {
  var b = a._currentValue;
  if (Pg !== a) if (a = {
    context: a,
    memoizedValue: b,
    next: null
  }, null === Og) {
    if (null === Ng) throw Error(p(308));
    Og = a;
    Ng.dependencies = {
      lanes: 0,
      firstContext: a
    };
  } else Og = Og.next = a;
  return b;
}
var Wg = null;
function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}
function Yg(a, b, c, d) {
  var e = b.interleaved;
  null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
  b.interleaved = c;
  return Zg(a, d);
}
function Zg(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a;) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var $g = !1;
function ah(a) {
  a.updateQueue = {
    baseState: a.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      interleaved: null,
      lanes: 0
    },
    effects: null
  };
}
function bh(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = {
    baseState: a.baseState,
    firstBaseUpdate: a.firstBaseUpdate,
    lastBaseUpdate: a.lastBaseUpdate,
    shared: a.shared,
    effects: a.effects
  });
}
function ch(a, b) {
  return {
    eventTime: a,
    lane: b,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  };
}
function dh(a, b, c) {
  var d = a.updateQueue;
  if (null === d) return null;
  d = d.shared;
  if (0 !== (K & 2)) {
    var e = d.pending;
    null === e ? b.next = b : (b.next = e.next, e.next = b);
    d.pending = b;
    return Zg(a, c);
  }
  e = d.interleaved;
  null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
  d.interleaved = b;
  return Zg(a, c);
}
function eh(a, b, c) {
  b = b.updateQueue;
  if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
function fh(a, b) {
  var c = a.updateQueue,
    d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null,
      f = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g = {
          eventTime: c.eventTime,
          lane: c.lane,
          tag: c.tag,
          payload: c.payload,
          callback: c.callback,
          next: null
        };
        null === f ? e = f = g : f = f.next = g;
        c = c.next;
      } while (null !== c);
      null === f ? e = f = b : f = f.next = b;
    } else e = f = b;
    c = {
      baseState: d.baseState,
      firstBaseUpdate: e,
      lastBaseUpdate: f,
      shared: d.shared,
      effects: d.effects
    };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function gh(a, b, c, d) {
  var e = a.updateQueue;
  $g = !1;
  var f = e.firstBaseUpdate,
    g = e.lastBaseUpdate,
    h = e.shared.pending;
  if (null !== h) {
    e.shared.pending = null;
    var k = h,
      l = k.next;
    k.next = null;
    null === g ? f = l : g.next = l;
    g = k;
    var m = a.alternate;
    null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
  }
  if (null !== f) {
    var q = e.baseState;
    g = 0;
    m = l = k = null;
    h = f;
    do {
      var r = h.lane,
        y = h.eventTime;
      if ((d & r) === r) {
        null !== m && (m = m.next = {
          eventTime: y,
          lane: 0,
          tag: h.tag,
          payload: h.payload,
          callback: h.callback,
          next: null
        });
        a: {
          var n = a,
            t = h;
          r = b;
          y = c;
          switch (t.tag) {
            case 1:
              n = t.payload;
              if ("function" === typeof n) {
                q = n.call(y, q, r);
                break a;
              }
              q = n;
              break a;
            case 3:
              n.flags = n.flags & -65537 | 128;
            case 0:
              n = t.payload;
              r = "function" === typeof n ? n.call(y, q, r) : n;
              if (null === r || void 0 === r) break a;
              q = A({}, q, r);
              break a;
            case 2:
              $g = !0;
          }
        }
        null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
      } else y = {
        eventTime: y,
        lane: r,
        tag: h.tag,
        payload: h.payload,
        callback: h.callback,
        next: null
      }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
      h = h.next;
      if (null === h) if (h = e.shared.pending, null === h) break;else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
    } while (1);
    null === m && (k = q);
    e.baseState = k;
    e.firstBaseUpdate = l;
    e.lastBaseUpdate = m;
    b = e.shared.interleaved;
    if (null !== b) {
      e = b;
      do g |= e.lane, e = e.next; while (e !== b);
    } else null === f && (e.shared.lanes = 0);
    hh |= g;
    a.lanes = g;
    a.memoizedState = q;
  }
}
function ih(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a) for (b = 0; b < a.length; b++) {
    var d = a[b],
      e = d.callback;
    if (null !== e) {
      d.callback = null;
      d = c;
      if ("function" !== typeof e) throw Error(p(191, e));
      e.call(d);
    }
  }
}
var jh = new aa.Component().refs;
function kh(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : A({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var nh = {
  isMounted: function (a) {
    return (a = a._reactInternals) ? Vb(a) === a : !1;
  },
  enqueueSetState: function (a, b, c) {
    a = a._reactInternals;
    var d = L(),
      e = lh(a),
      f = ch(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = dh(a, f, e);
    null !== b && (mh(b, a, e, d), eh(b, a, e));
  },
  enqueueReplaceState: function (a, b, c) {
    a = a._reactInternals;
    var d = L(),
      e = lh(a),
      f = ch(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = dh(a, f, e);
    null !== b && (mh(b, a, e, d), eh(b, a, e));
  },
  enqueueForceUpdate: function (a, b) {
    a = a._reactInternals;
    var c = L(),
      d = lh(a),
      e = ch(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = dh(a, e, d);
    null !== b && (mh(b, a, d, c), eh(b, a, d));
  }
};
function oh(a, b, c, d, e, f, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : !0;
}
function ph(a, b, c) {
  var d = !1,
    e = Vf;
  var f = b.contextType;
  "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
  b = new b(c, f);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = nh;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
  return b;
}
function qh(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && nh.enqueueReplaceState(b, b.state, null);
}
function rh(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = jh;
  ah(a);
  var f = b.contextType;
  "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
  e.state = a.memoizedState;
  f = b.getDerivedStateFromProps;
  "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4194308);
}
function sh(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag) throw Error(p(309));
        var d = c.stateNode;
      }
      if (!d) throw Error(p(147, a));
      var e = d,
        f = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
      b = function (a) {
        var b = e.refs;
        b === jh && (b = e.refs = {});
        null === a ? delete b[f] : b[f] = a;
      };
      b._stringRef = f;
      return b;
    }
    if ("string" !== typeof a) throw Error(p(284));
    if (!c._owner) throw Error(p(290, a));
  }
  return a;
}
function th(a, b) {
  a = Object.prototype.toString.call(b);
  throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
}
function uh(a) {
  var b = a._init;
  return b(a._payload);
}
function vh(a) {
  function b(b, c) {
    if (a) {
      var d = b.deletions;
      null === d ? (b.deletions = [c], b.flags |= 16) : d.push(c);
    }
  }
  function c(c, d) {
    if (!a) return null;
    for (; null !== d;) b(c, d), d = d.sibling;
    return null;
  }
  function d(a, b) {
    for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    return a;
  }
  function e(a, b) {
    a = wh(a, b);
    a.index = 0;
    a.sibling = null;
    return a;
  }
  function f(b, c, d) {
    b.index = d;
    if (!a) return b.flags |= 1048576, c;
    d = b.alternate;
    if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
    b.flags |= 2;
    return c;
  }
  function g(b) {
    a && null === b.alternate && (b.flags |= 2);
    return b;
  }
  function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = xh(c, a.mode, d), b.return = a, b;
    b = e(b, c);
    b.return = a;
    return b;
  }
  function k(a, b, c, d) {
    var f = c.type;
    if (f === ya) return m(a, b, c.props.children, d, c.key);
    if (null !== b && (b.elementType === f || "object" === typeof f && null !== f && f.$$typeof === Ha && uh(f) === b.type)) return d = e(b, c.props), d.ref = sh(a, b, c), d.return = a, d;
    d = yh(c.type, c.key, c.props, null, a.mode, d);
    d.ref = sh(a, b, c);
    d.return = a;
    return d;
  }
  function l(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = zh(c, a.mode, d), b.return = a, b;
    b = e(b, c.children || []);
    b.return = a;
    return b;
  }
  function m(a, b, c, d, f) {
    if (null === b || 7 !== b.tag) return b = Ah(c, a.mode, d, f), b.return = a, b;
    b = e(b, c);
    b.return = a;
    return b;
  }
  function q(a, b, c) {
    if ("string" === typeof b && "" !== b || "number" === typeof b) return b = xh("" + b, a.mode, c), b.return = a, b;
    if ("object" === typeof b && null !== b) {
      switch (b.$$typeof) {
        case va:
          return c = yh(b.type, b.key, b.props, null, a.mode, c), c.ref = sh(a, null, b), c.return = a, c;
        case wa:
          return b = zh(b, a.mode, c), b.return = a, b;
        case Ha:
          var d = b._init;
          return q(a, d(b._payload), c);
      }
      if (eb(b) || Ka(b)) return b = Ah(b, a.mode, c, null), b.return = a, b;
      th(a, b);
    }
    return null;
  }
  function r(a, b, c, d) {
    var e = null !== b ? b.key : null;
    if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
    if ("object" === typeof c && null !== c) {
      switch (c.$$typeof) {
        case va:
          return c.key === e ? k(a, b, c, d) : null;
        case wa:
          return c.key === e ? l(a, b, c, d) : null;
        case Ha:
          return e = c._init, r(a, b, e(c._payload), d);
      }
      if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
      th(a, c);
    }
    return null;
  }
  function y(a, b, c, d, e) {
    if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);
    if ("object" === typeof d && null !== d) {
      switch (d.$$typeof) {
        case va:
          return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);
        case wa:
          return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
        case Ha:
          var f = d._init;
          return y(a, b, c, f(d._payload), e);
      }
      if (eb(d) || Ka(d)) return a = a.get(c) || null, m(b, a, d, e, null);
      th(b, d);
    }
    return null;
  }
  function n(e, g, h, k) {
    for (var l = null, m = null, u = g, w = g = 0, x = null; null !== u && w < h.length; w++) {
      u.index > w ? (x = u, u = null) : x = u.sibling;
      var n = r(e, u, h[w], k);
      if (null === n) {
        null === u && (u = x);
        break;
      }
      a && u && null === n.alternate && b(e, u);
      g = f(n, g, w);
      null === m ? l = n : m.sibling = n;
      m = n;
      u = x;
    }
    if (w === h.length) return c(e, u), I && tg(e, w), l;
    if (null === u) {
      for (; w < h.length; w++) u = q(e, h[w], k), null !== u && (g = f(u, g, w), null === m ? l = u : m.sibling = u, m = u);
      I && tg(e, w);
      return l;
    }
    for (u = d(e, u); w < h.length; w++) x = y(u, e, w, h[w], k), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g = f(x, g, w), null === m ? l = x : m.sibling = x, m = x);
    a && u.forEach(function (a) {
      return b(e, a);
    });
    I && tg(e, w);
    return l;
  }
  function t(e, g, h, k) {
    var l = Ka(h);
    if ("function" !== typeof l) throw Error(p(150));
    h = l.call(h);
    if (null == h) throw Error(p(151));
    for (var u = l = null, m = g, w = g = 0, x = null, n = h.next(); null !== m && !n.done; w++, n = h.next()) {
      m.index > w ? (x = m, m = null) : x = m.sibling;
      var t = r(e, m, n.value, k);
      if (null === t) {
        null === m && (m = x);
        break;
      }
      a && m && null === t.alternate && b(e, m);
      g = f(t, g, w);
      null === u ? l = t : u.sibling = t;
      u = t;
      m = x;
    }
    if (n.done) return c(e, m), I && tg(e, w), l;
    if (null === m) {
      for (; !n.done; w++, n = h.next()) n = q(e, n.value, k), null !== n && (g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
      I && tg(e, w);
      return l;
    }
    for (m = d(e, m); !n.done; w++, n = h.next()) n = y(m, e, w, n.value, k), null !== n && (a && null !== n.alternate && m.delete(null === n.key ? w : n.key), g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
    a && m.forEach(function (a) {
      return b(e, a);
    });
    I && tg(e, w);
    return l;
  }
  function J(a, d, f, h) {
    "object" === typeof f && null !== f && f.type === ya && null === f.key && (f = f.props.children);
    if ("object" === typeof f && null !== f) {
      switch (f.$$typeof) {
        case va:
          a: {
            for (var k = f.key, l = d; null !== l;) {
              if (l.key === k) {
                k = f.type;
                if (k === ya) {
                  if (7 === l.tag) {
                    c(a, l.sibling);
                    d = e(l, f.props.children);
                    d.return = a;
                    a = d;
                    break a;
                  }
                } else if (l.elementType === k || "object" === typeof k && null !== k && k.$$typeof === Ha && uh(k) === l.type) {
                  c(a, l.sibling);
                  d = e(l, f.props);
                  d.ref = sh(a, l, f);
                  d.return = a;
                  a = d;
                  break a;
                }
                c(a, l);
                break;
              } else b(a, l);
              l = l.sibling;
            }
            f.type === ya ? (d = Ah(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = yh(f.type, f.key, f.props, null, a.mode, h), h.ref = sh(a, d, f), h.return = a, a = h);
          }
          return g(a);
        case wa:
          a: {
            for (l = f.key; null !== d;) {
              if (d.key === l) {
                if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                  c(a, d.sibling);
                  d = e(d, f.children || []);
                  d.return = a;
                  a = d;
                  break a;
                } else {
                  c(a, d);
                  break;
                }
              } else b(a, d);
              d = d.sibling;
            }
            d = zh(f, a.mode, h);
            d.return = a;
            a = d;
          }
          return g(a);
        case Ha:
          return l = f._init, J(a, d, l(f._payload), h);
      }
      if (eb(f)) return n(a, d, f, h);
      if (Ka(f)) return t(a, d, f, h);
      th(a, f);
    }
    return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = xh(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
  }
  return J;
}
var Bh = vh(!0),
  Ch = vh(!1),
  Dh = {},
  Eh = Uf(Dh),
  Fh = Uf(Dh),
  Gh = Uf(Dh);
function Hh(a) {
  if (a === Dh) throw Error(p(174));
  return a;
}
function Ih(a, b) {
  G(Gh, b);
  G(Fh, a);
  G(Eh, Dh);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
  }
  E(Eh);
  G(Eh, b);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a) {
  Hh(Gh.current);
  var b = Hh(Eh.current);
  var c = lb(b, a.type);
  b !== c && (G(Fh, a), G(Eh, c));
}
function Lh(a) {
  Fh.current === a && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a) {
  for (var b = a; null !== b;) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 128)) return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a) break;
    for (; null === b.sibling;) {
      if (null === b.return || b.return === a) return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher,
  Qh = ua.ReactCurrentBatchConfig,
  Rh = 0,
  N = null,
  O = null,
  P = null,
  Sh = !1,
  Th = !1,
  Uh = 0,
  Vh = 0;
function Q() {
  throw Error(p(321));
}
function Wh(a, b) {
  if (null === b) return !1;
  for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return !1;
  return !0;
}
function Xh(a, b, c, d, e, f) {
  Rh = f;
  N = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c(d, e);
  if (Th) {
    f = 0;
    do {
      Th = !1;
      Uh = 0;
      if (25 <= f) throw Error(p(301));
      f += 1;
      P = O = null;
      b.updateQueue = null;
      Ph.current = $h;
      a = c(d, e);
    } while (Th);
  }
  Ph.current = ai;
  b = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = !1;
  if (b) throw Error(p(300));
  return a;
}
function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}
function ci() {
  var a = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === P ? N.memoizedState = P = a : P = P.next = a;
  return P;
}
function di() {
  if (null === O) {
    var a = N.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = O.next;
  var b = null === P ? N.memoizedState : P.next;
  if (null !== b) P = b, O = a;else {
    if (null === a) throw Error(p(310));
    O = a;
    a = {
      memoizedState: O.memoizedState,
      baseState: O.baseState,
      baseQueue: O.baseQueue,
      queue: O.queue,
      next: null
    };
    null === P ? N.memoizedState = P = a : P = P.next = a;
  }
  return P;
}
function ei(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function fi(a) {
  var b = di(),
    c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = O,
    e = d.baseQueue,
    f = c.pending;
  if (null !== f) {
    if (null !== e) {
      var g = e.next;
      e.next = f.next;
      f.next = g;
    }
    d.baseQueue = e = f;
    c.pending = null;
  }
  if (null !== e) {
    f = e.next;
    d = d.baseState;
    var h = g = null,
      k = null,
      l = f;
    do {
      var m = l.lane;
      if ((Rh & m) === m) null !== k && (k = k.next = {
        lane: 0,
        action: l.action,
        hasEagerState: l.hasEagerState,
        eagerState: l.eagerState,
        next: null
      }), d = l.hasEagerState ? l.eagerState : a(d, l.action);else {
        var q = {
          lane: m,
          action: l.action,
          hasEagerState: l.hasEagerState,
          eagerState: l.eagerState,
          next: null
        };
        null === k ? (h = k = q, g = d) : k = k.next = q;
        N.lanes |= m;
        hh |= m;
      }
      l = l.next;
    } while (null !== l && l !== f);
    null === k ? g = d : k.next = h;
    He(d, b.memoizedState) || (Ug = !0);
    b.memoizedState = d;
    b.baseState = g;
    b.baseQueue = k;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (null !== a) {
    e = a;
    do f = e.lane, N.lanes |= f, hh |= f, e = e.next; while (e !== a);
  } else null === e && (c.lanes = 0);
  return [b.memoizedState, c.dispatch];
}
function gi(a) {
  var b = di(),
    c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch,
    e = c.pending,
    f = b.memoizedState;
  if (null !== e) {
    c.pending = null;
    var g = e = e.next;
    do f = a(f, g.action), g = g.next; while (g !== e);
    He(f, b.memoizedState) || (Ug = !0);
    b.memoizedState = f;
    null === b.baseQueue && (b.baseState = f);
    c.lastRenderedState = f;
  }
  return [f, d];
}
function hi() {}
function ii(a, b) {
  var c = N,
    d = di(),
    e = b(),
    f = !He(d.memoizedState, e);
  f && (d.memoizedState = e, Ug = !0);
  d = d.queue;
  ji(ki.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b || f || null !== P && P.memoizedState.tag & 1) {
    c.flags |= 2048;
    li(9, mi.bind(null, c, d, e, b), void 0, null);
    if (null === R) throw Error(p(349));
    0 !== (Rh & 30) || ni(c, b, e);
  }
  return e;
}
function ni(a, b, c) {
  a.flags |= 16384;
  a = {
    getSnapshot: b,
    value: c
  };
  b = N.updateQueue;
  null === b ? (b = {
    lastEffect: null,
    stores: null
  }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
}
function mi(a, b, c, d) {
  b.value = c;
  b.getSnapshot = d;
  oi(b) && pi(a);
}
function ki(a, b, c) {
  return c(function () {
    oi(b) && pi(a);
  });
}
function oi(a) {
  var b = a.getSnapshot;
  a = a.value;
  try {
    var c = b();
    return !He(a, c);
  } catch (d) {
    return !0;
  }
}
function pi(a) {
  var b = Zg(a, 1);
  null !== b && mh(b, a, 1, -1);
}
function qi(a) {
  var b = ci();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = {
    pending: null,
    interleaved: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: ei,
    lastRenderedState: a
  };
  b.queue = a;
  a = a.dispatch = ri.bind(null, N, a);
  return [b.memoizedState, a];
}
function li(a, b, c, d) {
  a = {
    tag: a,
    create: b,
    destroy: c,
    deps: d,
    next: null
  };
  b = N.updateQueue;
  null === b ? (b = {
    lastEffect: null,
    stores: null
  }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function si() {
  return di().memoizedState;
}
function ti(a, b, c, d) {
  var e = ci();
  N.flags |= a;
  e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
}
function ui(a, b, c, d) {
  var e = di();
  d = void 0 === d ? null : d;
  var f = void 0;
  if (null !== O) {
    var g = O.memoizedState;
    f = g.destroy;
    if (null !== d && Wh(d, g.deps)) {
      e.memoizedState = li(b, c, f, d);
      return;
    }
  }
  N.flags |= a;
  e.memoizedState = li(1 | b, c, f, d);
}
function vi(a, b) {
  return ti(8390656, 8, a, b);
}
function ji(a, b) {
  return ui(2048, 8, a, b);
}
function wi(a, b) {
  return ui(4, 2, a, b);
}
function xi(a, b) {
  return ui(4, 4, a, b);
}
function yi(a, b) {
  if ("function" === typeof b) return a = a(), b(a), function () {
    b(null);
  };
  if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
    b.current = null;
  };
}
function zi(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b, a), c);
}
function Ai() {}
function Bi(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Wh(b, d[1])) return d[0];
  c.memoizedState = [a, b];
  return a;
}
function Ci(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Wh(b, d[1])) return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function Di(a, b, c) {
  if (0 === (Rh & 21)) return a.baseState && (a.baseState = !1, Ug = !0), a.memoizedState = c;
  He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = !0);
  return b;
}
function Ei(a, b) {
  var c = C;
  C = 0 !== c && 4 > c ? c : 4;
  a(!0);
  var d = Qh.transition;
  Qh.transition = {};
  try {
    a(!1), b();
  } finally {
    C = c, Qh.transition = d;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a, b, c) {
  var d = lh(a);
  c = {
    lane: d,
    action: c,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (Hi(a)) Ii(b, c);else if (c = Yg(a, b, c, d), null !== c) {
    var e = L();
    mh(c, a, d, e);
    Ji(c, b, d);
  }
}
function ri(a, b, c) {
  var d = lh(a),
    e = {
      lane: d,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
  if (Hi(a)) Ii(b, e);else {
    var f = a.alternate;
    if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
      var g = b.lastRenderedState,
        h = f(g, c);
      e.hasEagerState = !0;
      e.eagerState = h;
      if (He(h, g)) {
        var k = b.interleaved;
        null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
        b.interleaved = e;
        return;
      }
    } catch (l) {} finally {}
    c = Yg(a, b, e, d);
    null !== c && (e = L(), mh(c, a, d, e), Ji(c, b, d));
  }
}
function Hi(a) {
  var b = a.alternate;
  return a === N || null !== b && b === N;
}
function Ii(a, b) {
  Th = Sh = !0;
  var c = a.pending;
  null === c ? b.next = b : (b.next = c.next, c.next = b);
  a.pending = b;
}
function Ji(a, b, c) {
  if (0 !== (c & 4194240)) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
var ai = {
    readContext: Vg,
    useCallback: Q,
    useContext: Q,
    useEffect: Q,
    useImperativeHandle: Q,
    useInsertionEffect: Q,
    useLayoutEffect: Q,
    useMemo: Q,
    useReducer: Q,
    useRef: Q,
    useState: Q,
    useDebugValue: Q,
    useDeferredValue: Q,
    useTransition: Q,
    useMutableSource: Q,
    useSyncExternalStore: Q,
    useId: Q,
    unstable_isNewReconciler: !1
  },
  Yh = {
    readContext: Vg,
    useCallback: function (a, b) {
      ci().memoizedState = [a, void 0 === b ? null : b];
      return a;
    },
    useContext: Vg,
    useEffect: vi,
    useImperativeHandle: function (a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ti(4194308, 4, yi.bind(null, b, a), c);
    },
    useLayoutEffect: function (a, b) {
      return ti(4194308, 4, a, b);
    },
    useInsertionEffect: function (a, b) {
      return ti(4, 2, a, b);
    },
    useMemo: function (a, b) {
      var c = ci();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    },
    useReducer: function (a, b, c) {
      var d = ci();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: b
      };
      d.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d.memoizedState, a];
    },
    useRef: function (a) {
      var b = ci();
      a = {
        current: a
      };
      return b.memoizedState = a;
    },
    useState: qi,
    useDebugValue: Ai,
    useDeferredValue: function (a) {
      return ci().memoizedState = a;
    },
    useTransition: function () {
      var a = qi(!1),
        b = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b, a];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (a, b, c) {
      var d = N,
        e = ci();
      if (I) {
        if (void 0 === c) throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(d, b, c);
      }
      e.memoizedState = c;
      var f = {
        value: c,
        getSnapshot: b
      };
      e.queue = f;
      vi(ki.bind(null, d, f, a), [a]);
      d.flags |= 2048;
      li(9, mi.bind(null, d, f, c, b), void 0, null);
      return c;
    },
    useId: function () {
      var a = ci(),
        b = R.identifierPrefix;
      if (I) {
        var c = sg;
        var d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Uh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    },
    unstable_isNewReconciler: !1
  },
  Zh = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: fi,
    useRef: si,
    useState: function () {
      return fi(ei);
    },
    useDebugValue: Ai,
    useDeferredValue: function (a) {
      var b = di();
      return Di(b, O.memoizedState, a);
    },
    useTransition: function () {
      var a = fi(ei)[0],
        b = di().memoizedState;
      return [a, b];
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1
  },
  $h = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: gi,
    useRef: si,
    useState: function () {
      return gi(ei);
    },
    useDebugValue: Ai,
    useDeferredValue: function (a) {
      var b = di();
      return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
    },
    useTransition: function () {
      var a = gi(ei)[0],
        b = di().memoizedState;
      return [a, b];
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1
  };
function Ki(a, b) {
  try {
    var c = "",
      d = b;
    do c += Pa(d), d = d.return; while (d);
    var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }
  return {
    value: a,
    source: b,
    stack: e,
    digest: null
  };
}
function Li(a, b, c) {
  return {
    value: a,
    source: null,
    stack: null != c ? c : null,
    digest: null != b ? b : null
  };
}
function Mi(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function () {
      throw c;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  c.payload = {
    element: null
  };
  var d = b.value;
  c.callback = function () {
    Pi || (Pi = !0, Qi = d);
    Mi(a, b);
  };
  return c;
}
function Ri(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e = b.value;
    c.payload = function () {
      return d(e);
    };
    c.callback = function () {
      Mi(a, b);
    };
  }
  var f = a.stateNode;
  null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
    Mi(a, b);
    "function" !== typeof d && (null === Si ? Si = new Set([this]) : Si.add(this));
    var c = b.stack;
    this.componentDidCatch(b.value, {
      componentStack: null !== c ? c : ""
    });
  });
  return c;
}
function Ti(a, b, c) {
  var d = a.pingCache;
  if (null === d) {
    d = a.pingCache = new Ni();
    var e = new Set();
    d.set(b, e);
  } else e = d.get(b), void 0 === e && (e = new Set(), d.set(b, e));
  e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
}
function Vi(a) {
  do {
    var b;
    if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? !0 : !1 : !0;
    if (b) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Wi(a, b, c, d, e) {
  if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e;
  return a;
}
var Xi = ua.ReactCurrentOwner,
  Ug = !1;
function Yi(a, b, c, d) {
  b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
}
function Zi(a, b, c, d, e) {
  c = c.render;
  var f = b.ref;
  Tg(b, e);
  d = Xh(a, b, c, d, f, e);
  c = bi();
  if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
  I && c && vg(b);
  b.flags |= 1;
  Yi(a, b, d, e);
  return b.child;
}
function aj(a, b, c, d, e) {
  if (null === a) {
    var f = c.type;
    if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d, e);
    a = yh(c.type, null, d, b, b.mode, e);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  f = a.child;
  if (0 === (a.lanes & e)) {
    var g = f.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g, d) && a.ref === b.ref) return $i(a, b, e);
  }
  b.flags |= 1;
  a = wh(f, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function cj(a, b, c, d, e) {
  if (null !== a) {
    var f = a.memoizedProps;
    if (Ie(f, d) && a.ref === b.ref) if (Ug = !1, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = !0);else return b.lanes = a.lanes, $i(a, b, e);
  }
  return dj(a, b, c, d, e);
}
function ej(a, b, c) {
  var d = b.pendingProps,
    e = d.children,
    f = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode) {
    if (0 === (b.mode & 1)) b.memoizedState = {
      baseLanes: 0,
      cachePool: null,
      transitions: null
    }, G(fj, gj), gj |= c;else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
        baseLanes: a,
        cachePool: null,
        transitions: null
      }, b.updateQueue = null, G(fj, gj), gj |= a, null;
      b.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
      };
      d = null !== f ? f.baseLanes : c;
      G(fj, gj);
      gj |= d;
    }
  } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
  Yi(a, b, e, c);
  return b.child;
}
function hj(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
}
function dj(a, b, c, d, e) {
  var f = Zf(c) ? Xf : H.current;
  f = Yf(b, f);
  Tg(b, e);
  c = Xh(a, b, c, d, f, e);
  d = bi();
  if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
  I && d && vg(b);
  b.flags |= 1;
  Yi(a, b, c, e);
  return b.child;
}
function ij(a, b, c, d, e) {
  if (Zf(c)) {
    var f = !0;
    cg(b);
  } else f = !1;
  Tg(b, e);
  if (null === b.stateNode) jj(a, b), ph(b, c, d), rh(b, c, d, e), d = !0;else if (null === a) {
    var g = b.stateNode,
      h = b.memoizedProps;
    g.props = h;
    var k = g.context,
      l = c.contextType;
    "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
    var m = c.getDerivedStateFromProps,
      q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
    q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && qh(b, g, d, l);
    $g = !1;
    var r = b.memoizedState;
    g.state = r;
    gh(b, d, g, e);
    k = b.memoizedState;
    h !== d || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d), k = b.memoizedState), (h = $g || oh(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = !1);
  } else {
    g = b.stateNode;
    bh(a, b);
    h = b.memoizedProps;
    l = b.type === b.elementType ? h : Lg(b.type, h);
    g.props = l;
    q = b.pendingProps;
    r = g.context;
    k = c.contextType;
    "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
    var y = c.getDerivedStateFromProps;
    (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d, k);
    $g = !1;
    r = b.memoizedState;
    g.state = r;
    gh(b, d, g, e);
    var n = b.memoizedState;
    h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d), n = b.memoizedState), (l = $g || oh(b, c, l, d, r, n, k) || !1) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = !1);
  }
  return kj(a, b, c, d, f, e);
}
function kj(a, b, c, d, e, f) {
  hj(a, b);
  var g = 0 !== (b.flags & 128);
  if (!d && !g) return e && dg(b, c, !1), $i(a, b, f);
  d = b.stateNode;
  Xi.current = b;
  var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
  b.memoizedState = d.state;
  e && dg(b, c, !0);
  return b.child;
}
function lj(a) {
  var b = a.stateNode;
  b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, !1);
  Ih(a, b.containerInfo);
}
function mj(a, b, c, d, e) {
  Ig();
  Jg(e);
  b.flags |= 256;
  Yi(a, b, c, d);
  return b.child;
}
var nj = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0
};
function oj(a) {
  return {
    baseLanes: a,
    cachePool: null,
    transitions: null
  };
}
function pj(a, b, c) {
  var d = b.pendingProps,
    e = M.current,
    f = !1,
    g = 0 !== (b.flags & 128),
    h;
  (h = g) || (h = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));
  if (h) f = !0, b.flags &= -129;else if (null === a || null !== a.memoizedState) e |= 1;
  G(M, e & 1);
  if (null === a) {
    Eg(b);
    a = b.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
    g = d.children;
    a = d.fallback;
    return f ? (d = b.mode, f = b.child, g = {
      mode: "hidden",
      children: g
    }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d, 0, null), a = Ah(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
  }
  e = a.memoizedState;
  if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d, h, e, c);
  if (f) {
    f = d.fallback;
    g = b.mode;
    e = a.child;
    h = e.sibling;
    var k = {
      mode: "hidden",
      children: d.children
    };
    0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = wh(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
    null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
    f.return = b;
    d.return = b;
    d.sibling = f;
    b.child = d;
    d = f;
    f = b.child;
    g = a.child.memoizedState;
    g = null === g ? oj(c) : {
      baseLanes: g.baseLanes | c,
      cachePool: null,
      transitions: g.transitions
    };
    f.memoizedState = g;
    f.childLanes = a.childLanes & ~c;
    b.memoizedState = nj;
    return d;
  }
  f = a.child;
  a = f.sibling;
  d = wh(f, {
    mode: "visible",
    children: d.children
  });
  0 === (b.mode & 1) && (d.lanes = c);
  d.return = b;
  d.sibling = null;
  null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
  b.child = d;
  b.memoizedState = null;
  return d;
}
function rj(a, b) {
  b = qj({
    mode: "visible",
    children: b
  }, a.mode, 0, null);
  b.return = a;
  return a.child = b;
}
function tj(a, b, c, d) {
  null !== d && Jg(d);
  Bh(b, a.child, null, c);
  a = rj(b, b.pendingProps.children);
  a.flags |= 2;
  b.memoizedState = null;
  return a;
}
function sj(a, b, c, d, e, f, g) {
  if (c) {
    if (b.flags & 256) return b.flags &= -257, d = Li(Error(p(422))), tj(a, b, g, d);
    if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
    f = d.fallback;
    e = b.mode;
    d = qj({
      mode: "visible",
      children: d.children
    }, e, 0, null);
    f = Ah(f, e, g, null);
    f.flags |= 2;
    d.return = b;
    f.return = b;
    d.sibling = f;
    b.child = d;
    0 !== (b.mode & 1) && Bh(b, a.child, null, g);
    b.child.memoizedState = oj(g);
    b.memoizedState = nj;
    return f;
  }
  if (0 === (b.mode & 1)) return tj(a, b, g, null);
  if ("$!" === e.data) {
    d = e.nextSibling && e.nextSibling.dataset;
    if (d) var h = d.dgst;
    d = h;
    f = Error(p(419));
    d = Li(f, d, void 0);
    return tj(a, b, g, d);
  }
  h = 0 !== (g & a.childLanes);
  if (Ug || h) {
    d = R;
    if (null !== d) {
      switch (g & -g) {
        case 4:
          e = 2;
          break;
        case 16:
          e = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e = 32;
          break;
        case 536870912:
          e = 268435456;
          break;
        default:
          e = 0;
      }
      e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
      0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d, a, e, -1));
    }
    uj();
    d = Li(Error(p(421)));
    return tj(a, b, g, d);
  }
  if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
  a = f.treeContext;
  yg = Lf(e.nextSibling);
  xg = b;
  I = !0;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
  b = rj(b, d.children);
  b.flags |= 4096;
  return b;
}
function wj(a, b, c) {
  a.lanes |= b;
  var d = a.alternate;
  null !== d && (d.lanes |= b);
  Sg(a.return, b, c);
}
function xj(a, b, c, d, e) {
  var f = a.memoizedState;
  null === f ? a.memoizedState = {
    isBackwards: b,
    rendering: null,
    renderingStartTime: 0,
    last: d,
    tail: c,
    tailMode: e
  } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
}
function yj(a, b, c) {
  var d = b.pendingProps,
    e = d.revealOrder,
    f = d.tail;
  Yi(a, b, d.children, c);
  d = M.current;
  if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a;) {
      if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);else if (19 === a.tag) wj(a, c, b);else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b) break a;
      for (; null === a.sibling;) {
        if (null === a.return || a.return === b) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d &= 1;
  }
  G(M, d);
  if (0 === (b.mode & 1)) b.memoizedState = null;else switch (e) {
    case "forwards":
      c = b.child;
      for (e = null; null !== c;) a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
      c = e;
      null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
      xj(b, !1, e, c, f);
      break;
    case "backwards":
      c = null;
      e = b.child;
      for (b.child = null; null !== e;) {
        a = e.alternate;
        if (null !== a && null === Mh(a)) {
          b.child = e;
          break;
        }
        a = e.sibling;
        e.sibling = c;
        c = e;
        e = a;
      }
      xj(b, !0, c, null, f);
      break;
    case "together":
      xj(b, !1, null, null, void 0);
      break;
    default:
      b.memoizedState = null;
  }
  return b.child;
}
function jj(a, b) {
  0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
}
function $i(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  hh |= b.lanes;
  if (0 === (c & b.childLanes)) return null;
  if (null !== a && b.child !== a.child) throw Error(p(153));
  if (null !== b.child) {
    a = b.child;
    c = wh(a, a.pendingProps);
    b.child = c;
    for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
    c.sibling = null;
  }
  return b.child;
}
function zj(a, b, c) {
  switch (b.tag) {
    case 3:
      lj(b);
      Ig();
      break;
    case 5:
      Kh(b);
      break;
    case 1:
      Zf(b.type) && cg(b);
      break;
    case 4:
      Ih(b, b.stateNode.containerInfo);
      break;
    case 10:
      var d = b.type._context,
        e = b.memoizedProps.value;
      G(Mg, d._currentValue);
      d._currentValue = e;
      break;
    case 13:
      d = b.memoizedState;
      if (null !== d) {
        if (null !== d.dehydrated) return G(M, M.current & 1), b.flags |= 128, null;
        if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
        G(M, M.current & 1);
        a = $i(a, b, c);
        return null !== a ? a.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d = 0 !== (c & b.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d) return yj(a, b, c);
        b.flags |= 128;
      }
      e = b.memoizedState;
      null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
      G(M, M.current);
      if (d) break;else return null;
    case 22:
    case 23:
      return b.lanes = 0, ej(a, b, c);
  }
  return $i(a, b, c);
}
var Aj, Bj, Cj, Dj;
Aj = function (a, b) {
  for (var c = b.child; null !== c;) {
    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b) break;
    for (; null === c.sibling;) {
      if (null === c.return || c.return === b) return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Bj = function () {};
Cj = function (a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    Hh(Eh.current);
    var f = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f = [];
        break;
      case "select":
        e = A({}, e, {
          value: void 0
        });
        d = A({}, d, {
          value: void 0
        });
        f = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f = [];
        break;
      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }
    ub(c, d);
    var g;
    c = null;
    for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
      var h = e[l];
      for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
    } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
    for (l in d) {
      var k = d[l];
      h = null != e ? e[l] : void 0;
      if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
        if (h) {
          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
        } else c || (f || (f = []), f.push(l, c)), c = k;
      } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
    }
    c && (f = f || []).push("style", c);
    var l = f;
    if (b.updateQueue = l) b.flags |= 4;
  }
};
Dj = function (a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Ej(a, b) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b = a.tail;
      for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;
      null === c ? a.tail = null : c.sibling = null;
      break;
    case "collapsed":
      c = a.tail;
      for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;
      null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
  }
}
function S(a) {
  var b = null !== a.alternate && a.alternate.child === a.child,
    c = 0,
    d = 0;
  if (b) for (var e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;else for (e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b;
}
function Fj(a, b, c) {
  var d = b.pendingProps;
  wg(b);
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b), null;
    case 1:
      return Zf(b.type) && $f(), S(b), null;
    case 3:
      d = b.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b);
      S(b);
      return null;
    case 5:
      Lh(b);
      var e = Hh(Gh.current);
      c = b.type;
      if (null !== a && null != b.stateNode) Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);else {
        if (!d) {
          if (null === b.stateNode) throw Error(p(166));
          S(b);
          return null;
        }
        a = Hh(Eh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.type;
          var f = b.memoizedProps;
          d[Of] = b;
          d[Pf] = f;
          a = 0 !== (b.mode & 1);
          switch (c) {
            case "dialog":
              D("cancel", d);
              D("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d);
              break;
            case "video":
            case "audio":
              for (e = 0; e < lf.length; e++) D(lf[e], d);
              break;
            case "source":
              D("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D("error", d);
              D("load", d);
              break;
            case "details":
              D("toggle", d);
              break;
            case "input":
              Za(d, f);
              D("invalid", d);
              break;
            case "select":
              d._wrapperState = {
                wasMultiple: !!f.multiple
              };
              D("invalid", d);
              break;
            case "textarea":
              hb(d, f), D("invalid", d);
          }
          ub(c, f);
          e = null;
          for (var g in f) if (f.hasOwnProperty(g)) {
            var h = f[g];
            "children" === g ? "string" === typeof h ? d.textContent !== h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
          }
          switch (c) {
            case "input":
              Va(d);
              db(d, f, !0);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f.onClick && (d.onclick = Bf);
          }
          d = e;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
            is: d.is
          }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[Of] = b;
          a[Pf] = d;
          Aj(a, b, !1, !1);
          b.stateNode = a;
          a: {
            g = vb(c, d);
            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e = d;
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], a);
                e = d;
                break;
              case "source":
                D("error", a);
                e = d;
                break;
              case "img":
              case "image":
              case "link":
                D("error", a);
                D("load", a);
                e = d;
                break;
              case "details":
                D("toggle", a);
                e = d;
                break;
              case "input":
                Za(a, d);
                e = Ya(a, d);
                D("invalid", a);
                break;
              case "option":
                e = d;
                break;
              case "select":
                a._wrapperState = {
                  wasMultiple: !!d.multiple
                };
                e = A({}, d, {
                  value: void 0
                });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d);
                e = gb(a, d);
                D("invalid", a);
                break;
              default:
                e = d;
            }
            ub(c, e);
            h = e;
            for (f in h) if (h.hasOwnProperty(f)) {
              var k = h[f];
              "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
            }
            switch (c) {
              case "input":
                Va(a);
                db(a, d, !1);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f = d.value;
                null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);
                break;
              default:
                "function" === typeof e.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = !0;
                break a;
              default:
                d = !1;
            }
          }
          d && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      }
      S(b);
      return null;
    case 6:
      if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d);else {
        if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
        c = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.memoizedProps;
          d[Of] = b;
          if (f = d.nodeValue !== c) if (a = xg, null !== a) switch (a.tag) {
            case 3:
              Af(d.nodeValue, c, 0 !== (a.mode & 1));
              break;
            case 5:
              !0 !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
          }
          f && (b.flags |= 4);
        } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
      }
      S(b);
      return null;
    case 13:
      E(M);
      d = b.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = !1;else if (f = Gg(b), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f) throw Error(p(318));
            f = b.memoizedState;
            f = null !== f ? f.dehydrated : null;
            if (!f) throw Error(p(317));
            f[Of] = b;
          } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
          S(b);
          f = !1;
        } else null !== zg && (Gj(zg), zg = null), f = !0;
        if (!f) return b.flags & 65536 ? b : null;
      }
      if (0 !== (b.flags & 128)) return b.lanes = c, b;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b.updateQueue && (b.flags |= 4);
      S(b);
      return null;
    case 4:
      return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
    case 10:
      return Rg(b.type._context), S(b), null;
    case 17:
      return Zf(b.type) && $f(), S(b), null;
    case 19:
      E(M);
      f = b.memoizedState;
      if (null === f) return S(b), null;
      d = 0 !== (b.flags & 128);
      g = f.rendering;
      if (null === g) {
        if (d) Ej(f, !1);else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a;) {
            g = Mh(a);
            if (null !== g) {
              b.flags |= 128;
              Ej(f, !1);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;
              for (c = b.child; null !== c;) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                lanes: a.lanes,
                firstContext: a.firstContext
              }), c = c.sibling;
              G(M, M.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f.tail && B() > Hj && (b.flags |= 128, d = !0, Ej(f, !1), b.lanes = 4194304);
        }
      } else {
        if (!d) if (a = Mh(g), null !== a) {
          if (b.flags |= 128, d = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, !0), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
        } else 2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = !0, Ej(f, !1), b.lanes = 4194304);
        f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
      }
      if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? c & 1 | 2 : c & 1), b;
      S(b);
      return null;
    case 22:
    case 23:
      return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p(156, b.tag));
}
function Jj(a, b) {
  wg(b);
  switch (b.tag) {
    case 1:
      return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
    case 5:
      return Lh(b), null;
    case 13:
      E(M);
      a = b.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b.alternate) throw Error(p(340));
        Ig();
      }
      a = b.flags;
      return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = !1,
  U = !1,
  Lj = "function" === typeof WeakSet ? WeakSet : Set,
  V = null;
function Mj(a, b) {
  var c = a.ref;
  if (null !== c) if ("function" === typeof c) try {
    c(null);
  } catch (d) {
    W(a, b, d);
  } else c.current = null;
}
function Nj(a, b, c) {
  try {
    c();
  } catch (d) {
    W(a, b, d);
  }
}
var Oj = !1;
function Pj(a, b) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c = {
      start: a.selectionStart,
      end: a.selectionEnd
    };else a: {
      c = (c = a.ownerDocument) && c.defaultView || window;
      var d = c.getSelection && c.getSelection();
      if (d && 0 !== d.rangeCount) {
        c = d.anchorNode;
        var e = d.anchorOffset,
          f = d.focusNode;
        d = d.focusOffset;
        try {
          c.nodeType, f.nodeType;
        } catch (F) {
          c = null;
          break a;
        }
        var g = 0,
          h = -1,
          k = -1,
          l = 0,
          m = 0,
          q = a,
          r = null;
        b: for (;;) {
          for (var y;;) {
            q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
            q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
            3 === q.nodeType && (g += q.nodeValue.length);
            if (null === (y = q.firstChild)) break;
            r = q;
            q = y;
          }
          for (;;) {
            if (q === a) break b;
            r === c && ++l === e && (h = g);
            r === f && ++m === d && (k = g);
            if (null !== (y = q.nextSibling)) break;
            q = r;
            r = q.parentNode;
          }
          q = y;
        }
        c = -1 === h || -1 === k ? null : {
          start: h,
          end: k
        };
      } else c = null;
    }
    c = c || {
      start: 0,
      end: 0
    };
  } else c = null;
  Df = {
    focusedElem: a,
    selectionRange: c
  };
  dd = !1;
  for (V = b; null !== V;) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;else for (; null !== V;) {
    b = V;
    try {
      var n = b.alternate;
      if (0 !== (b.flags & 1024)) switch (b.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n) {
            var t = n.memoizedProps,
              J = n.memoizedState,
              x = b.stateNode,
              w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
            x.__reactInternalSnapshotBeforeUpdate = w;
          }
          break;
        case 3:
          var u = b.stateNode.containerInfo;
          1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p(163));
      }
    } catch (F) {
      W(b, b.return, F);
    }
    a = b.sibling;
    if (null !== a) {
      a.return = b.return;
      V = a;
      break;
    }
    V = b.return;
  }
  n = Oj;
  Oj = !1;
  return n;
}
function Qj(a, b, c) {
  var d = b.updateQueue;
  d = null !== d ? d.lastEffect : null;
  if (null !== d) {
    var e = d = d.next;
    do {
      if ((e.tag & a) === a) {
        var f = e.destroy;
        e.destroy = void 0;
        void 0 !== f && Nj(b, c, f);
      }
      e = e.next;
    } while (e !== d);
  }
}
function Rj(a, b) {
  b = b.updateQueue;
  b = null !== b ? b.lastEffect : null;
  if (null !== b) {
    var c = b = b.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b);
  }
}
function Sj(a) {
  var b = a.ref;
  if (null !== b) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b ? b(a) : b.current = a;
  }
}
function Tj(a) {
  var b = a.alternate;
  null !== b && (a.alternate = null, Tj(b));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Vj(a) {
  a: for (;;) {
    for (; null === a.sibling;) {
      if (null === a.return || Uj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag;) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Wj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a;) Wj(a, b, c), a = a.sibling;
}
function Xj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a;) Xj(a, b, c), a = a.sibling;
}
var X = null,
  Yj = !1;
function Zj(a, b, c) {
  for (c = c.child; null !== c;) ak(a, b, c), c = c.sibling;
}
function ak(a, b, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c);
  } catch (h) {}
  switch (c.tag) {
    case 5:
      U || Mj(c, b);
    case 6:
      var d = X,
        e = Yj;
      X = null;
      Zj(a, b, c);
      X = d;
      Yj = e;
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
      break;
    case 4:
      d = X;
      e = Yj;
      X = c.stateNode.containerInfo;
      Yj = !0;
      Zj(a, b, c);
      X = d;
      Yj = e;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e = d = d.next;
        do {
          var f = e,
            g = f.destroy;
          f = f.tag;
          void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
          e = e.next;
        } while (e !== d);
      }
      Zj(a, b, c);
      break;
    case 1:
      if (!U && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
        d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
      } catch (h) {
        W(c, b, h);
      }
      Zj(a, b, c);
      break;
    case 21:
      Zj(a, b, c);
      break;
    case 22:
      c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Zj(a, b, c), U = d) : Zj(a, b, c);
      break;
    default:
      Zj(a, b, c);
  }
}
function bk(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Lj());
    b.forEach(function (b) {
      var d = ck.bind(null, a, b);
      c.has(b) || (c.add(b), b.then(d, d));
    });
  }
}
function dk(a, b) {
  var c = b.deletions;
  if (null !== c) for (var d = 0; d < c.length; d++) {
    var e = c[d];
    try {
      var f = a,
        g = b,
        h = g;
      a: for (; null !== h;) {
        switch (h.tag) {
          case 5:
            X = h.stateNode;
            Yj = !1;
            break a;
          case 3:
            X = h.stateNode.containerInfo;
            Yj = !0;
            break a;
          case 4:
            X = h.stateNode.containerInfo;
            Yj = !0;
            break a;
        }
        h = h.return;
      }
      if (null === X) throw Error(p(160));
      ak(f, g, e);
      X = null;
      Yj = !1;
      var k = e.alternate;
      null !== k && (k.return = null);
      e.return = null;
    } catch (l) {
      W(e, b, l);
    }
  }
  if (b.subtreeFlags & 12854) for (b = b.child; null !== b;) ek(b, a), b = b.sibling;
}
function ek(a, b) {
  var c = a.alternate,
    d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b, a);
      fk(a);
      if (d & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t) {
          W(a, a.return, t);
        }
        try {
          Qj(5, a, a.return);
        } catch (t) {
          W(a, a.return, t);
        }
      }
      break;
    case 1:
      dk(b, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      break;
    case 5:
      dk(b, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      if (a.flags & 32) {
        var e = a.stateNode;
        try {
          ob(e, "");
        } catch (t) {
          W(a, a.return, t);
        }
      }
      if (d & 4 && (e = a.stateNode, null != e)) {
        var f = a.memoizedProps,
          g = null !== c ? c.memoizedProps : f,
          h = a.type,
          k = a.updateQueue;
        a.updateQueue = null;
        if (null !== k) try {
          "input" === h && "radio" === f.type && null != f.name && ab(e, f);
          vb(h, g);
          var l = vb(h, f);
          for (g = 0; g < k.length; g += 2) {
            var m = k[g],
              q = k[g + 1];
            "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
          }
          switch (h) {
            case "input":
              bb(e, f);
              break;
            case "textarea":
              ib(e, f);
              break;
            case "select":
              var r = e._wrapperState.wasMultiple;
              e._wrapperState.wasMultiple = !!f.multiple;
              var y = f.value;
              null != y ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, !0) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
          }
          e[Pf] = f;
        } catch (t) {
          W(a, a.return, t);
        }
      }
      break;
    case 6:
      dk(b, a);
      fk(a);
      if (d & 4) {
        if (null === a.stateNode) throw Error(p(162));
        e = a.stateNode;
        f = a.memoizedProps;
        try {
          e.nodeValue = f;
        } catch (t) {
          W(a, a.return, t);
        }
      }
      break;
    case 3:
      dk(b, a);
      fk(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
        bd(b.containerInfo);
      } catch (t) {
        W(a, a.return, t);
      }
      break;
    case 4:
      dk(b, a);
      fk(a);
      break;
    case 13:
      dk(b, a);
      fk(a);
      e = a.child;
      e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
      d & 4 && bk(a);
      break;
    case 22:
      m = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U = (l = U) || m, dk(b, a), U = l) : dk(b, a);
      fk(a);
      if (d & 8192) {
        l = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m;) {
          for (q = V = m; null !== V;) {
            r = V;
            y = r.child;
            switch (r.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Qj(4, r, r.return);
                break;
              case 1:
                Mj(r, r.return);
                var n = r.stateNode;
                if ("function" === typeof n.componentWillUnmount) {
                  d = r;
                  c = r.return;
                  try {
                    b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                  } catch (t) {
                    W(d, c, t);
                  }
                }
                break;
              case 5:
                Mj(r, r.return);
                break;
              case 22:
                if (null !== r.memoizedState) {
                  hk(q);
                  continue;
                }
            }
            null !== y ? (y.return = r, V = y) : hk(q);
          }
          m = m.sibling;
        }
        a: for (m = null, q = a;;) {
          if (5 === q.tag) {
            if (null === m) {
              m = q;
              try {
                e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
              } catch (t) {
                W(a, a.return, t);
              }
            }
          } else if (6 === q.tag) {
            if (null === m) try {
              q.stateNode.nodeValue = l ? "" : q.memoizedProps;
            } catch (t) {
              W(a, a.return, t);
            }
          } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
            q.child.return = q;
            q = q.child;
            continue;
          }
          if (q === a) break a;
          for (; null === q.sibling;) {
            if (null === q.return || q.return === a) break a;
            m === q && (m = null);
            q = q.return;
          }
          m === q && (m = null);
          q.sibling.return = q.return;
          q = q.sibling;
        }
      }
      break;
    case 19:
      dk(b, a);
      fk(a);
      d & 4 && bk(a);
      break;
    case 21:
      break;
    default:
      dk(b, a), fk(a);
  }
}
function fk(a) {
  var b = a.flags;
  if (b & 2) {
    try {
      a: {
        for (var c = a.return; null !== c;) {
          if (Uj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p(160));
      }
      switch (d.tag) {
        case 5:
          var e = d.stateNode;
          d.flags & 32 && (ob(e, ""), d.flags &= -33);
          var f = Vj(a);
          Xj(a, f, e);
          break;
        case 3:
        case 4:
          var g = d.stateNode.containerInfo,
            h = Vj(a);
          Wj(a, h, g);
          break;
        default:
          throw Error(p(161));
      }
    } catch (k) {
      W(a, a.return, k);
    }
    a.flags &= -3;
  }
  b & 4096 && (a.flags &= -4097);
}
function ik(a, b, c) {
  V = a;
  jk(a, b, c);
}
function jk(a, b, c) {
  for (var d = 0 !== (a.mode & 1); null !== V;) {
    var e = V,
      f = e.child;
    if (22 === e.tag && d) {
      var g = null !== e.memoizedState || Kj;
      if (!g) {
        var h = e.alternate,
          k = null !== h && null !== h.memoizedState || U;
        h = Kj;
        var l = U;
        Kj = g;
        if ((U = k) && !l) for (V = e; null !== V;) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
        for (; null !== f;) V = f, jk(f, b, c), f = f.sibling;
        V = e;
        Kj = h;
        U = l;
      }
      lk(a, b, c);
    } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a, b, c);
  }
}
function lk(a) {
  for (; null !== V;) {
    var b = V;
    if (0 !== (b.flags & 8772)) {
      var c = b.alternate;
      try {
        if (0 !== (b.flags & 8772)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            U || Rj(5, b);
            break;
          case 1:
            var d = b.stateNode;
            if (b.flags & 4 && !U) if (null === c) d.componentDidMount();else {
              var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
              d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
            }
            var f = b.updateQueue;
            null !== f && ih(b, f, d);
            break;
          case 3:
            var g = b.updateQueue;
            if (null !== g) {
              c = null;
              if (null !== b.child) switch (b.child.tag) {
                case 5:
                  c = b.child.stateNode;
                  break;
                case 1:
                  c = b.child.stateNode;
              }
              ih(b, g, c);
            }
            break;
          case 5:
            var h = b.stateNode;
            if (null === c && b.flags & 4) {
              c = h;
              var k = b.memoizedProps;
              switch (b.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k.autoFocus && c.focus();
                  break;
                case "img":
                  k.src && (c.src = k.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b.memoizedState) {
              var l = b.alternate;
              if (null !== l) {
                var m = l.memoizedState;
                if (null !== m) {
                  var q = m.dehydrated;
                  null !== q && bd(q);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p(163));
        }
        U || b.flags & 512 && Sj(b);
      } catch (r) {
        W(b, b.return, r);
      }
    }
    if (b === a) {
      V = null;
      break;
    }
    c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function hk(a) {
  for (; null !== V;) {
    var b = V;
    if (b === a) {
      V = null;
      break;
    }
    var c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function kk(a) {
  for (; null !== V;) {
    var b = V;
    try {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          var c = b.return;
          try {
            Rj(4, b);
          } catch (k) {
            W(b, c, k);
          }
          break;
        case 1:
          var d = b.stateNode;
          if ("function" === typeof d.componentDidMount) {
            var e = b.return;
            try {
              d.componentDidMount();
            } catch (k) {
              W(b, e, k);
            }
          }
          var f = b.return;
          try {
            Sj(b);
          } catch (k) {
            W(b, f, k);
          }
          break;
        case 5:
          var g = b.return;
          try {
            Sj(b);
          } catch (k) {
            W(b, g, k);
          }
      }
    } catch (k) {
      W(b, b.return, k);
    }
    if (b === a) {
      V = null;
      break;
    }
    var h = b.sibling;
    if (null !== h) {
      h.return = b.return;
      V = h;
      break;
    }
    V = b.return;
  }
}
var mk = Math.ceil,
  nk = ua.ReactCurrentDispatcher,
  ok = ua.ReactCurrentOwner,
  pk = ua.ReactCurrentBatchConfig,
  K = 0,
  R = null,
  Y = null,
  Z = 0,
  gj = 0,
  fj = Uf(0),
  T = 0,
  qk = null,
  hh = 0,
  rk = 0,
  sk = 0,
  tk = null,
  uk = null,
  gk = 0,
  Hj = Infinity,
  vk = null,
  Pi = !1,
  Qi = null,
  Si = null,
  wk = !1,
  xk = null,
  yk = 0,
  zk = 0,
  Ak = null,
  Bk = -1,
  Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function mh(a, b, c, d) {
  if (50 < zk) throw zk = 0, Ak = null, Error(p(185));
  Ac(a, c, d);
  if (0 === (K & 2) || a !== R) a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a, b) {
  var c = a.callbackNode;
  wc(a, b);
  var d = uc(a, a === R ? Z : 0);
  if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;else if (b = d & -d, a.callbackPriority !== b) {
    null != c && bc(c);
    if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function () {
      0 === (K & 6) && jg();
    }), c = null;else {
      switch (Dc(d)) {
        case 1:
          c = fc;
          break;
        case 4:
          c = gc;
          break;
        case 16:
          c = hc;
          break;
        case 536870912:
          c = jc;
          break;
        default:
          c = hc;
      }
      c = Gk(c, Hk.bind(null, a));
    }
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Hk(a, b) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6)) throw Error(p(327));
  var c = a.callbackNode;
  if (Ik() && a.callbackNode !== c) return null;
  var d = uc(a, a === R ? Z : 0);
  if (0 === d) return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Jk(a, d);else {
    b = d;
    var e = K;
    K |= 2;
    var f = Kk();
    if (R !== a || Z !== b) vk = null, Hj = B() + 500, Lk(a, b);
    do try {
      Mk();
      break;
    } catch (h) {
      Nk(a, h);
    } while (1);
    Qg();
    nk.current = f;
    K = e;
    null !== Y ? b = 0 : (R = null, Z = 0, b = T);
  }
  if (0 !== b) {
    2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
    if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
    if (6 === b) Dk(a, d);else {
      e = a.current.alternate;
      if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
      a.finishedWork = e;
      a.finishedLanes = d;
      switch (b) {
        case 0:
        case 1:
          throw Error(p(345));
        case 2:
          Qk(a, uk, vk);
          break;
        case 3:
          Dk(a, d);
          if ((d & 130023424) === d && (b = gk + 500 - B(), 10 < b)) {
            if (0 !== uc(a, 0)) break;
            e = a.suspendedLanes;
            if ((e & d) !== d) {
              L();
              a.pingedLanes |= a.suspendedLanes & e;
              break;
            }
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 4:
          Dk(a, d);
          if ((d & 4194240) === d) break;
          b = a.eventTimes;
          for (e = -1; 0 < d;) {
            var g = 31 - oc(d);
            f = 1 << g;
            g = b[g];
            g > e && (e = g);
            d &= ~f;
          }
          d = e;
          d = B() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 5:
          Qk(a, uk, vk);
          break;
        default:
          throw Error(p(329));
      }
    }
  }
  Ek(a, B());
  return a.callbackNode === c ? Hk.bind(null, a) : null;
}
function Ok(a, b) {
  var c = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
  a = Jk(a, b);
  2 !== a && (b = uk, uk = c, null !== b && Gj(b));
  return a;
}
function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}
function Pk(a) {
  for (var b = a;;) {
    if (b.flags & 16384) {
      var c = b.updateQueue;
      if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
        var e = c[d],
          f = e.getSnapshot;
        e = e.value;
        try {
          if (!He(f(), e)) return !1;
        } catch (g) {
          return !1;
        }
      }
    }
    c = b.child;
    if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;else {
      if (b === a) break;
      for (; null === b.sibling;) {
        if (null === b.return || b.return === a) return !0;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return !0;
}
function Dk(a, b) {
  b &= ~sk;
  b &= ~rk;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b;) {
    var c = 31 - oc(b),
      d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Fk(a) {
  if (0 !== (K & 6)) throw Error(p(327));
  Ik();
  var b = uc(a, 0);
  if (0 === (b & 1)) return Ek(a, B()), null;
  var c = Jk(a, b);
  if (0 !== a.tag && 2 === c) {
    var d = xc(a);
    0 !== d && (b = d, c = Ok(a, d));
  }
  if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
  if (6 === c) throw Error(p(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Qk(a, uk, vk);
  Ek(a, B());
  return null;
}
function Rk(a, b) {
  var c = K;
  K |= 1;
  try {
    return a(b);
  } finally {
    K = c, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b = K;
  K |= 1;
  var c = pk.transition,
    d = C;
  try {
    if (pk.transition = null, C = 1, a) return a();
  } finally {
    C = d, pk.transition = c, K = b, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y) for (c = Y.return; null !== c;) {
    var d = c;
    wg(d);
    switch (d.tag) {
      case 1:
        d = d.type.childContextTypes;
        null !== d && void 0 !== d && $f();
        break;
      case 3:
        Jh();
        E(Wf);
        E(H);
        Oh();
        break;
      case 5:
        Lh(d);
        break;
      case 4:
        Jh();
        break;
      case 13:
        E(M);
        break;
      case 19:
        E(M);
        break;
      case 10:
        Rg(d.type._context);
        break;
      case 22:
      case 23:
        Ij();
    }
    c = c.return;
  }
  R = a;
  Y = a = wh(a.current, null);
  Z = gj = b;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b = 0; b < Wg.length; b++) if (c = Wg[b], d = c.interleaved, null !== d) {
      c.interleaved = null;
      var e = d.next,
        f = c.pending;
      if (null !== f) {
        var g = f.next;
        f.next = e;
        d.next = g;
      }
      c.pending = d;
    }
    Wg = null;
  }
  return a;
}
function Nk(a, b) {
  do {
    var c = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d = N.memoizedState; null !== d;) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }
        Sh = !1;
      }
      Rh = 0;
      P = O = N = null;
      Th = !1;
      Uh = 0;
      ok.current = null;
      if (null === c || null === c.return) {
        T = 1;
        qk = b;
        Y = null;
        break;
      }
      a: {
        var f = a,
          g = c.return,
          h = c,
          k = b;
        b = Z;
        h.flags |= 32768;
        if (null !== k && "object" === typeof k && "function" === typeof k.then) {
          var l = k,
            m = h,
            q = m.tag;
          if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
            var r = m.alternate;
            r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
          }
          var y = Vi(g);
          if (null !== y) {
            y.flags &= -257;
            Wi(y, g, h, f, b);
            y.mode & 1 && Ti(f, l, b);
            b = y;
            k = l;
            var n = b.updateQueue;
            if (null === n) {
              var t = new Set();
              t.add(k);
              b.updateQueue = t;
            } else n.add(k);
            break a;
          } else {
            if (0 === (b & 1)) {
              Ti(f, l, b);
              uj();
              break a;
            }
            k = Error(p(426));
          }
        } else if (I && h.mode & 1) {
          var J = Vi(g);
          if (null !== J) {
            0 === (J.flags & 65536) && (J.flags |= 256);
            Wi(J, g, h, f, b);
            Jg(Ki(k, h));
            break a;
          }
        }
        f = k = Ki(k, h);
        4 !== T && (T = 2);
        null === tk ? tk = [f] : tk.push(f);
        f = g;
        do {
          switch (f.tag) {
            case 3:
              f.flags |= 65536;
              b &= -b;
              f.lanes |= b;
              var x = Oi(f, k, b);
              fh(f, x);
              break a;
            case 1:
              h = k;
              var w = f.type,
                u = f.stateNode;
              if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var F = Ri(f, h, b);
                fh(f, F);
                break a;
              }
          }
          f = f.return;
        } while (null !== f);
      }
      Tk(c);
    } catch (na) {
      b = na;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}
function uj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a, b) {
  var c = K;
  K |= 2;
  var d = Kk();
  if (R !== a || Z !== b) vk = null, Lk(a, b);
  do try {
    Uk();
    break;
  } catch (e) {
    Nk(a, e);
  } while (1);
  Qg();
  K = c;
  nk.current = d;
  if (null !== Y) throw Error(p(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y;) Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc();) Vk(Y);
}
function Vk(a) {
  var b = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b ? Tk(a) : Y = b;
  ok.current = null;
}
function Tk(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 32768)) {
      if (c = Fj(c, b, gj), null !== c) {
        Y = c;
        return;
      }
    } else {
      c = Jj(c, b);
      if (null !== c) {
        c.flags &= 32767;
        Y = c;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;else {
        T = 6;
        Y = null;
        return;
      }
    }
    b = b.sibling;
    if (null !== b) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (null !== b);
  0 === T && (T = 5);
}
function Qk(a, b, c) {
  var d = C,
    e = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a, b, c, d);
  } finally {
    pk.transition = e, C = d;
  }
  return null;
}
function Xk(a, b, c, d) {
  do Ik(); while (null !== xk);
  if (0 !== (K & 6)) throw Error(p(327));
  c = a.finishedWork;
  var e = a.finishedLanes;
  if (null === c) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current) throw Error(p(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f = c.lanes | c.childLanes;
  Bc(a, f);
  a === R && (Y = R = null, Z = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = !0, Gk(hc, function () {
    Ik();
    return null;
  }));
  f = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f) {
    f = pk.transition;
    pk.transition = null;
    var g = C;
    C = 1;
    var h = K;
    K |= 4;
    ok.current = null;
    Pj(a, c);
    ek(c, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    ik(c, a, e);
    dc();
    K = h;
    C = g;
    pk.transition = f;
  } else a.current = c;
  wk && (wk = !1, xk = a, yk = e);
  f = a.pendingLanes;
  0 === f && (Si = null);
  mc(c.stateNode, d);
  Ek(a, B());
  if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, {
    componentStack: e.stack,
    digest: e.digest
  });
  if (Pi) throw Pi = !1, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f = a.pendingLanes;
  0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a = Dc(yk),
      b = pk.transition,
      c = C;
    try {
      pk.transition = null;
      C = 16 > a ? 16 : a;
      if (null === xk) var d = !1;else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6)) throw Error(p(331));
        var e = K;
        K |= 4;
        for (V = a.current; null !== V;) {
          var f = V,
            g = f.child;
          if (0 !== (V.flags & 16)) {
            var h = f.deletions;
            if (null !== h) {
              for (var k = 0; k < h.length; k++) {
                var l = h[k];
                for (V = l; null !== V;) {
                  var m = V;
                  switch (m.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m, f);
                  }
                  var q = m.child;
                  if (null !== q) q.return = m, V = q;else for (; null !== V;) {
                    m = V;
                    var r = m.sibling,
                      y = m.return;
                    Tj(m);
                    if (m === l) {
                      V = null;
                      break;
                    }
                    if (null !== r) {
                      r.return = y;
                      V = r;
                      break;
                    }
                    V = y;
                  }
                }
              }
              var n = f.alternate;
              if (null !== n) {
                var t = n.child;
                if (null !== t) {
                  n.child = null;
                  do {
                    var J = t.sibling;
                    t.sibling = null;
                    t = J;
                  } while (null !== t);
                }
              }
              V = f;
            }
          }
          if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;else b: for (; null !== V;) {
            f = V;
            if (0 !== (f.flags & 2048)) switch (f.tag) {
              case 0:
              case 11:
              case 15:
                Qj(9, f, f.return);
            }
            var x = f.sibling;
            if (null !== x) {
              x.return = f.return;
              V = x;
              break b;
            }
            V = f.return;
          }
        }
        var w = a.current;
        for (V = w; null !== V;) {
          g = V;
          var u = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;else b: for (g = w; null !== V;) {
            h = V;
            if (0 !== (h.flags & 2048)) try {
              switch (h.tag) {
                case 0:
                case 11:
                case 15:
                  Rj(9, h);
              }
            } catch (na) {
              W(h, h.return, na);
            }
            if (h === g) {
              V = null;
              break b;
            }
            var F = h.sibling;
            if (null !== F) {
              F.return = h.return;
              V = F;
              break b;
            }
            V = h.return;
          }
        }
        K = e;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {}
        d = !0;
      }
      return d;
    } finally {
      C = c, pk.transition = b;
    }
  }
  return !1;
}
function Yk(a, b, c) {
  b = Ki(c, b);
  b = Oi(a, b, 1);
  a = dh(a, b, 1);
  b = L();
  null !== a && (Ac(a, 1, b), Ek(a, b));
}
function W(a, b, c) {
  if (3 === a.tag) Yk(a, a, c);else for (; null !== b;) {
    if (3 === b.tag) {
      Yk(b, a, c);
      break;
    } else if (1 === b.tag) {
      var d = b.stateNode;
      if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
        a = Ki(c, a);
        a = Ri(b, a, 1);
        b = dh(b, a, 1);
        a = L();
        null !== b && (Ac(b, 1, a), Ek(b, a));
        break;
      }
    }
    b = b.return;
  }
}
function Ui(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = L();
  a.pingedLanes |= a.suspendedLanes & c;
  R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
  Ek(a, b);
}
function Zk(a, b) {
  0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = L();
  a = Zg(a, b);
  null !== a && (Ac(a, b, c), Ek(a, c));
}
function vj(a) {
  var b = a.memoizedState,
    c = 0;
  null !== b && (c = b.retryLane);
  Zk(a, c);
}
function ck(a, b) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e = a.memoizedState;
      null !== e && (c = e.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p(314));
  }
  null !== d && d.delete(b);
  Zk(a, c);
}
var Wk;
Wk = function (a, b, c) {
  if (null !== a) {
    if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = !0;else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = !1, zj(a, b, c);
      Ug = 0 !== (a.flags & 131072) ? !0 : !1;
    }
  } else Ug = !1, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      var d = b.type;
      jj(a, b);
      a = b.pendingProps;
      var e = Yf(b, H.current);
      Tg(b, c);
      e = Xh(null, b, d, a, e, c);
      var f = bi();
      b.flags |= 1;
      "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = !0, cg(b)) : f = !1, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, !0, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child);
      return b;
    case 16:
      d = b.elementType;
      a: {
        jj(a, b);
        a = b.pendingProps;
        e = d._init;
        d = e(d._payload);
        b.type = d;
        e = b.tag = $k(d);
        a = Lg(d, a);
        switch (e) {
          case 0:
            b = dj(null, b, d, a, c);
            break a;
          case 1:
            b = ij(null, b, d, a, c);
            break a;
          case 11:
            b = Zi(null, b, d, a, c);
            break a;
          case 14:
            b = aj(null, b, d, Lg(d.type, a), c);
            break a;
        }
        throw Error(p(306, d, ""));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);
    case 3:
      a: {
        lj(b);
        if (null === a) throw Error(p(387));
        d = b.pendingProps;
        f = b.memoizedState;
        e = f.element;
        bh(a, b);
        gh(b, d, null, c);
        var g = b.memoizedState;
        d = g.element;
        if (f.isDehydrated) {
          if (f = {
            element: d,
            isDehydrated: !1,
            cache: g.cache,
            pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
            transitions: g.transitions
          }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ki(Error(p(423)), b);
            b = mj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ki(Error(p(424)), b);
            b = mj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = !0, zg = null, c = Ch(b, null, d, c), b.child = c; c;) c.flags = c.flags & -3 | 4096, c = c.sibling;
        } else {
          Ig();
          if (d === e) {
            b = $i(a, b, c);
            break a;
          }
          Yi(a, b, d, c);
        }
        b = b.child;
      }
      return b;
    case 5:
      return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
    case 6:
      return null === a && Eg(b), null;
    case 13:
      return pj(a, b, c);
    case 4:
      return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);
    case 7:
      return Yi(a, b, b.pendingProps, c), b.child;
    case 8:
      return Yi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return Yi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        f = b.memoizedProps;
        g = e.value;
        G(Mg, d._currentValue);
        d._currentValue = g;
        if (null !== f) if (He(f.value, g)) {
          if (f.children === e.children && !Wf.current) {
            b = $i(a, b, c);
            break a;
          }
        } else for (f = b.child, null !== f && (f.return = b); null !== f;) {
          var h = f.dependencies;
          if (null !== h) {
            g = f.child;
            for (var k = h.firstContext; null !== k;) {
              if (k.context === d) {
                if (1 === f.tag) {
                  k = ch(-1, c & -c);
                  k.tag = 2;
                  var l = f.updateQueue;
                  if (null !== l) {
                    l = l.shared;
                    var m = l.pending;
                    null === m ? k.next = k : (k.next = m.next, m.next = k);
                    l.pending = k;
                  }
                }
                f.lanes |= c;
                k = f.alternate;
                null !== k && (k.lanes |= c);
                Sg(f.return, c, b);
                h.lanes |= c;
                break;
              }
              k = k.next;
            }
          } else if (10 === f.tag) g = f.type === b.type ? null : f.child;else if (18 === f.tag) {
            g = f.return;
            if (null === g) throw Error(p(341));
            g.lanes |= c;
            h = g.alternate;
            null !== h && (h.lanes |= c);
            Sg(g, c, b);
            g = f.sibling;
          } else g = f.child;
          if (null !== g) g.return = f;else for (g = f; null !== g;) {
            if (g === b) {
              g = null;
              break;
            }
            f = g.sibling;
            if (null !== f) {
              f.return = g.return;
              g = f;
              break;
            }
            g = g.return;
          }
          f = g;
        }
        Yi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;
    case 14:
      return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);
    case 15:
      return cj(a, b, b.type, b.pendingProps, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = !0, cg(b)) : a = !1, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, !0, a, c);
    case 19:
      return yj(a, b, c);
    case 22:
      return ej(a, b, c);
  }
  throw Error(p(156, b.tag));
};
function Gk(a, b) {
  return ac(a, b);
}
function al(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b, c, d) {
  return new al(a, b, c, d);
}
function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function $k(a) {
  if ("function" === typeof a) return bj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }
  return 2;
}
function wh(a, b) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : {
    lanes: b.lanes,
    firstContext: b.firstContext
  };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function yh(a, b, c, d, e, f) {
  var g = 2;
  d = a;
  if ("function" === typeof a) bj(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
    case ya:
      return Ah(c.children, e, f, b);
    case za:
      g = 8;
      e |= 8;
      break;
    case Aa:
      return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
    case Ea:
      return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
    case Fa:
      return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
    case Ia:
      return qj(c, e, f, b);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g = 10;
          break a;
        case Ca:
          g = 9;
          break a;
        case Da:
          g = 11;
          break a;
        case Ga:
          g = 14;
          break a;
        case Ha:
          g = 16;
          d = null;
          break a;
      }
      throw Error(p(130, null == a ? a : typeof a, ""));
  }
  b = Bg(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f;
  return b;
}
function Ah(a, b, c, d) {
  a = Bg(7, a, d, b);
  a.lanes = c;
  return a;
}
function qj(a, b, c, d) {
  a = Bg(22, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = {
    isHidden: !1
  };
  return a;
}
function xh(a, b, c) {
  a = Bg(6, a, null, b);
  a.lanes = c;
  return a;
}
function zh(a, b, c) {
  b = Bg(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = {
    containerInfo: a.containerInfo,
    pendingChildren: null,
    implementation: a.implementation
  };
  return b;
}
function bl(a, b, c, d, e) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a, b, c, d, e, f, g, h, k) {
  a = new bl(a, b, c, h, k);
  1 === b ? (b = 1, !0 === f && (b |= 8)) : b = 0;
  f = Bg(3, null, null, b);
  a.current = f;
  f.stateNode = a;
  f.memoizedState = {
    element: d,
    isDehydrated: c,
    cache: null,
    transitions: null,
    pendingSuspenseBoundaries: null
  };
  ah(f);
  return a;
}
function dl(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: wa,
    key: null == d ? null : "" + d,
    children: a,
    containerInfo: b,
    implementation: c
  };
}
function el(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
    var b = a;
    do {
      switch (b.tag) {
        case 3:
          b = b.stateNode.context;
          break a;
        case 1:
          if (Zf(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b = b.return;
    } while (null !== b);
    throw Error(p(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c)) return bg(a, c, b);
  }
  return b;
}
function fl(a, b, c, d, e, f, g, h, k) {
  a = cl(c, d, !0, a, e, f, g, h, k);
  a.context = el(null);
  c = a.current;
  d = L();
  e = lh(c);
  f = ch(d, e);
  f.callback = void 0 !== b && null !== b ? b : null;
  dh(c, f, e);
  a.current.lanes = e;
  Ac(a, e, d);
  Ek(a, d);
  return a;
}
function gl(a, b, c, d) {
  var e = b.current,
    f = L(),
    g = lh(e);
  c = el(c);
  null === b.context ? b.context = c : b.pendingContext = c;
  b = ch(f, g);
  b.payload = {
    element: a
  };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  a = dh(e, b, g);
  null !== a && (mh(a, e, g, f), eh(a, e, g));
  return g;
}
function hl(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function il(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function jl(a, b) {
  il(a, b);
  (a = a.alternate) && il(a, b);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function (a) {
  console.error(a);
};
function ml(a) {
  this._internalRoot = a;
}
nl.prototype.render = ml.prototype.render = function (a) {
  var b = this._internalRoot;
  if (null === b) throw Error(p(409));
  gl(a, b, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function () {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b = a.containerInfo;
    Sk(function () {
      gl(null, a, null, null);
    });
    b[uf] = null;
  }
};
function nl(a) {
  this._internalRoot = a;
}
nl.prototype.unstable_scheduleHydration = function (a) {
  if (a) {
    var b = Hc();
    a = {
      blockedOn: null,
      target: a,
      priority: b
    };
    for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++);
    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function ql() {}
function rl(a, b, c, d, e) {
  if (e) {
    if ("function" === typeof d) {
      var f = d;
      d = function () {
        var a = hl(g);
        f.call(a);
      };
    }
    var g = fl(b, d, a, 0, null, !1, !1, "", ql);
    a._reactRootContainer = g;
    a[uf] = g.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g;
  }
  for (; e = a.lastChild;) a.removeChild(e);
  if ("function" === typeof d) {
    var h = d;
    d = function () {
      var a = hl(k);
      h.call(a);
    };
  }
  var k = cl(a, 0, !1, null, null, !1, !1, "", ql);
  a._reactRootContainer = k;
  a[uf] = k.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function () {
    gl(b, k, c, d);
  });
  return k;
}
function sl(a, b, c, d, e) {
  var f = c._reactRootContainer;
  if (f) {
    var g = f;
    if ("function" === typeof e) {
      var h = e;
      e = function () {
        var a = hl(g);
        h.call(a);
      };
    }
    gl(b, g, a, e);
  } else g = rl(c, b, a, e, d);
  return hl(g);
}
Ec = function (a) {
  switch (a.tag) {
    case 3:
      var b = a.stateNode;
      if (b.current.memoizedState.isDehydrated) {
        var c = tc(b.pendingLanes);
        0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function () {
        var b = Zg(a, 1);
        if (null !== b) {
          var c = L();
          mh(b, a, 1, c);
        }
      }), jl(a, 1);
  }
};
Fc = function (a) {
  if (13 === a.tag) {
    var b = Zg(a, 134217728);
    if (null !== b) {
      var c = L();
      mh(b, a, 134217728, c);
    }
    jl(a, 134217728);
  }
};
Gc = function (a) {
  if (13 === a.tag) {
    var b = lh(a),
      c = Zg(a, b);
    if (null !== c) {
      var d = L();
      mh(c, a, b, d);
    }
    jl(a, b);
  }
};
Hc = function () {
  return C;
};
Ic = function (a, b) {
  var c = C;
  try {
    return C = a, b();
  } finally {
    C = c;
  }
};
yb = function (a, b, c) {
  switch (b) {
    case "input":
      bb(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode;) c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e) throw Error(p(90));
            Wa(d);
            bb(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, !1);
  }
};
Gb = Rk;
Hb = Sk;
var tl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue, Db, Eb, Fb, Rk]
  },
  ul = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
  };
var vl = {
  bundleType: ul.bundleType,
  version: ul.version,
  rendererPackageName: ul.rendererPackageName,
  rendererConfig: ul.rendererConfig,
  overrideHookState: null,
  overrideHookStateDeletePath: null,
  overrideHookStateRenamePath: null,
  overrideProps: null,
  overridePropsDeletePath: null,
  overridePropsRenamePath: null,
  setErrorHandler: null,
  setSuspenseHandler: null,
  scheduleUpdate: null,
  currentDispatcherRef: ua.ReactCurrentDispatcher,
  findHostInstanceByFiber: function (a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  },
  findFiberByHostInstance: ul.findFiberByHostInstance || kl,
  findHostInstancesForRefresh: null,
  scheduleRefresh: null,
  scheduleRoot: null,
  setRefreshHandler: null,
  getCurrentFiber: null,
  reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber) try {
    kc = wl.inject(vl), lc = wl;
  } catch (a) {}
}
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
exports.createPortal = function (a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b)) throw Error(p(200));
  return dl(a, b, null, c);
};
exports.createRoot = function (a, b) {
  if (!ol(a)) throw Error(p(299));
  var c = !1,
    d = "",
    e = ll;
  null !== b && void 0 !== b && (!0 === b.unstable_strictMode && (c = !0), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
  b = cl(a, 1, !1, null, null, c, !1, d, e);
  a[uf] = b.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b);
};
exports.findDOMNode = function (a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render) throw Error(p(188));
    a = Object.keys(a).join(",");
    throw Error(p(268, a));
  }
  a = Zb(b);
  a = null === a ? null : a.stateNode;
  return a;
};
exports.flushSync = function (a) {
  return Sk(a);
};
exports.hydrate = function (a, b, c) {
  if (!pl(b)) throw Error(p(200));
  return sl(null, a, b, !0, c);
};
exports.hydrateRoot = function (a, b, c) {
  if (!ol(a)) throw Error(p(405));
  var d = null != c && c.hydratedSources || null,
    e = !1,
    f = "",
    g = ll;
  null !== c && void 0 !== c && (!0 === c.unstable_strictMode && (e = !0), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
  b = fl(b, null, a, 1, null != c ? c : null, e, !1, f, g);
  a[uf] = b.current;
  sf(a);
  if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(c, e);
  return new nl(b);
};
exports.render = function (a, b, c) {
  if (!pl(b)) throw Error(p(200));
  return sl(null, a, b, !1, c);
};
exports.unmountComponentAtNode = function (a) {
  if (!pl(a)) throw Error(p(40));
  return a._reactRootContainer ? (Sk(function () {
    sl(null, null, a, !1, function () {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), !0) : !1;
};
exports.unstable_batchedUpdates = Rk;
exports.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
  if (!pl(c)) throw Error(p(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p(38));
  return sl(a, b, c, !1, d);
};
exports.version = "18.2.0-next-9e3b772b8-20220608";

/***/ }),

/***/ 1250:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


var m = __webpack_require__(4164);
if (true) {
  exports.s = m.createRoot;
  __webpack_unused_export__ = m.hydrateRoot;
} else { var i; }

/***/ }),

/***/ 4164:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}
if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(4463);
} else {}

/***/ }),

/***/ 7689:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AW: () => (/* binding */ Route),
/* harmony export */   Fg: () => (/* binding */ Navigate),
/* harmony export */   TH: () => (/* binding */ useLocation),
/* harmony export */   Us: () => (/* binding */ NavigationContext),
/* harmony export */   VA: () => (/* binding */ MemoryRouter),
/* harmony export */   WU: () => (/* binding */ useResolvedPath),
/* harmony export */   Z5: () => (/* binding */ Routes),
/* harmony export */   oQ: () => (/* binding */ useHref),
/* harmony export */   s0: () => (/* binding */ useNavigate)
/* harmony export */ });
/* unused harmony exports Await, Outlet, Router, RouterProvider, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_RouteContext, UNSAFE_mapRouteProperties, UNSAFE_useRouteId, UNSAFE_useRoutesImpl, createMemoryRouter, createRoutesFromChildren, createRoutesFromElements, renderMatches, useActionData, useAsyncError, useAsyncValue, useBlocker, useInRouterContext, useLoaderData, useMatch, useMatches, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useRevalidator, useRouteError, useRouteLoaderData, useRoutes */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2791);
/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8278);
/**
 * React Router v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// Create react-specific types from the agnostic types in @remix-run/router to
// export from react-router
const DataRouterContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
if (false) {}
const DataRouterStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
if (false) {}
const AwaitContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
if (false) {}

/**
 * A Navigator is a "location changer"; it's how you get to different locations.
 *
 * Every history instance conforms to the Navigator interface, but the
 * distinction is useful primarily when it comes to the low-level `<Router>` API
 * where both the location and a navigator must be provided separately in order
 * to avoid "tearing" that may occur in a suspense-enabled app if the action
 * and/or location were to be read directly from the history instance.
 */

const NavigationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
if (false) {}
const LocationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
if (false) {}
const RouteContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
if (false) {}
const RouteErrorContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
if (false) {}

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/hooks/use-href
 */
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  let {
    basename,
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;

  // If we're operating within a basename, prepend it to the pathname prior
  // to creating the href.  If this is a root navigation, then just use the raw
  // basename which allows the basename to have full control over the presence
  // of a trailing slash on root links
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .joinPaths */ .RQ)([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}

/**
 * Returns true if this component is a descendant of a `<Router>`.
 *
 * @see https://reactrouter.com/hooks/use-in-router-context
 */
function useInRouterContext() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;
}

/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/hooks/use-location
 */
function useLocation() {
  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;
}

/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/hooks/use-navigation-type
 */
function useNavigationType() {
  return React.useContext(LocationContext).navigationType;
}

/**
 * Returns a PathMatch object if the given pattern matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * `<NavLink>`.
 *
 * @see https://reactrouter.com/hooks/use-match
 */
function useMatch(pattern) {
  !useInRouterContext() ?  false ? 0 : UNSAFE_invariant(false) : void 0;
  let {
    pathname
  } = useLocation();
  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
}

/**
 * The interface for the navigate() function returned from useNavigate().
 */

const navigateEffectWarning = (/* unused pure expression or super */ null && ("You should call navigate() in a React.useEffect(), not when " + "your component is first rendered."));

// Mute warnings for calls to useNavigate in SSR environments
function useIsomorphicLayoutEffect(cb) {
  let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;
  if (!isStatic) {
    // We should be able to get rid of this once react 18.3 is released
    // See: https://github.com/facebook/react/pull/26395
    // eslint-disable-next-line react-hooks/rules-of-hooks
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);
  }
}

/**
 * Returns an imperative method for changing the location. Used by `<Link>`s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/hooks/use-navigate
 */
function useNavigate() {
  let {
    isDataRoute
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_getResolveToMatches */ .cm)(matches, future.v7_relativeSplatPath));
  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }
     false ? 0 : void 0;

    // Short circuit here since if this happens on first render the navigate
    // is useless because we haven't wired up our history listener yet
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .resolveTo */ .pC)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");

    // If we're operating within a basename, prepend it to the pathname prior
    // to handing off to history (but only if we're not in a data router,
    // otherwise it'll prepend the basename inside of the router).
    // If this is a root navigation, then we navigate to the raw basename
    // which allows the basename to have full control over the presence of a
    // trailing slash on root links
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .joinPaths */ .RQ)([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
const OutletContext = /*#__PURE__*/(/* unused pure expression or super */ null && (React.createContext(null)));

/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/hooks/use-outlet-context
 */
function useOutletContext() {
  return React.useContext(OutletContext);
}

/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by `<Outlet>` to render child routes.
 *
 * @see https://reactrouter.com/hooks/use-outlet
 */
function useOutlet(context) {
  let outlet = React.useContext(RouteContext).outlet;
  if (outlet) {
    return /*#__PURE__*/React.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}

/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/hooks/use-params
 */
function useParams() {
  let {
    matches
  } = React.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}

/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/hooks/use-resolved-path
 */
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_getResolveToMatches */ .cm)(matches, future.v7_relativeSplatPath));
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .resolveTo */ .pC)(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}

/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an `<Outlet>` to render their child route's
 * element.
 *
 * @see https://reactrouter.com/hooks/use-routes
 */
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}

// Internal implementation with accept optional param for RouterProvider usage
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  let {
    navigator
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (false) {}
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    // Determine the remaining pathname by removing the # of URL segments the
    // parentPathnameBase has, instead of removing based on character count.
    // This is because we can't guarantee that incoming/outgoing encodings/
    // decodings will match exactly.
    // We decode paths before matching on a per-segment basis with
    // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they
    // match what `window.location.pathname` would reflect.  Those don't 100%
    // align when it comes to encoded URI characters such as % and &.
    //
    // So we may end up with:
    //   pathname:           "/descendant/a%25b/match"
    //   parentPathnameBase: "/descendant/a%b"
    //
    // And the direct substring removal approach won't work :/
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .matchRoutes */ .fp)(routes, {
    pathname: remainingPathname
  });
  if (false) {}
  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .joinPaths */ .RQ)([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .joinPaths */ .RQ)([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
  })), parentMatches, dataRouterState, future);

  // When a user passes in a `locationArg`, the associated routes need to
  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`
  // to use the scoped location instead of the global location.
  if (locationArg && renderedMatches) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {
      value: {
        location: _extends({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .Action */ .aU.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .isRouteErrorResponse */ .WK)(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (false) {}
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h2", null, "Unexpected Application Error!"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error: error
    };
  }
  static getDerivedStateFromProps(props, state) {
    // When we get into an error state, the user will likely click "back" to the
    // previous page that didn't have an error. Because this wraps the entire
    // application, that will have no effect--the error page continues to display.
    // This gives us a mechanism to recover from the error when the location changes.
    //
    // Whether we're in an error state or not, we update the location in state
    // so that when we are in an error state, it gets reset when a new location
    // comes in and the user recovers from the error.
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }

    // If we're not changing locations, preserve the location but still surface
    // any new errors that may come through. We retain the existing error, we do
    // this because the error provided from the app state may be cleared without
    // the location changing.
    return {
      error: props.error !== undefined ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== undefined ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);

  // Track how deep we got in our render pass to emulate SSR componentDidCatch
  // in a DataStaticRouter
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      // Don't bail if we have data router errors so we can render them in the
      // boundary.  Use the pre-matched (or shimmed) matches
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;

  // If we have data errors, trim matches to the highest error boundary
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));
    !(errorIndex >= 0) ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }

  // If we're in a partial hydration mode, detect if we need to render down to
  // a given HydrateFallback while we load the rest of the hydration data
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      // Track the deepest fallback up until the first route without data
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);
        if (match.route.lazy || needsToRunLoader) {
          // We found the first route that's not ready to render (waiting on
          // lazy, or has a loader that hasn't run yet).  Flag that we need to
          // render a fallback and render up until the appropriate fallback
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    // Only data routers handle errors/fallbacks
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : undefined;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        // Note: This is a de-optimized path since React won't re-use the
        // ReactElement since it's identity changes with each new
        // React.createElement call.  We keep this so folks can use
        // `<Route Component={...}>` in `<Routes>` but generally `Component`
        // usage is only advised in `RouterProvider` when we can convert it to
        // `element` ahead of time.
        children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {
        match: match,
        routeContext: {
          outlet,
          matches,
          isDataRoute: dataRouterState != null
        },
        children: children
      });
    };
    // Only wrap in an error boundary within data router usages when we have an
    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to
    // an ancestor ErrorBoundary/errorElement
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error: error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook = /*#__PURE__*/function (DataRouterHook) {
  DataRouterHook["UseBlocker"] = "useBlocker";
  DataRouterHook["UseRevalidator"] = "useRevalidator";
  DataRouterHook["UseNavigateStable"] = "useNavigate";
  return DataRouterHook;
}(DataRouterHook || {});
var DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {
  DataRouterStateHook["UseBlocker"] = "useBlocker";
  DataRouterStateHook["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook["UseActionData"] = "useActionData";
  DataRouterStateHook["UseRouteError"] = "useRouteError";
  DataRouterStateHook["UseNavigation"] = "useNavigation";
  DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook["UseMatches"] = "useMatches";
  DataRouterStateHook["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook["UseRouteId"] = "useRouteId";
  return DataRouterStateHook;
}(DataRouterStateHook || {});
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  !ctx ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  !state ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  !route ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  return route;
}

// Internal version with hookName-aware debugging
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  return thisRoute.route.id;
}

/**
 * Returns the ID for the nearest contextual route
 */
function useRouteId() {
  return useCurrentRouteId(DataRouterStateHook.UseRouteId);
}

/**
 * Returns the current navigation, defaulting to an "idle" navigation when
 * no navigation is in progress
 */
function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}

/**
 * Returns a revalidate function for manually triggering revalidation, as well
 * as the current state of any manual revalidations
 */
function useRevalidator() {
  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);
  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);
  return React.useMemo(() => ({
    revalidate: dataRouterContext.router.revalidate,
    state: state.revalidation
  }), [dataRouterContext.router.revalidate, state.revalidation]);
}

/**
 * Returns the active route matches, useful for accessing loaderData for
 * parent/child routes or the route "handle" property
 */
function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return React.useMemo(() => matches.map(m => UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);
}

/**
 * Returns the loader data for the nearest ancestor Route loader
 */
function useLoaderData() {
  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  if (state.errors && state.errors[routeId] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
    return undefined;
  }
  return state.loaderData[routeId];
}

/**
 * Returns the loaderData for the given routeId
 */
function useRouteLoaderData(routeId) {
  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);
  return state.loaderData[routeId];
}

/**
 * Returns the action data for the nearest ancestor Route action
 */
function useActionData() {
  let state = useDataRouterState(DataRouterStateHook.UseActionData);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  return state.actionData ? state.actionData[routeId] : undefined;
}

/**
 * Returns the nearest ancestor Route error, which could be a loader/action
 * error or a render error.  This is intended to be called from your
 * ErrorBoundary/errorElement to display a proper error message.
 */
function useRouteError() {
  var _state$errors;
  let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);

  // If this was a render error, we put it in a RouteError context inside
  // of RenderErrorBoundary
  if (error !== undefined) {
    return error;
  }

  // Otherwise look for errors from our data router state
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}

/**
 * Returns the happy-path data from the nearest ancestor `<Await />` value
 */
function useAsyncValue() {
  let value = React.useContext(AwaitContext);
  return value == null ? void 0 : value._data;
}

/**
 * Returns the error from the nearest ancestor `<Await />` value
 */
function useAsyncError() {
  let value = React.useContext(AwaitContext);
  return value == null ? void 0 : value._error;
}
let blockerId = 0;

/**
 * Allow the application to block navigations within the SPA and present the
 * user a confirmation dialog to confirm the navigation.  Mostly used to avoid
 * using half-filled form data.  This does not handle hard-reloads or
 * cross-origin navigations.
 */
function useBlocker(shouldBlock) {
  let {
    router,
    basename
  } = useDataRouterContext(DataRouterHook.UseBlocker);
  let state = useDataRouterState(DataRouterStateHook.UseBlocker);
  let [blockerKey, setBlockerKey] = React.useState("");
  let blockerFunction = React.useCallback(arg => {
    if (typeof shouldBlock !== "function") {
      return !!shouldBlock;
    }
    if (basename === "/") {
      return shouldBlock(arg);
    }

    // If they provided us a function and we've got an active basename, strip
    // it from the locations we expose to the user to match the behavior of
    // useLocation
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = arg;
    return shouldBlock({
      currentLocation: _extends({}, currentLocation, {
        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
      }),
      nextLocation: _extends({}, nextLocation, {
        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
      }),
      historyAction
    });
  }, [basename, shouldBlock]);

  // This effect is in charge of blocker key assignment and deletion (which is
  // tightly coupled to the key)
  React.useEffect(() => {
    let key = String(++blockerId);
    setBlockerKey(key);
    return () => router.deleteBlocker(key);
  }, [router]);

  // This effect handles assigning the blockerFunction.  This is to handle
  // unstable blocker function identities, and happens only after the prior
  // effect so we don't get an orphaned blockerFunction in the router with a
  // key of "".  Until then we just have the IDLE_BLOCKER.
  React.useEffect(() => {
    if (blockerKey !== "") {
      router.getBlocker(blockerKey, blockerFunction);
    }
  }, [router, blockerKey, blockerFunction]);

  // Prefer the blocker from `state` not `router.state` since DataRouterContext
  // is memoized so this ensures we update on blocker state updates
  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;
}

/**
 * Stable version of useNavigate that is used when we are in the context of
 * a RouterProvider.
 */
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseNavigateStable);
  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);
  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }
     false ? 0 : void 0;

    // Short circuit here since if this happens on first render the navigate
    // is useless because we haven't wired up our router subscriber yet
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends({
        fromRouteId: id
      }, options));
    }
  }, [router, id]);
  return navigate;
}
const alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     false ? 0 : void 0;
  }
}

/**
  Webpack + React 17 fails to compile on any of the following because webpack
  complains that `startTransition` doesn't exist in `React`:
  * import { startTransition } from "react"
  * import * as React from from "react";
    "startTransition" in React ? React.startTransition(() => setState()) : setState()
  * import * as React from from "react";
    "startTransition" in React ? React["startTransition"](() => setState()) : setState()

  Moving it to a constant such as the following solves the Webpack/React 17 issue:
  * import * as React from from "react";
    const START_TRANSITION = "startTransition";
    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()

  However, that introduces webpack/terser minification issues in production builds
  in React 18 where minification/obfuscation ends up removing the call of
  React.startTransition entirely from the first half of the ternary.  Grabbing
  this exported reference once up front resolves that issue.

  See https://github.com/remix-run/react-router/issues/10579
*/
const START_TRANSITION = "startTransition";
const startTransitionImpl = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[START_TRANSITION];

/**
 * Given a Remix Router instance, render the appropriate UI
 */
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router,
    future
  } = _ref;
  let [state, setStateImpl] = React.useState(router.state);
  let {
    v7_startTransition
  } = future || {};
  let setState = React.useCallback(newState => {
    if (v7_startTransition && startTransitionImpl) {
      startTransitionImpl(() => setStateImpl(newState));
    } else {
      setStateImpl(newState);
    }
  }, [setStateImpl, v7_startTransition]);

  // Need to use a layout effect here so we are subscribed early enough to
  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)
  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  React.useEffect(() => {
     false ? 0 : void 0;
    // Only log this once on initial mount
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  let navigator = React.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state, opts) => router.navigate(to, {
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state, opts) => router.navigate(to, {
        replace: true,
        state,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = React.useMemo(() => ({
    router,
    navigator,
    static: false,
    basename
  }), [router, navigator, basename]);

  // The fragment and {null} here are important!  We need them to keep React 18's
  // useId happy when we are server-rendering since we may have a <script> here
  // containing the hydrated server-side staticContext (from StaticRouterProvider).
  // useId relies on the component tree structure to generate deterministic id's
  // so we need to ensure it remains the same on the client even though
  // we don't need the <script> tag
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /*#__PURE__*/React.createElement(Router, {
    basename: basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator,
    future: {
      v7_relativeSplatPath: router.future.v7_relativeSplatPath
    }
  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/React.createElement(DataRoutes, {
    routes: router.routes,
    future: router.future,
    state: state
  }) : fallbackElement))), null);
}
function DataRoutes(_ref2) {
  let {
    routes,
    future,
    state
  } = _ref2;
  return useRoutesImpl(routes, undefined, state, future);
}
/**
 * A `<Router>` that stores all entries in memory.
 *
 * @see https://reactrouter.com/router-components/memory-router
 */
function MemoryRouter(_ref3) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex,
    future
  } = _ref3;
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .createMemoryHistory */ .PP)({
      initialEntries,
      initialIndex,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future
  });
}
/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/components/navigate
 */
function Navigate(_ref4) {
  let {
    to,
    replace,
    state,
    relative
  } = _ref4;
  !useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
  let {
    future,
    static: isStatic
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
   false ? 0 : void 0;
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();

  // Resolve the path outside of the effect so that when effects run twice in
  // StrictMode they navigate to the same place
  let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .resolveTo */ .pC)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_getResolveToMatches */ .cm)(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace,
    state,
    relative
  }), [navigate, jsonPath, relative, replace, state]);
  return null;
}
/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/components/outlet
 */
function Outlet(props) {
  return useOutlet(props.context);
}
/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/components/route
 */
function Route(_props) {
   false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false);
}
/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a `<Router>` directly. Instead, you'll render a
 * router that is more specific to your environment such as a `<BrowserRouter>`
 * in web browsers or a `<StaticRouter>` for server rendering.
 *
 * @see https://reactrouter.com/router-components/router
 */
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .Action */ .aU.Pop,
    navigator,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;

  // Preserve trailing slashes on basename, so we can let the user control
  // the enforcement of trailing slashes throughout the app
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    basename,
    navigator,
    static: staticProp,
    future: _extends({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .stripBasename */ .Zn)(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
   false ? 0 : void 0;
  if (locationContext == null) {
    return null;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {
    children: children,
    value: locationContext
  }));
}
/**
 * A container for a nested tree of `<Route>` elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/components/routes
 */
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
/**
 * Component to use for rendering lazily loaded data from returning defer()
 * in a loader function
 */
function Await(_ref7) {
  let {
    children,
    errorElement,
    resolve
  } = _ref7;
  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {
    resolve: resolve,
    errorElement: errorElement
  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));
}
var AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {
  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
  return AwaitRenderStatus;
}(AwaitRenderStatus || {});
const neverSettledPromise = new Promise(() => {});
class AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("<Await> caught the following error during render", error, errorInfo);
  }
  render() {
    let {
      children,
      errorElement,
      resolve
    } = this.props;
    let promise = null;
    let status = AwaitRenderStatus.pending;
    if (!(resolve instanceof Promise)) {
      // Didn't get a promise - provide as a resolved promise
      status = AwaitRenderStatus.success;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_data", {
        get: () => resolve
      });
    } else if (this.state.error) {
      // Caught a render error, provide it as a rejected promise
      status = AwaitRenderStatus.error;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_error", {
        get: () => renderError
      });
    } else if (resolve._tracked) {
      // Already tracked promise - check contents
      promise = resolve;
      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;
    } else {
      // Raw (untracked) promise - track it
      status = AwaitRenderStatus.pending;
      Object.defineProperty(resolve, "_tracked", {
        get: () => true
      });
      promise = resolve.then(data => Object.defineProperty(resolve, "_data", {
        get: () => data
      }), error => Object.defineProperty(resolve, "_error", {
        get: () => error
      }));
    }
    if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .AbortedDeferredError */ .X3) {
      // Freeze the UI by throwing a never resolved promise
      throw neverSettledPromise;
    }
    if (status === AwaitRenderStatus.error && !errorElement) {
      // No errorElement, throw to the nearest route-level error boundary
      throw promise._error;
    }
    if (status === AwaitRenderStatus.error) {
      // Render via our errorElement
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {
        value: promise,
        children: errorElement
      });
    }
    if (status === AwaitRenderStatus.success) {
      // Render children with resolved value
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {
        value: promise,
        children: children
      });
    }

    // Throw to the suspense boundary
    throw promise;
  }
}

/**
 * @private
 * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`
 */
function ResolveAwait(_ref8) {
  let {
    children
  } = _ref8;
  let data = useAsyncValue();
  let toRender = typeof children === "function" ? children(data) : children;
  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);
}

///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/utils/create-routes-from-children
 */
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index) => {
    if (! /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
    !(!element.props.index || !element.props.children) ?  false ? 0 : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__/* .UNSAFE_invariant */ .J0)(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}

/**
 * Renders the result of `matchRoutes()` into a React element.
 */
function renderMatches(matches) {
  return _renderMatches(matches);
}
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    if (false) {}
    Object.assign(updates, {
      element: /*#__PURE__*/React.createElement(route.Component),
      Component: undefined
    });
  }
  if (route.HydrateFallback) {
    if (false) {}
    Object.assign(updates, {
      hydrateFallbackElement: /*#__PURE__*/React.createElement(route.HydrateFallback),
      HydrateFallback: undefined
    });
  }
  if (route.ErrorBoundary) {
    if (false) {}
    Object.assign(updates, {
      errorElement: /*#__PURE__*/React.createElement(route.ErrorBoundary),
      ErrorBoundary: undefined
    });
  }
  return updates;
}
function createMemoryRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: _extends({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createMemoryHistory({
      initialEntries: opts == null ? void 0 : opts.initialEntries,
      initialIndex: opts == null ? void 0 : opts.initialIndex
    }),
    hydrationData: opts == null ? void 0 : opts.hydrationData,
    routes,
    mapRouteProperties
  }).initialize();
}


/***/ }),

/***/ 6374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var f = __webpack_require__(2791),
  k = Symbol.for("react.element"),
  l = Symbol.for("react.fragment"),
  m = Object.prototype.hasOwnProperty,
  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  p = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };
function q(c, a, g) {
  var b,
    d = {},
    e = null,
    h = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h = a.ref);
  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
  return {
    $$typeof: k,
    type: c,
    key: e,
    ref: h,
    props: d,
    _owner: n.current
  };
}
exports.Fragment = l;
exports.jsx = q;
exports.jsxs = q;

/***/ }),

/***/ 9117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var l = Symbol.for("react.element"),
  n = Symbol.for("react.portal"),
  p = Symbol.for("react.fragment"),
  q = Symbol.for("react.strict_mode"),
  r = Symbol.for("react.profiler"),
  t = Symbol.for("react.provider"),
  u = Symbol.for("react.context"),
  v = Symbol.for("react.forward_ref"),
  w = Symbol.for("react.suspense"),
  x = Symbol.for("react.memo"),
  y = Symbol.for("react.lazy"),
  z = Symbol.iterator;
function A(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z && a[z] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  C = Object.assign,
  D = {};
function E(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}
E.prototype.isReactComponent = {};
E.prototype.setState = function (a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {}
F.prototype = E.prototype;
function G(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}
var H = G.prototype = new F();
H.constructor = G;
C(H, E.prototype);
H.isPureReactComponent = !0;
var I = Array.isArray,
  J = Object.prototype.hasOwnProperty,
  K = {
    current: null
  },
  L = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };
function M(a, b, e) {
  var d,
    c = {},
    k = null,
    h = null;
  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
  var g = arguments.length - 2;
  if (1 === g) c.children = e;else if (1 < g) {
    for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
    c.children = f;
  }
  if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
  return {
    $$typeof: l,
    type: a,
    key: k,
    ref: h,
    props: c,
    _owner: K.current
  };
}
function N(a, b) {
  return {
    $$typeof: l,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}
function O(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l;
}
function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (a) {
    return b[a];
  });
}
var P = /\/+/g;
function Q(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function R(a, b, e, d, c) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k) a = null;
  var h = !1;
  if (null === a) h = !0;else switch (k) {
    case "string":
    case "number":
      h = !0;
      break;
    case "object":
      switch (a.$$typeof) {
        case l:
        case n:
          h = !0;
      }
  }
  if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function (a) {
    return a;
  })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
  h = 0;
  d = "" === d ? "." : d + ":";
  if (I(a)) for (var g = 0; g < a.length; g++) {
    k = a[g];
    var f = d + Q(k, g);
    h += R(k, b, e, f, c);
  } else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h;
}
function S(a, b, e) {
  if (null == a) return a;
  var d = [],
    c = 0;
  R(a, d, "", "", function (a) {
    return b.call(e, a, c++);
  });
  return d;
}
function T(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function (b) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
    }, function (b) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U = {
    current: null
  },
  V = {
    transition: null
  },
  W = {
    ReactCurrentDispatcher: U,
    ReactCurrentBatchConfig: V,
    ReactCurrentOwner: K
  };
exports.Children = {
  map: S,
  forEach: function (a, b, e) {
    S(a, function () {
      b.apply(this, arguments);
    }, e);
  },
  count: function (a) {
    var b = 0;
    S(a, function () {
      b++;
    });
    return b;
  },
  toArray: function (a) {
    return S(a, function (a) {
      return a;
    }) || [];
  },
  only: function (a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  }
};
exports.Component = E;
exports.Fragment = p;
exports.Profiler = r;
exports.PureComponent = G;
exports.StrictMode = q;
exports.Suspense = w;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
exports.cloneElement = function (a, b, e) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C({}, a.props),
    c = a.key,
    k = a.ref,
    h = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = K.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
    for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
  }
  var f = arguments.length - 2;
  if (1 === f) d.children = e;else if (1 < f) {
    g = Array(f);
    for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
    d.children = g;
  }
  return {
    $$typeof: l,
    type: a.type,
    key: c,
    ref: k,
    props: d,
    _owner: h
  };
};
exports.createContext = function (a) {
  a = {
    $$typeof: u,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null,
    _defaultValue: null,
    _globalName: null
  };
  a.Provider = {
    $$typeof: t,
    _context: a
  };
  return a.Consumer = a;
};
exports.createElement = M;
exports.createFactory = function (a) {
  var b = M.bind(null, a);
  b.type = a;
  return b;
};
exports.createRef = function () {
  return {
    current: null
  };
};
exports.forwardRef = function (a) {
  return {
    $$typeof: v,
    render: a
  };
};
exports.isValidElement = O;
exports.lazy = function (a) {
  return {
    $$typeof: y,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: T
  };
};
exports.memo = function (a, b) {
  return {
    $$typeof: x,
    type: a,
    compare: void 0 === b ? null : b
  };
};
exports.startTransition = function (a) {
  var b = V.transition;
  V.transition = {};
  try {
    a();
  } finally {
    V.transition = b;
  }
};
exports.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
exports.useCallback = function (a, b) {
  return U.current.useCallback(a, b);
};
exports.useContext = function (a) {
  return U.current.useContext(a);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (a) {
  return U.current.useDeferredValue(a);
};
exports.useEffect = function (a, b) {
  return U.current.useEffect(a, b);
};
exports.useId = function () {
  return U.current.useId();
};
exports.useImperativeHandle = function (a, b, e) {
  return U.current.useImperativeHandle(a, b, e);
};
exports.useInsertionEffect = function (a, b) {
  return U.current.useInsertionEffect(a, b);
};
exports.useLayoutEffect = function (a, b) {
  return U.current.useLayoutEffect(a, b);
};
exports.useMemo = function (a, b) {
  return U.current.useMemo(a, b);
};
exports.useReducer = function (a, b, e) {
  return U.current.useReducer(a, b, e);
};
exports.useRef = function (a) {
  return U.current.useRef(a);
};
exports.useState = function (a) {
  return U.current.useState(a);
};
exports.useSyncExternalStore = function (a, b, e) {
  return U.current.useSyncExternalStore(a, b, e);
};
exports.useTransition = function () {
  return U.current.useTransition();
};
exports.version = "18.2.0";

/***/ }),

/***/ 2791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(9117);
} else {}

/***/ }),

/***/ 184:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(6374);
} else {}

/***/ }),

/***/ 6813:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function f(a, b) {
  var c = a.length;
  a.push(b);
  a: for (; 0 < c;) {
    var d = c - 1 >>> 1,
      e = a[d];
    if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;else break a;
  }
}
function h(a) {
  return 0 === a.length ? null : a[0];
}
function k(a) {
  if (0 === a.length) return null;
  var b = a[0],
    c = a.pop();
  if (c !== b) {
    a[0] = c;
    a: for (var d = 0, e = a.length, w = e >>> 1; d < w;) {
      var m = 2 * (d + 1) - 1,
        C = a[m],
        n = m + 1,
        x = a[n];
      if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;else break a;
    }
  }
  return b;
}
function g(a, b) {
  var c = a.sortIndex - b.sortIndex;
  return 0 !== c ? c : a.id - b.id;
}
if ("object" === typeof performance && "function" === typeof performance.now) {
  var l = performance;
  exports.unstable_now = function () {
    return l.now();
  };
} else {
  var p = Date,
    q = p.now();
  exports.unstable_now = function () {
    return p.now() - q;
  };
}
var r = [],
  t = [],
  u = 1,
  v = null,
  y = 3,
  z = !1,
  A = !1,
  B = !1,
  D = "function" === typeof setTimeout ? setTimeout : null,
  E = "function" === typeof clearTimeout ? clearTimeout : null,
  F = "undefined" !== typeof setImmediate ? setImmediate : null;
"undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
function G(a) {
  for (var b = h(t); null !== b;) {
    if (null === b.callback) k(t);else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);else break;
    b = h(t);
  }
}
function H(a) {
  B = !1;
  G(a);
  if (!A) if (null !== h(r)) A = !0, I(J);else {
    var b = h(t);
    null !== b && K(H, b.startTime - a);
  }
}
function J(a, b) {
  A = !1;
  B && (B = !1, E(L), L = -1);
  z = !0;
  var c = y;
  try {
    G(b);
    for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M());) {
      var d = v.callback;
      if ("function" === typeof d) {
        v.callback = null;
        y = v.priorityLevel;
        var e = d(v.expirationTime <= b);
        b = exports.unstable_now();
        "function" === typeof e ? v.callback = e : v === h(r) && k(r);
        G(b);
      } else k(r);
      v = h(r);
    }
    if (null !== v) var w = !0;else {
      var m = h(t);
      null !== m && K(H, m.startTime - b);
      w = !1;
    }
    return w;
  } finally {
    v = null, y = c, z = !1;
  }
}
var N = !1,
  O = null,
  L = -1,
  P = 5,
  Q = -1;
function M() {
  return exports.unstable_now() - Q < P ? !1 : !0;
}
function R() {
  if (null !== O) {
    var a = exports.unstable_now();
    Q = a;
    var b = !0;
    try {
      b = O(!0, a);
    } finally {
      b ? S() : (N = !1, O = null);
    }
  } else N = !1;
}
var S;
if ("function" === typeof F) S = function () {
  F(R);
};else if ("undefined" !== typeof MessageChannel) {
  var T = new MessageChannel(),
    U = T.port2;
  T.port1.onmessage = R;
  S = function () {
    U.postMessage(null);
  };
} else S = function () {
  D(R, 0);
};
function I(a) {
  O = a;
  N || (N = !0, S());
}
function K(a, b) {
  L = D(function () {
    a(exports.unstable_now());
  }, b);
}
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_cancelCallback = function (a) {
  a.callback = null;
};
exports.unstable_continueExecution = function () {
  A || z || (A = !0, I(J));
};
exports.unstable_forceFrameRate = function (a) {
  0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1E3 / a) : 5;
};
exports.unstable_getCurrentPriorityLevel = function () {
  return y;
};
exports.unstable_getFirstCallbackNode = function () {
  return h(r);
};
exports.unstable_next = function (a) {
  switch (y) {
    case 1:
    case 2:
    case 3:
      var b = 3;
      break;
    default:
      b = y;
  }
  var c = y;
  y = b;
  try {
    return a();
  } finally {
    y = c;
  }
};
exports.unstable_pauseExecution = function () {};
exports.unstable_requestPaint = function () {};
exports.unstable_runWithPriority = function (a, b) {
  switch (a) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      a = 3;
  }
  var c = y;
  y = a;
  try {
    return b();
  } finally {
    y = c;
  }
};
exports.unstable_scheduleCallback = function (a, b, c) {
  var d = exports.unstable_now();
  "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
  switch (a) {
    case 1:
      var e = -1;
      break;
    case 2:
      e = 250;
      break;
    case 5:
      e = 1073741823;
      break;
    case 4:
      e = 1E4;
      break;
    default:
      e = 5E3;
  }
  e = c + e;
  a = {
    id: u++,
    callback: b,
    priorityLevel: a,
    startTime: c,
    expirationTime: e,
    sortIndex: -1
  };
  c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = !0, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = !0, I(J)));
  return a;
};
exports.unstable_shouldYield = M;
exports.unstable_wrapCallback = function (a) {
  var b = y;
  return function () {
    var c = y;
    y = b;
    try {
      return a.apply(this, arguments);
    } finally {
      y = c;
    }
  };
};

/***/ }),

/***/ 5296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(6813);
} else {}

/***/ }),

/***/ 8637:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * use-sync-external-store-with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var g = __webpack_require__(2791);
function n(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var p = "function" === typeof Object.is ? Object.is : n,
  q = g.useSyncExternalStore,
  r = g.useRef,
  t = g.useEffect,
  u = g.useMemo,
  v = g.useDebugValue;
exports.useSyncExternalStoreWithSelector = function (a, b, e, l, h) {
  var c = r(null);
  if (null === c.current) {
    var f = {
      hasValue: !1,
      value: null
    };
    c.current = f;
  } else f = c.current;
  c = u(function () {
    function a(a) {
      if (!c) {
        c = !0;
        d = a;
        a = l(a);
        if (void 0 !== h && f.hasValue) {
          var b = f.value;
          if (h(b, a)) return k = b;
        }
        return k = a;
      }
      b = k;
      if (p(d, a)) return b;
      var e = l(a);
      if (void 0 !== h && h(b, e)) return b;
      d = a;
      return k = e;
    }
    var c = !1,
      d,
      k,
      m = void 0 === e ? null : e;
    return [function () {
      return a(b());
    }, null === m ? void 0 : function () {
      return a(m());
    }];
  }, [b, e, l, h]);
  var d = q(a, c[0], c[1]);
  t(function () {
    f.hasValue = !0;
    f.value = d;
  }, [d]);
  v(d);
  return d;
};

/***/ }),

/***/ 7995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(8637);
} else {}

/***/ }),

/***/ 1418:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
  'use strict';

  var hasOwn = {}.hasOwnProperty;
  function classNames() {
    var classes = '';
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg) {
        classes = appendClass(classes, parseValue(arg));
      }
    }
    return classes;
  }
  function parseValue(arg) {
    if (typeof arg === 'string' || typeof arg === 'number') {
      return arg;
    }
    if (typeof arg !== 'object') {
      return '';
    }
    if (Array.isArray(arg)) {
      return classNames.apply(null, arg);
    }
    if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
      return arg.toString();
    }
    var classes = '';
    for (var key in arg) {
      if (hasOwn.call(arg, key) && arg[key]) {
        classes = appendClass(classes, key);
      }
    }
    return classes;
  }
  function appendClass(value, newClass) {
    if (!newClass) {
      return value;
    }
    if (value) {
      return value + ' ' + newClass;
    }
    return value + newClass;
  }
  if ( true && module.exports) {
    classNames.default = classNames;
    module.exports = classNames;
  } else if (true) {
    // register as 'classnames', consistent with npm package name
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return classNames;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})();

/***/ }),

/***/ 4572:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ _defineProperty)
});

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

/***/ }),

/***/ 7291:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  xC: () => (/* binding */ configureStore),
  hg: () => (/* binding */ createAsyncThunk),
  oM: () => (/* binding */ createSlice)
});

// UNUSED EXPORTS: ReducerType, SHOULD_AUTOBATCH, TaskAbortError, Tuple, __DO_NOT_USE__ActionTypes, addListener, applyMiddleware, asyncThunkCreator, autoBatchEnhancer, bindActionCreators, buildCreateSlice, clearAllListeners, combineReducers, combineSlices, compose, createAction, createActionCreatorInvariantMiddleware, createDraftSafeSelector, createDraftSafeSelectorCreator, createDynamicMiddleware, createEntityAdapter, createImmutableStateInvariantMiddleware, createListenerMiddleware, createNextState, createReducer, createSelector, createSelectorCreator, createSerializableStateInvariantMiddleware, createStore, current, findNonSerializableValue, formatProdErrorMessage, freeze, isAction, isActionCreator, isAllOf, isAnyOf, isAsyncThunkAction, isDraft, isFluxStandardAction, isFulfilled, isImmutableDefault, isPending, isPlain, isPlainObject, isRejected, isRejectedWithValue, legacy_createStore, lruMemoize, miniSerializeError, nanoid, original, prepareAutoBatched, removeListener, unwrapResult, weakMapMemoize

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js + 3 modules
var defineProperty = __webpack_require__(4572);
;// CONCATENATED MODULE: ./node_modules/immer/dist/immer.mjs
// src/utils/env.ts
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");

// src/utils/errors.ts
var errors =  false ? 0 : [];
function die(error) {
  if (false) { var _len, args, _key; }
  throw new Error("[Immer] minified error nr: ".concat(error, ". Full error at: https://bit.ly/3cXEKWf"));
}

// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _value$constructor;
  if (!value) return false;
  return immer_isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function immer_isPlainObject(value) {
  if (!value || typeof value !== "object") return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object) return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
  if (!isDraft(value)) die(15, value);
  return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0 /* Object */) {
    Reflect.ownKeys(obj).forEach(key => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;
}

function has(thing, prop) {
  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2 /* Map */) thing.set(propOrOldValue, value);else if (t === 3 /* Set */) {
    thing.add(value);
  } else thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base)) return Array.prototype.slice.call(base);
  const isPlain = immer_isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set) descriptors[key] = {
        configurable: true,
        writable: true,
        // could live with !!desc.set as well here...
        enumerable: desc.enumerable,
        value: base[key]
      };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return {
        ...base
      };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj) {
  let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep) Object.entries(obj).forEach(_ref => {
    let [key, value] = _ref;
    return freeze(value, true);
  });
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}

// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}

// src/core/scope.ts
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */) state.revoke_();else state.revoked_ = true;
}

// src/core/finalize.ts
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_) maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value)) return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path));
    return value;
  }
  if (state.scope_ !== rootScope) return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3 /* Set */) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(resultEach, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (false) {}
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ &&
    // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop)) maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value) {
  let deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}

// src/core/proxy.ts
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 /* Array */ : 0 /* Object */,

    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const {
    revoke,
    proxy
  } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE) return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc !== null && desc !== void 0 && desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && (
    // special case: handle new props with value 'undefined'
    value !== void 0 || prop in state.copy_) ||
    // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc) return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 /* Array */ || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function () {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function (state, prop) {
  if (false) {}
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function (state, prop, value) {
  if (false) {}
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _desc$get;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? "value" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the
  // prototype, we should invoke it with the draft as context!
  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source)) return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc) return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
  }
}

// src/core/immerClass.ts
var Immer2 = class {
  constructor(config) {
    var _this = this;
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce() {
          let base2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          return self.produce(base2, draft => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function") die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError) revokeScope(scope);else leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0) result = base;
        if (result === NOTHING) result = void 0;
        if (this.autoFreeze_) freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return function (state) {
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }
          return _this.produceWithPatches(state, draft => base(draft, ...args));
        };
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
    if (typeof (config === null || config === void 0 ? void 0 : config.useStrictShallowCopy) === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base)) die(8);
    if (isDraft(base)) base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_) die(9);
    const {
      scope_: scope
    } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(base, draft => applyPatchesImpl(draft, patches));
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}

// src/core/current.ts
function current(value) {
  if (!isDraft(value)) die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value)) return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_) return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}

// src/plugins/patches.ts
function enablePatches() {
  const errorOffset = 16;
  if (false) {}
  const REPLACE = "replace";
  const ADD = "add";
  const REMOVE = "remove";
  function generatePatches_(state, basePath, patches, inversePatches) {
    switch (state.type_) {
      case 0 /* Object */:
      case 2 /* Map */:
        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
      case 1 /* Array */:
        return generateArrayPatches(state, basePath, patches, inversePatches);
      case 3 /* Set */:
        return generateSetPatches(state, basePath, patches, inversePatches);
    }
  }
  function generateArrayPatches(state, basePath, patches, inversePatches) {
    let {
      base_,
      assigned_
    } = state;
    let copy_ = state.copy_;
    if (copy_.length < base_.length) {
      ;
      [base_, copy_] = [copy_, base_];
      [patches, inversePatches] = [inversePatches, patches];
    }
    for (let i = 0; i < base_.length; i++) {
      if (assigned_[i] && copy_[i] !== base_[i]) {
        const path = basePath.concat([i]);
        patches.push({
          op: REPLACE,
          path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
        inversePatches.push({
          op: REPLACE,
          path,
          value: clonePatchValueIfNeeded(base_[i])
        });
      }
    }
    for (let i = base_.length; i < copy_.length; i++) {
      const path = basePath.concat([i]);
      patches.push({
        op: ADD,
        path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[i])
      });
    }
    for (let i = copy_.length - 1; base_.length <= i; --i) {
      const path = basePath.concat([i]);
      inversePatches.push({
        op: REMOVE,
        path
      });
    }
  }
  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    const {
      base_,
      copy_
    } = state;
    each(state.assigned_, (key, assignedValue) => {
      const origValue = get(base_, key);
      const value = get(copy_, key);
      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE) return;
      const path = basePath.concat(key);
      patches.push(op === REMOVE ? {
        op,
        path
      } : {
        op,
        path,
        value
      });
      inversePatches.push(op === ADD ? {
        op: REMOVE,
        path
      } : op === REMOVE ? {
        op: ADD,
        path,
        value: clonePatchValueIfNeeded(origValue)
      } : {
        op: REPLACE,
        path,
        value: clonePatchValueIfNeeded(origValue)
      });
    });
  }
  function generateSetPatches(state, basePath, patches, inversePatches) {
    let {
      base_,
      copy_
    } = state;
    let i = 0;
    base_.forEach(value => {
      if (!copy_.has(value)) {
        const path = basePath.concat([i]);
        patches.push({
          op: REMOVE,
          path,
          value
        });
        inversePatches.unshift({
          op: ADD,
          path,
          value
        });
      }
      i++;
    });
    i = 0;
    copy_.forEach(value => {
      if (!base_.has(value)) {
        const path = basePath.concat([i]);
        patches.push({
          op: ADD,
          path,
          value
        });
        inversePatches.unshift({
          op: REMOVE,
          path,
          value
        });
      }
      i++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? void 0 : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    patches.forEach(patch => {
      const {
        path,
        op
      } = patch;
      let base = draft;
      for (let i = 0; i < path.length - 1; i++) {
        const parentType = getArchtype(base);
        let p = path[i];
        if (typeof p !== "string" && typeof p !== "number") {
          p = "" + p;
        }
        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === "__proto__" || p === "constructor")) die(errorOffset + 3);
        if (typeof base === "function" && p === "prototype") die(errorOffset + 3);
        base = get(base, p);
        if (typeof base !== "object") die(errorOffset + 2, path.join("/"));
      }
      const type = getArchtype(base);
      const value = deepClonePatchValue(patch.value);
      const key = path[path.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2 /* Map */:
              return base.set(key, value);
            case 3 /* Set */:
              die(errorOffset);
            default:
              return base[key] = value;
          }
        case ADD:
          switch (type) {
            case 1 /* Array */:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2 /* Map */:
              return base.set(key, value);
            case 3 /* Set */:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1 /* Array */:
              return base.splice(key, 1);
            case 2 /* Map */:
              return base.delete(key);
            case 3 /* Set */:
              return base.delete(patch.value);
            default:
              return delete base[key];
          }
        default:
          die(errorOffset + 1, op);
      }
    });
    return draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj)) return obj;
    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(_ref2 => {
      let [k, v] = _ref2;
      return [k, deepClonePatchValue(v)];
    }));
    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
    const cloned = Object.create(getPrototypeOf(obj));
    for (const key in obj) cloned[key] = deepClonePatchValue(obj[key]);
    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else return obj;
  }
  loadPlugin("Patches", {
    applyPatches_,
    generatePatches_,
    generateReplacementPatches_
  });
}

// src/plugins/mapset.ts
function enableMapSet() {
  class DraftMap extends Map {
    constructor(target, parent) {
      super();
      this[DRAFT_STATE] = {
        type_: 2 /* Map */,
        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: void 0,
        assigned_: void 0,
        base_: target,
        draft_: this,
        isManual_: false,
        revoked_: false
      };
    }
    get size() {
      return latest(this[DRAFT_STATE]).size;
    }
    has(key) {
      return latest(this[DRAFT_STATE]).has(key);
    }
    set(key, value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!latest(state).has(key) || latest(state).get(key) !== value) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_.set(key, true);
        state.copy_.set(key, value);
        state.assigned_.set(key, true);
      }
      return this;
    }
    delete(key) {
      if (!this.has(key)) {
        return false;
      }
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareMapCopy(state);
      markChanged(state);
      if (state.base_.has(key)) {
        state.assigned_.set(key, false);
      } else {
        state.assigned_.delete(key);
      }
      state.copy_.delete(key);
      return true;
    }
    clear() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_ = /* @__PURE__ */new Map();
        each(state.base_, key => {
          state.assigned_.set(key, false);
        });
        state.copy_.clear();
      }
    }
    forEach(cb, thisArg) {
      const state = this[DRAFT_STATE];
      latest(state).forEach((_value, key, _map) => {
        cb.call(thisArg, this.get(key), key, this);
      });
    }
    get(key) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      const value = latest(state).get(key);
      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }
      if (value !== state.base_.get(key)) {
        return value;
      }
      const draft = createProxy(value, state);
      prepareMapCopy(state);
      state.copy_.set(key, draft);
      return draft;
    }
    keys() {
      return latest(this[DRAFT_STATE]).keys();
    }
    values() {
      const iterator = this.keys();
      return {
        [Symbol.iterator]: () => this.values(),
        next: () => {
          const r = iterator.next();
          if (r.done) return r;
          const value = this.get(r.value);
          return {
            done: false,
            value
          };
        }
      };
    }
    entries() {
      const iterator = this.keys();
      return {
        [Symbol.iterator]: () => this.entries(),
        next: () => {
          const r = iterator.next();
          if (r.done) return r;
          const value = this.get(r.value);
          return {
            done: false,
            value: [r.value, value]
          };
        }
      };
    }
    [(DRAFT_STATE, Symbol.iterator)]() {
      return this.entries();
    }
  }
  function proxyMap_(target, parent) {
    return new DraftMap(target, parent);
  }
  function prepareMapCopy(state) {
    if (!state.copy_) {
      state.assigned_ = /* @__PURE__ */new Map();
      state.copy_ = new Map(state.base_);
    }
  }
  class DraftSet extends Set {
    constructor(target, parent) {
      super();
      this[DRAFT_STATE] = {
        type_: 3 /* Set */,
        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: void 0,
        base_: target,
        draft_: this,
        drafts_: /* @__PURE__ */new Map(),
        revoked_: false,
        isManual_: false
      };
    }
    get size() {
      return latest(this[DRAFT_STATE]).size;
    }
    has(value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!state.copy_) {
        return state.base_.has(value);
      }
      if (state.copy_.has(value)) return true;
      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
      return false;
    }
    add(value) {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!this.has(value)) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.add(value);
      }
      return this;
    }
    delete(value) {
      if (!this.has(value)) {
        return false;
      }
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      markChanged(state);
      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */
      false);
    }
    clear() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.clear();
      }
    }
    values() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.values();
    }
    entries() {
      const state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.entries();
    }
    keys() {
      return this.values();
    }
    [(DRAFT_STATE, Symbol.iterator)]() {
      return this.values();
    }
    forEach(cb, thisArg) {
      const iterator = this.values();
      let result = iterator.next();
      while (!result.done) {
        cb.call(thisArg, result.value, result.value, this);
        result = iterator.next();
      }
    }
  }
  function proxySet_(target, parent) {
    return new DraftSet(target, parent);
  }
  function prepareSetCopy(state) {
    if (!state.copy_) {
      state.copy_ = /* @__PURE__ */new Set();
      state.base_.forEach(value => {
        if (isDraftable(value)) {
          const draft = createProxy(value, state);
          state.drafts_.set(value, draft);
          state.copy_.add(draft);
        } else {
          state.copy_.add(value);
        }
      });
    }
  }
  function assertUnrevoked(state) {
    if (state.revoked_) die(3, JSON.stringify(latest(state)));
  }
  loadPlugin("MapSet", {
    proxyMap_,
    proxySet_
  });
}

// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(immer);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);
function castDraft(value) {
  return value;
}
function castImmutable(value) {
  return value;
}

// EXTERNAL MODULE: ./node_modules/reselect/dist/reselect.mjs
var reselect = __webpack_require__(3553);
// EXTERNAL MODULE: ./node_modules/redux/dist/redux.mjs
var redux = __webpack_require__(1154);
;// CONCATENATED MODULE: ./node_modules/redux-thunk/dist/redux-thunk.mjs
// src/index.ts
function createThunkMiddleware(extraArgument) {
  const middleware = _ref => {
    let {
      dispatch,
      getState
    } = _ref;
    return next => action => {
      if (typeof action === "function") {
        return action(dispatch, getState, extraArgument);
      }
      return next(action);
    };
  };
  return middleware;
}
var redux_thunk_thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;

;// CONCATENATED MODULE: ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs

// src/index.ts




// src/createDraftSafeSelector.ts


var createDraftSafeSelectorCreator = function () {
  const createSelector2 = (0,reselect/* createSelectorCreator */.wN)(...arguments);
  const createDraftSafeSelector2 = Object.assign(function () {
    const selector = createSelector2(...arguments);
    const wrappedSelector = function (value) {
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      return selector(isDraft(value) ? current(value) : value, ...rest);
    };
    Object.assign(wrappedSelector, selector);
    return wrappedSelector;
  }, {
    withTypes: () => createDraftSafeSelector2
  });
  return createDraftSafeSelector2;
};
var createDraftSafeSelector = createDraftSafeSelectorCreator(reselect/* weakMapMemoize */.kO);

// src/configureStore.ts


// src/devtoolsExtension.ts

var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return redux/* compose */.qC;
  return redux/* compose */.qC.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function () {
  return function (noop3) {
    return noop3;
  };
};

// src/getDefaultMiddleware.ts


// src/createAction.ts


// src/tsHelpers.ts
var hasMatchFunction = v => {
  return v && typeof v.match === "function";
};

// src/createAction.ts
function createAction(type, prepareAction) {
  function actionCreator() {
    if (prepareAction) {
      let prepared = prepareAction(...arguments);
      if (!prepared) {
        throw new Error( true ? formatProdErrorMessage(0) : 0);
      }
      return {
        type,
        payload: prepared.payload,
        ...("meta" in prepared && {
          meta: prepared.meta
        }),
        ...("error" in prepared && {
          error: prepared.error
        })
      };
    }
    return {
      type,
      payload: arguments.length <= 0 ? undefined : arguments[0]
    };
  }
  actionCreator.toString = () => "".concat(type);
  actionCreator.type = type;
  actionCreator.match = action => (0,redux/* isAction */.LG)(action) && action.type === type;
  return actionCreator;
}
function isActionCreator(action) {
  return typeof action === "function" && "type" in action &&
  // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hasMatchFunction(action);
}
function isFSA(action) {
  return isAction(action) && Object.keys(action).every(isValidKey);
}
function isValidKey(key) {
  return ["type", "payload", "error", "meta"].indexOf(key) > -1;
}

// src/actionCreatorInvariantMiddleware.ts
function getMessage(type) {
  const splitType = type ? "".concat(type).split("/") : [];
  const actionName = splitType[splitType.length - 1] || "actionCreator";
  return "Detected an action creator with type \"".concat(type || "unknown", "\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. `dispatch(").concat(actionName, "())` instead of `dispatch(").concat(actionName, ")`. This is necessary even if the action has no payload.");
}
function createActionCreatorInvariantMiddleware() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (true) {
    return () => next => action => next(action);
  }
  const {
    isActionCreator: isActionCreator2 = isActionCreator
  } = options;
  return () => next => action => {
    if (isActionCreator2(action)) {
      console.warn(getMessage(action.type));
    }
    return next(action);
  };
}

// src/utils.ts

function getTimeMeasureUtils(maxDelay, fnName) {
  let elapsed = 0;
  return {
    measureTime(fn) {
      const started = Date.now();
      try {
        return fn();
      } finally {
        const finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn("".concat(fnName, " took ").concat(elapsed, "ms, which is more than the warning threshold of ").concat(maxDelay, "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that."));
      }
    }
  };
}
function find(iterable, comparator) {
  for (const entry of iterable) {
    if (comparator(entry)) {
      return entry;
    }
  }
  return void 0;
}
var Tuple = class _Tuple extends Array {
  constructor() {
    super(...arguments);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat() {
    for (var _len2 = arguments.length, arr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      arr[_key2] = arguments[_key2];
    }
    return super.concat.apply(this, arr);
  }
  prepend() {
    for (var _len3 = arguments.length, arr = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      arr[_key3] = arguments[_key3];
    }
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {}) : val;
}
function emplace(map, key, handler) {
  if (map.has(key)) {
    let value = map.get(key);
    if (handler.update) {
      value = handler.update(value, key, map);
      map.set(key, value);
    }
    return value;
  }
  if (!handler.insert) throw new Error( true ? formatProdErrorMessage(10) : 0);
  const inserted = handler.insert(key, map);
  map.set(key, inserted);
  return inserted;
}

// src/immutableStateInvariantMiddleware.ts
function isImmutableDefault(value) {
  return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable) {
  let ignorePaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let obj = arguments.length > 2 ? arguments[2] : undefined;
  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
  let checkedObjects = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : /* @__PURE__ */new Set();
  const tracked = {
    value: obj
  };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (const key in obj) {
      const childPath = path ? path + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable) {
  let ignoredPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let trackedProperty = arguments.length > 2 ? arguments[2] : undefined;
  let obj = arguments.length > 3 ? arguments[3] : undefined;
  let sameParentRef = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  let path = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "";
  const prevObj = trackedProperty ? trackedProperty.value : void 0;
  const sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path
    };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  }
  const keysToDetect = {};
  for (let key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (let key in obj) {
    keysToDetect[key] = true;
  }
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (let key in keysToDetect) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some(ignored => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
    if (result.wasMutated) {
      return result;
    }
  }
  return {
    wasMutated: false
  };
}
function createImmutableStateInvariantMiddleware() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (true) {
    return () => next => action => next(action);
  } else { var stringify, getSerialize; }
}

// src/serializableStateInvariantMiddleware.ts

function isPlain(val) {
  const type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value) {
  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  let isSerializable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isPlain;
  let getEntries = arguments.length > 3 ? arguments[3] : undefined;
  let ignoredPaths = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  let cache = arguments.length > 5 ? arguments[5] : undefined;
  let foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (cache !== null && cache !== void 0 && cache.has(value)) return false;
  const entries = getEntries != null ? getEntries(value) : Object.entries(value);
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const [key, nestedValue] of entries) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some(ignored => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  if (cache && isNestedFrozen(value)) cache.add(value);
  return false;
}
function isNestedFrozen(value) {
  if (!Object.isFrozen(value)) return false;
  for (const nestedValue of Object.values(value)) {
    if (typeof nestedValue !== "object" || nestedValue === null) continue;
    if (!isNestedFrozen(nestedValue)) return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (true) {
    return () => next => action => next(action);
  } else {}
}

// src/getDefaultMiddleware.ts
function isBoolean(x) {
  return typeof x === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
  const {
    thunk = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options !== null && options !== void 0 ? options : {};
  let middlewareArray = new Tuple();
  if (thunk) {
    if (isBoolean(thunk)) {
      middlewareArray.push(redux_thunk_thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk.extraArgument));
    }
  }
  if (false) {}
  return middlewareArray;
};

// src/autoBatchEnhancer.ts
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = () => payload => ({
  payload,
  meta: {
    [SHOULD_AUTOBATCH]: true
  }
});
var createQueueWithTimer = timeout => {
  return notify => {
    setTimeout(notify, timeout);
  };
};
var rAF = typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);
var autoBatchEnhancer = function () {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    type: "raf"
  };
  return next => function () {
    const store = next(...arguments);
    let notifying = true;
    let shouldNotifyAtEndOfTick = false;
    let notificationQueued = false;
    const listeners = /* @__PURE__ */new Set();
    const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? rAF : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
    const notifyListeners = () => {
      notificationQueued = false;
      if (shouldNotifyAtEndOfTick) {
        shouldNotifyAtEndOfTick = false;
        listeners.forEach(l => l());
      }
    };
    return Object.assign({}, store, {
      // Override the base `store.subscribe` method to keep original listeners
      // from running if we're delaying notifications
      subscribe(listener2) {
        const wrappedListener = () => notifying && listener2();
        const unsubscribe = store.subscribe(wrappedListener);
        listeners.add(listener2);
        return () => {
          unsubscribe();
          listeners.delete(listener2);
        };
      },
      // Override the base `store.dispatch` method so that we can check actions
      // for the `shouldAutoBatch` flag and determine if batching is active
      dispatch(action) {
        try {
          var _action$meta;
          notifying = !(action !== null && action !== void 0 && (_action$meta = action.meta) !== null && _action$meta !== void 0 && _action$meta[SHOULD_AUTOBATCH]);
          shouldNotifyAtEndOfTick = !notifying;
          if (shouldNotifyAtEndOfTick) {
            if (!notificationQueued) {
              notificationQueued = true;
              queueCallback(notifyListeners);
            }
          }
          return store.dispatch(action);
        } finally {
          notifying = true;
        }
      }
    });
  };
};

// src/getDefaultEnhancers.ts
var buildGetDefaultEnhancers = middlewareEnhancer => function getDefaultEnhancers(options) {
  const {
    autoBatch = true
  } = options !== null && options !== void 0 ? options : {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};

// src/configureStore.ts
var IS_PRODUCTION = "production" === "production";
function configureStore(options) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware,
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if ((0,redux/* isPlainObject */.PO)(reducer)) {
    rootReducer = (0,redux/* combineReducers */.UY)(reducer);
  } else {
    throw new Error( true ? formatProdErrorMessage(1) : 0);
  }
  if (!IS_PRODUCTION && middleware && typeof middleware !== "function") {
    throw new Error( true ? formatProdErrorMessage(2) : 0);
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
      throw new Error( true ? formatProdErrorMessage(3) : 0);
    }
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  if (!IS_PRODUCTION && finalMiddleware.some(item => typeof item !== "function")) {
    throw new Error( true ? formatProdErrorMessage(4) : 0);
  }
  let finalCompose = redux/* compose */.qC;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: !IS_PRODUCTION,
      ...(typeof devTools === "object" && devTools)
    });
  }
  const middlewareEnhancer = (0,redux/* applyMiddleware */.md)(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  if (!IS_PRODUCTION && enhancers && typeof enhancers !== "function") {
    throw new Error( true ? formatProdErrorMessage(5) : 0);
  }
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {
    throw new Error( true ? formatProdErrorMessage(6) : 0);
  }
  if (!IS_PRODUCTION && storeEnhancers.some(item => typeof item !== "function")) {
    throw new Error( true ? formatProdErrorMessage(7) : 0);
  }
  if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
    console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return (0,redux/* createStore */.MT)(rootReducer, preloadedState, composedEnhancer);
}

// src/createReducer.ts


// src/mapBuilders.ts
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      if (false) {}
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error( true ? formatProdErrorMessage(28) : 0);
      }
      if (type in actionsMap) {
        throw new Error( true ? formatProdErrorMessage(29) : 0);
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher(matcher, reducer) {
      if (false) {}
      actionMatchers.push({
        matcher,
        reducer
      });
      return builder;
    },
    addDefaultCase(reducer) {
      if (false) {}
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}

// src/createReducer.ts
function isStateFunction(x) {
  return typeof x === "function";
}
function createReducer(initialState, mapOrBuilderCallback) {
  if (false) {}
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState)) {
    getInitialState = () => freezeDraftable(initialState());
  } else {
    const frozenInitialState = freezeDraftable(initialState);
    getInitialState = () => frozenInitialState;
  }
  function reducer() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getInitialState();
    let action = arguments.length > 1 ? arguments[1] : undefined;
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(_ref2 => {
      let {
        matcher
      } = _ref2;
      return matcher(action);
    }).map(_ref3 => {
      let {
        reducer: reducer2
      } = _ref3;
      return reducer2;
    })];
    if (caseReducers.filter(cr => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw new Error( true ? formatProdErrorMessage(9) : 0);
          }
          return result;
        } else {
          return produce(previousState, draft => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}

// src/nanoid.ts
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = function () {
  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;
  let id = "";
  let i = size;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};

// src/matchers.ts
var matches = (matcher, action) => {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf() {
  for (var _len4 = arguments.length, matchers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    matchers[_key4] = arguments[_key4];
  }
  return action => {
    return matchers.some(matcher => matches(matcher, action));
  };
}
function isAllOf() {
  for (var _len5 = arguments.length, matchers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    matchers[_key5] = arguments[_key5];
  }
  return action => {
    return matchers.every(matcher => matches(matcher, action));
  };
}
function hasExpectedRequestMetadata(action, validStatus) {
  if (!action || !action.meta) return false;
  const hasValidRequestId = typeof action.meta.requestId === "string";
  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
  return hasValidRequestId && hasValidRequestStatus;
}
function isAsyncThunkArray(a) {
  return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
}
function isPending() {
  for (var _len6 = arguments.length, asyncThunks = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    asyncThunks[_key6] = arguments[_key6];
  }
  if (asyncThunks.length === 0) {
    return action => hasExpectedRequestMetadata(action, ["pending"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isPending()(asyncThunks[0]);
  }
  return action => {
    const matchers = asyncThunks.map(asyncThunk => asyncThunk.pending);
    const combinedMatcher = isAnyOf(...matchers);
    return combinedMatcher(action);
  };
}
function isRejected() {
  for (var _len7 = arguments.length, asyncThunks = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    asyncThunks[_key7] = arguments[_key7];
  }
  if (asyncThunks.length === 0) {
    return action => hasExpectedRequestMetadata(action, ["rejected"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejected()(asyncThunks[0]);
  }
  return action => {
    const matchers = asyncThunks.map(asyncThunk => asyncThunk.rejected);
    const combinedMatcher = isAnyOf(...matchers);
    return combinedMatcher(action);
  };
}
function isRejectedWithValue() {
  for (var _len8 = arguments.length, asyncThunks = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
    asyncThunks[_key8] = arguments[_key8];
  }
  const hasFlag = action => {
    return action && action.meta && action.meta.rejectedWithValue;
  };
  if (asyncThunks.length === 0) {
    return action => {
      const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);
      return combinedMatcher(action);
    };
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejectedWithValue()(asyncThunks[0]);
  }
  return action => {
    const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);
    return combinedMatcher(action);
  };
}
function isFulfilled() {
  for (var _len9 = arguments.length, asyncThunks = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    asyncThunks[_key9] = arguments[_key9];
  }
  if (asyncThunks.length === 0) {
    return action => hasExpectedRequestMetadata(action, ["fulfilled"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isFulfilled()(asyncThunks[0]);
  }
  return action => {
    const matchers = asyncThunks.map(asyncThunk => asyncThunk.fulfilled);
    const combinedMatcher = isAnyOf(...matchers);
    return combinedMatcher(action);
  };
}
function isAsyncThunkAction() {
  for (var _len10 = arguments.length, asyncThunks = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
    asyncThunks[_key10] = arguments[_key10];
  }
  if (asyncThunks.length === 0) {
    return action => hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isAsyncThunkAction()(asyncThunks[0]);
  }
  return action => {
    const matchers = [];
    for (const asyncThunk of asyncThunks) {
      matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);
    }
    const combinedMatcher = isAnyOf(...matchers);
    return combinedMatcher(action);
  };
}

// src/createAsyncThunk.ts
var commonProperties = ["name", "message", "stack", "code"];
var RejectWithValue = class RejectWithValue {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    (0,defineProperty/* default */.Z)(this, "_type", void 0);
    this.payload = payload;
    this.meta = meta;
  }
};
var FulfillWithMeta = class FulfillWithMeta {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    (0,defineProperty/* default */.Z)(this, "_type", void 0);
    this.payload = payload;
    this.meta = meta;
  }
};
var miniSerializeError = value => {
  if (typeof value === "object" && value !== null) {
    const simpleError = {};
    for (const property of commonProperties) {
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return {
    message: String(value)
  };
};
var createAsyncThunk = /* @__PURE__ */(() => {
  function createAsyncThunk2(typePrefix, payloadCreator, options) {
    const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
      payload,
      meta: {
        ...(meta || {}),
        arg,
        requestId,
        requestStatus: "fulfilled"
      }
    }));
    const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
      payload: void 0,
      meta: {
        ...(meta || {}),
        arg,
        requestId,
        requestStatus: "pending"
      }
    }));
    const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
      payload,
      error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
      meta: {
        ...(meta || {}),
        arg,
        requestId,
        rejectedWithValue: !!payload,
        requestStatus: "rejected",
        aborted: (error === null || error === void 0 ? void 0 : error.name) === "AbortError",
        condition: (error === null || error === void 0 ? void 0 : error.name) === "ConditionError"
      }
    }));
    function actionCreator(arg) {
      return (dispatch, getState, extra) => {
        const requestId = options !== null && options !== void 0 && options.idGenerator ? options.idGenerator(arg) : nanoid();
        const abortController = new AbortController();
        let abortHandler;
        let abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        const promise = async function () {
          let finalAction;
          try {
            var _options$condition, _options$getPendingMe;
            let conditionResult = options === null || options === void 0 ? void 0 : (_options$condition = options.condition) === null || _options$condition === void 0 ? void 0 : _options$condition.call(options, arg, {
              getState,
              extra
            });
            if (isThenable(conditionResult)) {
              conditionResult = await conditionResult;
            }
            if (conditionResult === false || abortController.signal.aborted) {
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            }
            const abortedPromise = new Promise((_, reject) => {
              abortHandler = () => {
                reject({
                  name: "AbortError",
                  message: abortReason || "Aborted"
                });
              };
              abortController.signal.addEventListener("abort", abortHandler);
            });
            dispatch(pending(requestId, arg, options === null || options === void 0 ? void 0 : (_options$getPendingMe = options.getPendingMeta) === null || _options$getPendingMe === void 0 ? void 0 : _options$getPendingMe.call(options, {
              requestId,
              arg
            }, {
              getState,
              extra
            })));
            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch,
              getState,
              extra,
              requestId,
              signal: abortController.signal,
              abort,
              rejectWithValue: (value, meta) => {
                return new RejectWithValue(value, meta);
              },
              fulfillWithValue: (value, meta) => {
                return new FulfillWithMeta(value, meta);
              }
            })).then(result => {
              if (result instanceof RejectWithValue) {
                throw result;
              }
              if (result instanceof FulfillWithMeta) {
                return fulfilled(result.payload, requestId, arg, result.meta);
              }
              return fulfilled(result, requestId, arg);
            })]);
          } catch (err) {
            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
          } finally {
            if (abortHandler) {
              abortController.signal.removeEventListener("abort", abortHandler);
            }
          }
          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
          if (!skipDispatch) {
            dispatch(finalAction);
          }
          return finalAction;
        }();
        return Object.assign(promise, {
          abort,
          requestId,
          arg,
          unwrap() {
            return promise.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      settled: isAnyOf(rejected, fulfilled),
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = () => createAsyncThunk2;
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}

// src/createSlice.ts
var asyncThunkSymbol = /* @__PURE__ */Symbol.for("rtk-slice-createasyncthunk");
var asyncThunkCreator = {
  [asyncThunkSymbol]: createAsyncThunk
};
var ReducerType = /* @__PURE__ */(ReducerType2 => {
  ReducerType2["reducer"] = "reducer";
  ReducerType2["reducerWithPrepare"] = "reducerWithPrepare";
  ReducerType2["asyncThunk"] = "asyncThunk";
  return ReducerType2;
})(ReducerType || {});
function getType(slice, actionKey) {
  return "".concat(slice, "/").concat(actionKey);
}
function buildCreateSlice() {
  var _creators$asyncThunk;
  let {
    creators
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const cAT = creators === null || creators === void 0 ? void 0 : (_creators$asyncThunk = creators.asyncThunk) === null || _creators$asyncThunk === void 0 ? void 0 : _creators$asyncThunk[asyncThunkSymbol];
  return function createSlice2(options) {
    const {
      name,
      reducerPath = name
    } = options;
    if (!name) {
      throw new Error( true ? formatProdErrorMessage(11) : 0);
    }
    if (typeof process !== "undefined" && "production" === "development") {}
    const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
    const reducerNames = Object.keys(reducers);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer2) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error( true ? formatProdErrorMessage(12) : 0);
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error( true ? formatProdErrorMessage(13) : 0);
        }
        context.sliceCaseReducersByType[type] = reducer2;
        return contextMethods;
      },
      addMatcher(matcher, reducer2) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer2
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer2) {
        context.sliceCaseReducersByName[name2] = reducer2;
        return contextMethods;
      }
    };
    reducerNames.forEach(reducerName => {
      const reducerDefinition = reducers[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      if (false) {}
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options.initialState, builder => {
        for (let key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (let sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m of actionMatchers) {
          builder.addMatcher(m.matcher, m.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = state => state;
    const injectedSelectorCache = /* @__PURE__ */new Map();
    let _reducer;
    function reducer(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2) {
      let injected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getInitialState();
          } else if (false) {}
        }
        return sliceState;
      }
      function getSelectors() {
        let selectState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : selectSelf;
        const selectorCache = emplace(injectedSelectorCache, injected, {
          insert: () => /* @__PURE__ */new WeakMap()
        });
        return emplace(selectorCache, selectState, {
          insert: () => {
            const map = {};
            for (const [name2, selector] of Object.entries((_options$selectors = options.selectors) !== null && _options$selectors !== void 0 ? _options$selectors : {})) {
              var _options$selectors;
              map[name2] = wrapSelector(selector, selectState, getInitialState, injected);
            }
            return map;
          }
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice = {
      name,
      reducer,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable) {
        let {
          reducerPath: pathOpt,
          ...config
        } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const newReducerPath = pathOpt !== null && pathOpt !== void 0 ? pathOpt : reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer
        }, config);
        return {
          ...slice,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      } else if (false) {}
    }
    for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
      args[_key11 - 1] = arguments[_key11];
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = /* @__PURE__ */buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config) {
    return {
      _reducerDefinitionType: "asyncThunk" /* asyncThunk */,
      payloadCreator,
      ...config
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name]() {
          return caseReducer(...arguments);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer" /* reducer */
      });
    },

    preparedReducer(prepare, reducer) {
      return {
        _reducerDefinitionType: "reducerWithPrepare" /* reducerWithPrepare */,
        prepare,
        reducer
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition(_ref4, maybeReducerWithPrepare, context) {
  let {
    type,
    reducerName,
    createNotation
  } = _ref4;
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error( true ? formatProdErrorMessage(17) : 0);
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk" /* asyncThunk */;
}

function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare" /* reducerWithPrepare */;
}

function handleThunkCaseReducerDefinition(_ref5, reducerDefinition, context, cAT) {
  let {
    type,
    reducerName
  } = _ref5;
  if (!cAT) {
    throw new Error( true ? formatProdErrorMessage(18) : 0);
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options
  } = reducerDefinition;
  const thunk = cAT(type, payloadCreator, options);
  context.exposeAction(reducerName, thunk);
  if (fulfilled) {
    context.addCase(thunk.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop,
    pending: pending || noop,
    rejected: rejected || noop,
    settled: settled || noop
  });
}
function noop() {}

// src/entities/entity_state.ts
function getInitialEntityState() {
  return {
    ids: [],
    entities: {}
  };
}
function createInitialStateFactory(stateAdapter) {
  function getInitialState() {
    let additionalState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let entities = arguments.length > 1 ? arguments[1] : undefined;
    const state = Object.assign(getInitialEntityState(), additionalState);
    return entities ? stateAdapter.setAll(state, entities) : state;
  }
  return {
    getInitialState
  };
}

// src/entities/state_selectors.ts
function createSelectorsFactory() {
  function getSelectors(selectState) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      createSelector: createSelector2 = createDraftSafeSelector
    } = options;
    const selectIds = state => state.ids;
    const selectEntities = state => state.entities;
    const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map(id => entities[id]));
    const selectId = (_, id) => id;
    const selectById = (entities, id) => entities[id];
    const selectTotal = createSelector2(selectIds, ids => ids.length);
    if (!selectState) {
      return {
        selectIds,
        selectEntities,
        selectAll,
        selectTotal,
        selectById: createSelector2(selectEntities, selectId, selectById)
      };
    }
    const selectGlobalizedEntities = createSelector2(selectState, selectEntities);
    return {
      selectIds: createSelector2(selectState, selectIds),
      selectEntities: selectGlobalizedEntities,
      selectAll: createSelector2(selectState, selectAll),
      selectTotal: createSelector2(selectState, selectTotal),
      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)
    };
  }
  return {
    getSelectors
  };
}

// src/entities/state_adapter.ts

var isDraftTyped = (/* unused pure expression or super */ null && (isDraft3));
function createSingleArgumentStateOperator(mutator) {
  const operator = createStateOperator((_, state) => mutator(state));
  return function operation(state) {
    return operator(state, void 0);
  };
}
function createStateOperator(mutator) {
  return function operation(state, arg) {
    function isPayloadActionArgument(arg2) {
      return isFSA(arg2);
    }
    const runMutator = draft => {
      if (isPayloadActionArgument(arg)) {
        mutator(arg.payload, draft);
      } else {
        mutator(arg, draft);
      }
    };
    if (isDraftTyped(state)) {
      runMutator(state);
      return state;
    }
    return createNextState3(state, runMutator);
  };
}

// src/entities/utils.ts
function selectIdValue(entity, selectId) {
  const key = selectId(entity);
  if (false) {}
  return key;
}
function ensureEntitiesArray(entities) {
  if (!Array.isArray(entities)) {
    entities = Object.values(entities);
  }
  return entities;
}
function splitAddedUpdatedEntities(newEntities, selectId, state) {
  newEntities = ensureEntitiesArray(newEntities);
  const added = [];
  const updated = [];
  for (const entity of newEntities) {
    const id = selectIdValue(entity, selectId);
    if (id in state.entities) {
      updated.push({
        id,
        changes: entity
      });
    } else {
      added.push(entity);
    }
  }
  return [added, updated];
}

// src/entities/unsorted_state_adapter.ts
function createUnsortedStateAdapter(selectId) {
  function addOneMutably(entity, state) {
    const key = selectIdValue(entity, selectId);
    if (key in state.entities) {
      return;
    }
    state.ids.push(key);
    state.entities[key] = entity;
  }
  function addManyMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    for (const entity of newEntities) {
      addOneMutably(entity, state);
    }
  }
  function setOneMutably(entity, state) {
    const key = selectIdValue(entity, selectId);
    if (!(key in state.entities)) {
      state.ids.push(key);
    }
    ;
    state.entities[key] = entity;
  }
  function setManyMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    for (const entity of newEntities) {
      setOneMutably(entity, state);
    }
  }
  function setAllMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    state.ids = [];
    state.entities = {};
    addManyMutably(newEntities, state);
  }
  function removeOneMutably(key, state) {
    return removeManyMutably([key], state);
  }
  function removeManyMutably(keys, state) {
    let didMutate = false;
    keys.forEach(key => {
      if (key in state.entities) {
        delete state.entities[key];
        didMutate = true;
      }
    });
    if (didMutate) {
      state.ids = state.ids.filter(id => id in state.entities);
    }
  }
  function removeAllMutably(state) {
    Object.assign(state, {
      ids: [],
      entities: {}
    });
  }
  function takeNewKey(keys, update, state) {
    const original3 = state.entities[update.id];
    if (original3 === void 0) {
      return false;
    }
    const updated = Object.assign({}, original3, update.changes);
    const newKey = selectIdValue(updated, selectId);
    const hasNewKey = newKey !== update.id;
    if (hasNewKey) {
      keys[update.id] = newKey;
      delete state.entities[update.id];
    }
    ;
    state.entities[newKey] = updated;
    return hasNewKey;
  }
  function updateOneMutably(update, state) {
    return updateManyMutably([update], state);
  }
  function updateManyMutably(updates, state) {
    const newKeys = {};
    const updatesPerEntity = {};
    updates.forEach(update => {
      if (update.id in state.entities) {
        updatesPerEntity[update.id] = {
          id: update.id,
          // Spreads ignore falsy values, so this works even if there isn't
          // an existing update already at this key
          changes: {
            ...(updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null),
            ...update.changes
          }
        };
      }
    });
    updates = Object.values(updatesPerEntity);
    const didMutateEntities = updates.length > 0;
    if (didMutateEntities) {
      const didMutateIds = updates.filter(update => takeNewKey(newKeys, update, state)).length > 0;
      if (didMutateIds) {
        state.ids = Object.values(state.entities).map(e => selectIdValue(e, selectId));
      }
    }
  }
  function upsertOneMutably(entity, state) {
    return upsertManyMutably([entity], state);
  }
  function upsertManyMutably(newEntities, state) {
    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);
    updateManyMutably(updated, state);
    addManyMutably(added, state);
  }
  return {
    removeAll: createSingleArgumentStateOperator(removeAllMutably),
    addOne: createStateOperator(addOneMutably),
    addMany: createStateOperator(addManyMutably),
    setOne: createStateOperator(setOneMutably),
    setMany: createStateOperator(setManyMutably),
    setAll: createStateOperator(setAllMutably),
    updateOne: createStateOperator(updateOneMutably),
    updateMany: createStateOperator(updateManyMutably),
    upsertOne: createStateOperator(upsertOneMutably),
    upsertMany: createStateOperator(upsertManyMutably),
    removeOne: createStateOperator(removeOneMutably),
    removeMany: createStateOperator(removeManyMutably)
  };
}

// src/entities/sorted_state_adapter.ts
function createSortedStateAdapter(selectId, sort) {
  const {
    removeOne,
    removeMany,
    removeAll
  } = createUnsortedStateAdapter(selectId);
  function addOneMutably(entity, state) {
    return addManyMutably([entity], state);
  }
  function addManyMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    const models = newEntities.filter(model => !(selectIdValue(model, selectId) in state.entities));
    if (models.length !== 0) {
      merge(models, state);
    }
  }
  function setOneMutably(entity, state) {
    return setManyMutably([entity], state);
  }
  function setManyMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    if (newEntities.length !== 0) {
      merge(newEntities, state);
    }
  }
  function setAllMutably(newEntities, state) {
    newEntities = ensureEntitiesArray(newEntities);
    state.entities = {};
    state.ids = [];
    addManyMutably(newEntities, state);
  }
  function updateOneMutably(update, state) {
    return updateManyMutably([update], state);
  }
  function updateManyMutably(updates, state) {
    let appliedUpdates = false;
    for (let update of updates) {
      const entity = state.entities[update.id];
      if (!entity) {
        continue;
      }
      appliedUpdates = true;
      Object.assign(entity, update.changes);
      const newId = selectId(entity);
      if (update.id !== newId) {
        delete state.entities[update.id];
        state.entities[newId] = entity;
      }
    }
    if (appliedUpdates) {
      resortEntities(state);
    }
  }
  function upsertOneMutably(entity, state) {
    return upsertManyMutably([entity], state);
  }
  function upsertManyMutably(newEntities, state) {
    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);
    updateManyMutably(updated, state);
    addManyMutably(added, state);
  }
  function areArraysEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length && i < b.length; i++) {
      if (a[i] === b[i]) {
        continue;
      }
      return false;
    }
    return true;
  }
  function merge(models, state) {
    models.forEach(model => {
      ;
      state.entities[selectId(model)] = model;
    });
    resortEntities(state);
  }
  function resortEntities(state) {
    const allEntities = Object.values(state.entities);
    allEntities.sort(sort);
    const newSortedIds = allEntities.map(selectId);
    const {
      ids
    } = state;
    if (!areArraysEqual(ids, newSortedIds)) {
      state.ids = newSortedIds;
    }
  }
  return {
    removeOne,
    removeMany,
    removeAll,
    addOne: createStateOperator(addOneMutably),
    updateOne: createStateOperator(updateOneMutably),
    upsertOne: createStateOperator(upsertOneMutably),
    setOne: createStateOperator(setOneMutably),
    setMany: createStateOperator(setManyMutably),
    setAll: createStateOperator(setAllMutably),
    addMany: createStateOperator(addManyMutably),
    updateMany: createStateOperator(updateManyMutably),
    upsertMany: createStateOperator(upsertManyMutably)
  };
}

// src/entities/create_adapter.ts
function createEntityAdapter() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    selectId,
    sortComparer
  } = {
    sortComparer: false,
    selectId: instance => instance.id,
    ...options
  };
  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
  const stateFactory = createInitialStateFactory(stateAdapter);
  const selectorsFactory = createSelectorsFactory();
  return {
    selectId,
    sortComparer,
    ...stateFactory,
    ...selectorsFactory,
    ...stateAdapter
  };
}

// src/listenerMiddleware/index.ts


// src/listenerMiddleware/exceptions.ts
var task = "task";
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = "task-".concat(cancelled);
var taskCompleted = "task-".concat(completed);
var listenerCancelled = "".concat(listener, "-").concat(cancelled);
var listenerCompleted = "".concat(listener, "-").concat(completed);
var TaskAbortError = class TaskAbortError {
  constructor(code) {
    _defineProperty(this, "name", "TaskAbortError");
    _defineProperty(this, "message", void 0);
    this.code = code;
    this.message = "".concat(task, " ").concat(cancelled, " (reason: ").concat(code, ")");
  }
};

// src/listenerMiddleware/utils.ts
var assertFunction = (func, expected) => {
  if (typeof func !== "function") {
    throw new Error( true ? formatProdErrorMessage(32) : 0);
  }
};
var noop2 = () => {};
var catchRejection = function (promise) {
  let onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop2;
  promise.catch(onError);
  return promise;
};
var addAbortSignalListener = (abortSignal, callback) => {
  abortSignal.addEventListener("abort", callback, {
    once: true
  });
  return () => abortSignal.removeEventListener("abort", callback);
};
var abortControllerWithReason = (abortController, reason) => {
  const signal = abortController.signal;
  if (signal.aborted) {
    return;
  }
  if (!("reason" in signal)) {
    Object.defineProperty(signal, "reason", {
      enumerable: true,
      value: reason,
      configurable: true,
      writable: true
    });
  }
  ;
  abortController.abort(reason);
};

// src/listenerMiddleware/task.ts
var validateActive = signal => {
  if (signal.aborted) {
    const {
      reason
    } = signal;
    throw new TaskAbortError(reason);
  }
};
function raceWithSignal(signal, promise) {
  let cleanup = noop2;
  return new Promise((resolve, reject) => {
    const notifyRejection = () => reject(new TaskAbortError(signal.reason));
    if (signal.aborted) {
      notifyRejection();
      return;
    }
    cleanup = addAbortSignalListener(signal, notifyRejection);
    promise.finally(() => cleanup()).then(resolve, reject);
  }).finally(() => {
    cleanup = noop2;
  });
}
var runTask = async (task2, cleanUp) => {
  try {
    await Promise.resolve();
    const value = await task2();
    return {
      status: "ok",
      value
    };
  } catch (error) {
    return {
      status: error instanceof TaskAbortError ? "cancelled" : "rejected",
      error
    };
  } finally {
    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();
  }
};
var createPause = signal => {
  return promise => {
    return catchRejection(raceWithSignal(signal, promise).then(output => {
      validateActive(signal);
      return output;
    }));
  };
};
var createDelay = signal => {
  const pause = createPause(signal);
  return timeoutMs => {
    return pause(new Promise(resolve => setTimeout(resolve, timeoutMs)));
  };
};

// src/listenerMiddleware/index.ts
var {
  assign: redux_toolkit_modern_assign
} = Object;
var INTERNAL_NIL_TOKEN = {};
var alm = "listenerMiddleware";
var createFork = (parentAbortSignal, parentBlockingPromises) => {
  const linkControllers = controller => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));
  return (taskExecutor, opts) => {
    assertFunction(taskExecutor, "taskExecutor");
    const childAbortController = new AbortController();
    linkControllers(childAbortController);
    const result = runTask(async () => {
      validateActive(parentAbortSignal);
      validateActive(childAbortController.signal);
      const result2 = await taskExecutor({
        pause: createPause(childAbortController.signal),
        delay: createDelay(childAbortController.signal),
        signal: childAbortController.signal
      });
      validateActive(childAbortController.signal);
      return result2;
    }, () => abortControllerWithReason(childAbortController, taskCompleted));
    if (opts !== null && opts !== void 0 && opts.autoJoin) {
      parentBlockingPromises.push(result.catch(noop2));
    }
    return {
      result: createPause(parentAbortSignal)(result),
      cancel() {
        abortControllerWithReason(childAbortController, taskCancelled);
      }
    };
  };
};
var createTakePattern = (startListening, signal) => {
  const take = async (predicate, timeout) => {
    validateActive(signal);
    let unsubscribe = () => {};
    const tuplePromise = new Promise((resolve, reject) => {
      let stopListening = startListening({
        predicate,
        effect: (action, listenerApi) => {
          listenerApi.unsubscribe();
          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);
        }
      });
      unsubscribe = () => {
        stopListening();
        reject();
      };
    });
    const promises = [tuplePromise];
    if (timeout != null) {
      promises.push(new Promise(resolve => setTimeout(resolve, timeout, null)));
    }
    try {
      const output = await raceWithSignal(signal, Promise.race(promises));
      validateActive(signal);
      return output;
    } finally {
      unsubscribe();
    }
  };
  return (predicate, timeout) => catchRejection(take(predicate, timeout));
};
var getListenerEntryPropsFrom = options => {
  let {
    type,
    actionCreator,
    matcher,
    predicate,
    effect
  } = options;
  if (type) {
    predicate = createAction(type).match;
  } else if (actionCreator) {
    type = actionCreator.type;
    predicate = actionCreator.match;
  } else if (matcher) {
    predicate = matcher;
  } else if (predicate) {} else {
    throw new Error( true ? formatProdErrorMessage(21) : 0);
  }
  assertFunction(effect, "options.listener");
  return {
    predicate,
    type,
    effect
  };
};
var createListenerEntry = Object.assign(options => {
  const {
    type,
    predicate,
    effect
  } = getListenerEntryPropsFrom(options);
  const id = nanoid();
  const entry = {
    id,
    effect,
    type,
    predicate,
    pending: /* @__PURE__ */new Set(),
    unsubscribe: () => {
      throw new Error( true ? formatProdErrorMessage(22) : 0);
    }
  };
  return entry;
}, {
  withTypes: () => createListenerEntry
});
var cancelActiveListeners = entry => {
  entry.pending.forEach(controller => {
    abortControllerWithReason(controller, listenerCancelled);
  });
};
var createClearListenerMiddleware = listenerMap => {
  return () => {
    listenerMap.forEach(cancelActiveListeners);
    listenerMap.clear();
  };
};
var safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {
  try {
    errorHandler(errorToNotify, errorInfo);
  } catch (errorHandlerError) {
    setTimeout(() => {
      throw errorHandlerError;
    }, 0);
  }
};
var addListener = Object.assign(createAction("".concat(alm, "/add")), {
  withTypes: () => addListener
});
var clearAllListeners = createAction("".concat(alm, "/removeAll"));
var removeListener = Object.assign(createAction("".concat(alm, "/remove")), {
  withTypes: () => removeListener
});
var defaultErrorHandler = function () {
  for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
    args[_key12] = arguments[_key12];
  }
  console.error("".concat(alm, "/error"), ...args);
};
var createListenerMiddleware = function () {
  let middlewareOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const listenerMap = /* @__PURE__ */new Map();
  const {
    extra,
    onError = defaultErrorHandler
  } = middlewareOptions;
  assertFunction(onError, "onError");
  const insertEntry = entry => {
    entry.unsubscribe = () => listenerMap.delete(entry.id);
    listenerMap.set(entry.id, entry);
    return cancelOptions => {
      entry.unsubscribe();
      if (cancelOptions !== null && cancelOptions !== void 0 && cancelOptions.cancelActive) {
        cancelActiveListeners(entry);
      }
    };
  };
  const startListening = options => {
    let entry = find(Array.from(listenerMap.values()), existingEntry => existingEntry.effect === options.effect);
    if (!entry) {
      entry = createListenerEntry(options);
    }
    return insertEntry(entry);
  };
  Object.assign(startListening, {
    withTypes: () => startListening
  });
  const stopListening = options => {
    const {
      type,
      effect,
      predicate
    } = getListenerEntryPropsFrom(options);
    const entry = find(Array.from(listenerMap.values()), entry2 => {
      const matchPredicateOrType = typeof type === "string" ? entry2.type === type : entry2.predicate === predicate;
      return matchPredicateOrType && entry2.effect === effect;
    });
    if (entry) {
      entry.unsubscribe();
      if (options.cancelActive) {
        cancelActiveListeners(entry);
      }
    }
    return !!entry;
  };
  Object.assign(stopListening, {
    withTypes: () => stopListening
  });
  const notifyListener = async (entry, action, api, getOriginalState) => {
    const internalTaskController = new AbortController();
    const take = createTakePattern(startListening, internalTaskController.signal);
    const autoJoinPromises = [];
    try {
      entry.pending.add(internalTaskController);
      await Promise.resolve(entry.effect(action,
      // Use assign() rather than ... to avoid extra helper functions added to bundle
      redux_toolkit_modern_assign({}, api, {
        getOriginalState,
        condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),
        take,
        delay: createDelay(internalTaskController.signal),
        pause: createPause(internalTaskController.signal),
        extra,
        signal: internalTaskController.signal,
        fork: createFork(internalTaskController.signal, autoJoinPromises),
        unsubscribe: entry.unsubscribe,
        subscribe: () => {
          listenerMap.set(entry.id, entry);
        },
        cancelActiveListeners: () => {
          entry.pending.forEach((controller, _, set) => {
            if (controller !== internalTaskController) {
              abortControllerWithReason(controller, listenerCancelled);
              set.delete(controller);
            }
          });
        },
        cancel: () => {
          abortControllerWithReason(internalTaskController, listenerCancelled);
          entry.pending.delete(internalTaskController);
        },
        throwIfCancelled: () => {
          validateActive(internalTaskController.signal);
        }
      })));
    } catch (listenerError) {
      if (!(listenerError instanceof TaskAbortError)) {
        safelyNotifyError(onError, listenerError, {
          raisedBy: "effect"
        });
      }
    } finally {
      await Promise.all(autoJoinPromises);
      abortControllerWithReason(internalTaskController, listenerCompleted);
      entry.pending.delete(internalTaskController);
    }
  };
  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);
  const middleware = api => next => action => {
    if (!isAction3(action)) {
      return next(action);
    }
    if (addListener.match(action)) {
      return startListening(action.payload);
    }
    if (clearAllListeners.match(action)) {
      clearListenerMiddleware();
      return;
    }
    if (removeListener.match(action)) {
      return stopListening(action.payload);
    }
    let originalState = api.getState();
    const getOriginalState = () => {
      if (originalState === INTERNAL_NIL_TOKEN) {
        throw new Error( true ? formatProdErrorMessage(23) : 0);
      }
      return originalState;
    };
    let result;
    try {
      result = next(action);
      if (listenerMap.size > 0) {
        const currentState = api.getState();
        const listenerEntries = Array.from(listenerMap.values());
        for (const entry of listenerEntries) {
          let runListener = false;
          try {
            runListener = entry.predicate(action, currentState, originalState);
          } catch (predicateError) {
            runListener = false;
            safelyNotifyError(onError, predicateError, {
              raisedBy: "predicate"
            });
          }
          if (!runListener) {
            continue;
          }
          notifyListener(entry, action, api, getOriginalState);
        }
      }
    } finally {
      originalState = INTERNAL_NIL_TOKEN;
    }
    return result;
  };
  return {
    middleware,
    startListening,
    stopListening,
    clearListeners: clearListenerMiddleware
  };
};

// src/dynamicMiddleware/index.ts

var createMiddlewareEntry = middleware => ({
  id: nanoid(),
  middleware,
  applied: /* @__PURE__ */new Map()
});
var matchInstance = instanceId => action => {
  var _action$meta2;
  return (action === null || action === void 0 ? void 0 : (_action$meta2 = action.meta) === null || _action$meta2 === void 0 ? void 0 : _action$meta2.instanceId) === instanceId;
};
var createDynamicMiddleware = () => {
  const instanceId = nanoid();
  const middlewareMap = /* @__PURE__ */new Map();
  const withMiddleware = Object.assign(createAction("dynamicMiddleware/add", function () {
    for (var _len13 = arguments.length, middlewares = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      middlewares[_key13] = arguments[_key13];
    }
    return {
      payload: middlewares,
      meta: {
        instanceId
      }
    };
  }), {
    withTypes: () => withMiddleware
  });
  const addMiddleware = Object.assign(function addMiddleware2() {
    for (var _len14 = arguments.length, middlewares = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
      middlewares[_key14] = arguments[_key14];
    }
    middlewares.forEach(middleware2 => {
      let entry = find(Array.from(middlewareMap.values()), entry2 => entry2.middleware === middleware2);
      if (!entry) {
        entry = createMiddlewareEntry(middleware2);
      }
      middlewareMap.set(entry.id, entry);
    });
  }, {
    withTypes: () => addMiddleware
  });
  const getFinalMiddleware = api => {
    const appliedMiddleware = Array.from(middlewareMap.values()).map(entry => emplace(entry.applied, api, {
      insert: () => entry.middleware(api)
    }));
    return compose3(...appliedMiddleware);
  };
  const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));
  const middleware = api => next => action => {
    if (isWithMiddleware(action)) {
      addMiddleware(...action.payload);
      return api.dispatch;
    }
    return getFinalMiddleware(api)(next)(action);
  };
  return {
    middleware,
    addMiddleware,
    withMiddleware,
    instanceId
  };
};

// src/combineSlices.ts

var isSliceLike = maybeSliceLike => "reducerPath" in maybeSliceLike && typeof maybeSliceLike.reducerPath === "string";
var getReducers = slices => slices.flatMap(sliceOrMap => isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap));
var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");
var isStateProxy = value => !!value && !!value[ORIGINAL_STATE];
var stateProxyMap = /* @__PURE__ */new WeakMap();
var createStateProxy = (state, reducerMap) => emplace(stateProxyMap, state, {
  insert: () => new Proxy(state, {
    get: (target, prop, receiver) => {
      if (prop === ORIGINAL_STATE) return target;
      const result = Reflect.get(target, prop, receiver);
      if (typeof result === "undefined") {
        const reducer = reducerMap[prop.toString()];
        if (reducer) {
          const reducerResult = reducer(void 0, {
            type: nanoid()
          });
          if (typeof reducerResult === "undefined") {
            throw new Error( true ? formatProdErrorMessage(24) : 0);
          }
          return reducerResult;
        }
      }
      return result;
    }
  })
});
var redux_toolkit_modern_original = state => {
  if (!isStateProxy(state)) {
    throw new Error( true ? formatProdErrorMessage(25) : 0);
  }
  return state[ORIGINAL_STATE];
};
var noopReducer = function () {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return state;
};
function combineSlices() {
  for (var _len15 = arguments.length, slices = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
    slices[_key15] = arguments[_key15];
  }
  const reducerMap = Object.fromEntries(getReducers(slices));
  const getReducer = () => Object.keys(reducerMap).length ? combineReducers2(reducerMap) : noopReducer;
  let reducer = getReducer();
  function combinedReducer(state, action) {
    return reducer(state, action);
  }
  combinedReducer.withLazyLoadedSlices = () => combinedReducer;
  const inject = function (slice) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      reducerPath,
      reducer: reducerToInject
    } = slice;
    const currentReducer = reducerMap[reducerPath];
    if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {
      if (typeof process !== "undefined" && "production" === "development") {}
      return combinedReducer;
    }
    reducerMap[reducerPath] = reducerToInject;
    reducer = getReducer();
    return combinedReducer;
  };
  const selector = Object.assign(function makeSelector(selectorFn, selectState) {
    return function selector2(state) {
      for (var _len16 = arguments.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {
        args[_key16 - 1] = arguments[_key16];
      }
      return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);
    };
  }, {
    original: redux_toolkit_modern_original
  });
  return Object.assign(combinedReducer, {
    inject,
    selector
  });
}

// src/formatProdErrorMessage.ts
function formatProdErrorMessage(code) {
  return "Minified Redux Toolkit error #".concat(code, "; visit https://redux-toolkit.js.org/Errors?code=").concat(code, " for the full message or use the non-minified dev environment for full errors. ");
}


/***/ }),

/***/ 8113:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export Big */
/*
 *  big.js v6.2.1
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2022 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */

/************************************** EDITABLE DEFAULTS *****************************************/

// The default values below must be integers within the stated ranges.

/*
 * The maximum number of decimal places (DP) of the results of operations involving division:
 * div and sqrt, and pow with negative exponents.
 */
var DP = 20,
  // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,
  // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,
  // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,
  // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,
  // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
   */
  PE = 21,
  // 0 to 1000000

  /*
   * When true, an error will be thrown if a primitive number is passed to the Big constructor,
   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
   * primitive number without a loss of precision.
   */
  STRICT = false,
  // true or false

  /**************************************************************************************************/

  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',
  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

/*
 * Create and return a Big constructor.
 */
function _Big_() {
  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== 'string') {
        if (Big.strict === true && typeof n !== 'bigint') {
          throw TypeError(INVALID + 'value');
        }

        // Minus zero?
        n = n === 0 && 1 / n < 0 ? '-0' : String(n);
      }
      parse(x, n);
    }

    // Retain a reference to this Big constructor.
    // Shadow Big.prototype.constructor which points to Object.
    x.constructor = Big;
  }
  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.strict = STRICT;
  Big.roundDown = 0;
  Big.roundHalfUp = 1;
  Big.roundHalfEven = 2;
  Big.roundUp = 3;
  return Big;
}

/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse(x, n) {
  var e, i, nl;
  if (!NUMERIC.test(n)) {
    throw Error(INVALID + 'number');
  }

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {
    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {
    // Integer.
    e = n.length;
  }
  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;
  if (i == nl) {
    // Zero.
    x.c = [x.e = 0];
  } else {
    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }
  return x;
}

/*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, sd, rm, more) {
  var xc = x.c;
  if (rm === UNDEFINED) rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }
  if (sd < 1) {
    more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
    xc.length = 1;
    if (more) {
      // 1, 0.1, 0.01, 0.001, 0.0001 etc.
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {
      // Zero.
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {
    // xc[sd] is the digit after the digit that may be rounded up.
    more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);

    // Remove any digits after the required precision.
    xc.length = sd;

    // Round up?
    if (more) {
      // Rounding up may mean the previous digit has to be rounded up.
      for (; ++xc[--sd] > 9;) {
        xc[sd] = 0;
        if (sd === 0) {
          ++x.e;
          xc.unshift(1);
          break;
        }
      }
    }

    // Remove trailing zeros.
    for (sd = xc.length; !xc[--sd];) xc.pop();
  }
  return x;
}

/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */
function stringify(x, doExponential, isNonzero) {
  var e = x.e,
    s = x.c.join(''),
    n = s.length;

  // Exponential notation?
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

    // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--;) s += '0';
    } else if (e < n) {
      s = s.slice(0, e) + '.' + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }
  return x.s < 0 && isNonzero ? '-' + s : s;
}

// Prototype/instance methods

/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};

/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;
  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};

/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,
    // dividend
    b = (y = new Big(y)).c,
    // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }

  // Divisor is zero?
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }

  // Dividend is 0? Return +-0.
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }
  var bl,
    bt,
    n,
    cmp,
    ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),
    // remainder
    rl = r.length,
    q = y,
    // quotient
    qc = q.c = [],
    qi = 0,
    p = dp + (q.e = x.e - y.e) + 1; // precision of the result

  q.s = k;
  k = p < 0 ? 0 : p;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);
  do {
    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {
      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {
        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }
        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;else r = [a[ai]];
  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {
    // There can't be more than one zero.
    qc.shift();
    q.e--;
    p--;
  }

  // Round?
  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);
  return q;
};

/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return this.cmp(y) === 0;
};

/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};

/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};

/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};

/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};

/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i,
    j,
    t,
    xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }
  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big(x);
    } else {
      y.s = 1;
    }
    return y;
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {
    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }
    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {
    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;
    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }
    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }
  if (!xc[0]) {
    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }
  y.c = xc;
  y.e = ye;
  return y;
};

/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;
  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }
  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;
  if (ygtx) return new Big(x);
  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;
  return this.minus(x.times(y));
};

/*
 * Return a new Big whose value is the value of this Big negated.
 */
P.neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return x;
};

/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var e,
    k,
    t,
    x = this,
    Big = x.constructor;
  y = new Big(y);

  // Signs differ?
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }
  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }
    t.reverse();
    for (; e--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }
  e = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (k) {
    xc.unshift(k);
    ++ye;
  }

  // Remove trailing zeros.
  for (e = xc.length; xc[--e] === 0;) xc.pop();
  y.c = xc;
  y.e = ye;
  return y;
};

/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor('1'),
    y = one,
    isneg = n < 0;
  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + 'exponent');
  }
  if (isneg) n = -n;
  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }
  return isneg ? one.div(y) : y;
};

/*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.prec = function (sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + 'precision');
  }
  return round(new this.constructor(this), sd, rm);
};

/*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.round = function (dp, rm) {
  if (dp === UNDEFINED) dp = 0;else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};

/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r,
    c,
    t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big('0.5');

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) {
    throw Error(NAME + 'No square root');
  }

  // Estimate.
  s = Math.sqrt(x + '');

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s + '');
  }
  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));
  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);
};

/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {
      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }
    c[j] = b;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;
  return y;
};

/*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toExponential = function (dp, rm) {
  var x = this,
    n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp;) x.c.push(0);
  }
  return stringify(x, true, !!n);
};

/*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp, rm) {
  var x = this,
    n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);

    // x.e may have changed if the value is rounded up.
    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
  }
  return stringify(x, false, !!n);
};

/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P[Symbol.for('nodejs.util.inspect.custom')] = P.toJSON = P.toString = function () {
  var x = this,
    Big = x.constructor;
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
};

/*
 * Return the value of this Big as a primitve number.
 */
P.toNumber = function () {
  var n = Number(stringify(this, true, true));
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + 'Imprecise conversion');
  }
  return n;
};

/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toPrecision = function (sd, rm) {
  var x = this,
    Big = x.constructor,
    n = x.c[0];
  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    x = round(new Big(x), sd, rm);
    for (; x.c.length < sd;) x.c.push(0);
  }
  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
};

/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = function () {
  var x = this,
    Big = x.constructor;
  if (Big.strict === true) {
    throw Error(NAME + 'valueOf disallowed');
  }
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
};

// Export

var Big = _Big_();

/// <reference types="https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts" />
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);

/***/ }),

/***/ 9779:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ou: () => (/* reexport */ DateTime)
});

// UNUSED EXPORTS: Duration, FixedOffsetZone, IANAZone, Info, Interval, InvalidZone, Settings, SystemZone, VERSION, Zone

;// CONCATENATED MODULE: ./node_modules/luxon/src/errors.js
// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
class LuxonError extends Error {}

/**
 * @private
 */
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super("Invalid DateTime: ".concat(reason.toMessage()));
  }
}

/**
 * @private
 */
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super("Invalid Interval: ".concat(reason.toMessage()));
  }
}

/**
 * @private
 */
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super("Invalid Duration: ".concat(reason.toMessage()));
  }
}

/**
 * @private
 */
class ConflictingSpecificationError extends LuxonError {}

/**
 * @private
 */
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super("Invalid unit ".concat(unit));
  }
}

/**
 * @private
 */
class InvalidArgumentError extends LuxonError {}

/**
 * @private
 */
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/formats.js
/**
 * @private
 */

const n = "numeric",
  s = "short",
  l = "long";
const DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
const DATE_MED = {
  year: n,
  month: s,
  day: n
};
const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
const DATE_FULL = {
  year: n,
  month: l,
  day: n
};
const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
const TIME_SIMPLE = {
  hour: n,
  minute: n
};
const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
;// CONCATENATED MODULE: ./node_modules/luxon/src/zone.js


/**
 * @interface
 */
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }

  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }

  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/zones/systemZone.js


let singleton = null;

/**
 * Represents the local zone for this JavaScript environment.
 * @implements {Zone}
 */
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone();
    }
    return singleton;
  }

  /** @override **/
  get type() {
    return "system";
  }

  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, _ref) {
    let {
      format,
      locale
    } = _ref;
    return parseZoneInfo(ts, format, locale);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }

  /** @override **/
  get isValid() {
    return true;
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/zones/IANAZone.js


let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
    parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted),
    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const {
      type,
      value
    } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
let ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }

  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }

  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s) {
    return this.isValidZone(s);
  }

  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", {
        timeZone: zone
      }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    /** @private **/
    this.zoneName = name;
    /** @private **/
    this.valid = IANAZone.isValidZone(name);
  }

  /** @override **/
  get type() {
    return "iana";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, _ref) {
    let {
      format,
      locale
    } = _ref;
    return parseZoneInfo(ts, format, locale, this.name);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date)) return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }

    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }

  /** @override **/
  get isValid() {
    return this.valid;
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/locale.js






// todo - remap caching

let intlLFCache = {};
function getCachedLF(locString) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
let intlDTCache = {};
function getCachedDTF(locString) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
let intlNumCache = {};
function getCachedINF(locString) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
let intlRelCache = {};
function getCachedRTF(locString) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    base,
    ...cacheKeyOpts
  } = opts; // exclude `base` from the options
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
let weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    // browsers currently implement this as a property, but spec says it should be a getter function
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:

  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u

  // private subtags and unicode subtags have ordering requirements,
  // and we're not properly parsing this, so just strip out the
  // private ones if they exist.
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const {
      numberingSystem,
      calendar
    } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += "-ca-".concat(outputCalendar);
    }
    if (numberingSystem) {
      localeStr += "-nu-".concat(numberingSystem);
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}

/**
 * @private
 */

class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const {
      padTo,
      floor,
      ...otherOpts
    } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = {
        useGrouping: false,
        ...opts
      };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}

/**
 * @private
 */

class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = undefined;
    let z = undefined;
    if (this.opts.timeZone) {
      // Don't apply any workarounds if a timeZone is explicitly provided in opts
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
      // That is why fixed-offset TZ is set to that unless it is:
      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.
      // 2. Unsupported by the browser:
      //    - some do not support Etc/
      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? "Etc/GMT+".concat(gmtOffset) : "Etc/GMT".concat(gmtOffset);
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so
        // we manually apply the offset and substitute the zone as needed.
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({
          minutes: dt.offset
        });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      // Custom zones can have any offset / offsetName so we just manually
      // apply the offset and substitute the zone as needed.
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({
        minutes: dt.offset
      });
      this.originalZone = dt.zone;
    }
    const intlOpts = {
      ...this.opts
    };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      // If we have to substitute in the actual zone name, we have to use
      // formatToParts so that the timezone can be replaced.
      return this.formatToParts().map(_ref => {
        let {
          value
        } = _ref;
        return value;
      }).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map(part => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}

/**
 * @private
 */
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = {
      style: "long",
      ...opts
    };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}
const fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};

/**
 * @private
 */

class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings) {
    let defaultToEN = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    const specifiedLocale = locale || Settings.defaultLocale;
    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject() {
    let {
      locale,
      numberingSystem,
      outputCalendar,
      weekSettings
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = {
      format: {},
      standalone: {}
    };
    this.monthsCache = {
      format: {},
      standalone: {}
    };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this.weekSettings, alts.defaultToEN || false);
    }
  }
  redefaultToEN() {
    let alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.clone({
      ...alts,
      defaultToEN: true
    });
  }
  redefaultToSystem() {
    let alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.clone({
      ...alts,
      defaultToEN: false
    });
  }
  months(length) {
    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return listStuff(this, length, months, () => {
      const intl = format ? {
          month: length,
          day: "numeric"
        } : {
          month: length
        },
        formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length) {
    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return listStuff(this, length, weekdays, () => {
      const intl = format ? {
          weekday: length,
          year: "numeric",
          month: "long",
          day: "numeric"
        } : {
          weekday: length
        },
        formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, "weekday"));
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(this, undefined, () => meridiems, () => {
      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
      // for AM and PM. This is probably wrong, but it's makes parsing way easier.
      if (!this.meridiemCache) {
        const intl = {
          hour: "numeric",
          hourCycle: "h12"
        };
        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = {
        era: length
      };

      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, "era"));
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts),
      results = df.formatToParts(),
      matching = results.find(m => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt) {
    let intlOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/zones/fixedOffsetZone.js


let fixedOffsetZone_singleton = null;

/**
 * A zone with a fixed offset (meaning no DST)
 * @implements {Zone}
 */
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (fixedOffsetZone_singleton === null) {
      fixedOffsetZone_singleton = new FixedOffsetZone(0);
    }
    return fixedOffsetZone_singleton;
  }

  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }

  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s) {
    if (s) {
      const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset) {
    super();
    /** @private **/
    this.fixed = offset;
  }

  /** @override **/
  get type() {
    return "fixed";
  }

  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : "UTC".concat(formatOffset(this.fixed, "narrow"));
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return "Etc/GMT".concat(formatOffset(-this.fixed, "narrow"));
    }
  }

  /** @override **/
  offsetName() {
    return this.name;
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }

  /** @override **/
  get isUniversal() {
    return true;
  }

  /** @override **/
  offset() {
    return this.fixed;
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }

  /** @override **/
  get isValid() {
    return true;
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/zones/invalidZone.js


/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    /**  @private */
    this.zoneName = zoneName;
  }

  /** @override **/
  get type() {
    return "invalid";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName() {
    return null;
  }

  /** @override **/
  formatOffset() {
    return "";
  }

  /** @override **/
  offset() {
    return NaN;
  }

  /** @override **/
  equals() {
    return false;
  }

  /** @override **/
  get isValid() {
    return false;
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/zoneUtil.js
/**
 * @private
 */







function normalizeZone(input, defaultZone) {
  let offset;
  if (isUndefined(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone;else if (lowered === "local" || lowered === "system") return SystemZone.instance;else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new InvalidZone(input);
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/settings.js





let now = () => Date.now(),
  defaultZone = "system",
  defaultLocale = null,
  defaultNumberingSystem = null,
  defaultOutputCalendar = null,
  twoDigitCutoffYear = 60,
  throwOnInvalid,
  defaultWeekSettings = null;

/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }

  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n) {
    now = n;
  }

  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }

  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }

  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }

  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }

  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }

  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }

  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }

  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }

  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */

  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }

  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }

  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }

  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }

  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }

  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/invalid.js
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return "".concat(this.reason, ": ").concat(this.explanation);
    } else {
      return this.reason;
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/conversions.js



const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", "you specified ".concat(value, " (of type ").concat(typeof value, ") as a ").concat(unit, ", which is invalid"));
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder,
    month0 = table.findIndex(i => i < ordinal),
    day = ordinal - table[month0];
  return {
    month: month0 + 1,
    day
  };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}

/**
 * @private
 */

function gregorianToWeek(gregObj) {
  let minDaysInFirstWeek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  let startOfWeek = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  const {
      year,
      month,
      day
    } = gregObj,
    ordinal = computeOrdinal(year, month, day),
    weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7),
    weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return {
    weekYear,
    weekNumber,
    weekday,
    ...timeObject(gregObj)
  };
}
function weekToGregorian(weekData) {
  let minDaysInFirstWeek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  let startOfWeek = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  const {
      weekYear,
      weekNumber,
      weekday
    } = weekData,
    weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek),
    yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek,
    year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const {
    month,
    day
  } = uncomputeOrdinal(year, ordinal);
  return {
    year,
    month,
    day,
    ...timeObject(weekData)
  };
}
function gregorianToOrdinal(gregData) {
  const {
    year,
    month,
    day
  } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return {
    year,
    ordinal,
    ...timeObject(gregData)
  };
}
function ordinalToGregorian(ordinalData) {
  const {
    year,
    ordinal
  } = ordinalData;
  const {
    month,
    day
  } = uncomputeOrdinal(year, ordinal);
  return {
    year,
    month,
    day,
    ...timeObject(ordinalData)
  };
}

/**
 * Check if local week units like localWeekday are used in obj.
 * If so, validates that they are not mixed with ISO week units and then copies them to the normal week unit properties.
 * Modifies obj in-place!
 * @param obj the object values
 */
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
    }
    if (!isUndefined(obj.localWeekday)) obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return {
      minDaysInFirstWeek: 4,
      startOfWeek: 1
    };
  }
}
function hasInvalidWeekData(obj) {
  let minDaysInFirstWeek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  let startOfWeek = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  const validYear = isInteger(obj.weekYear),
    validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)),
    validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year),
    validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year),
    validMonth = integerBetween(obj.month, 1, 12),
    validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const {
    hour,
    minute,
    second,
    millisecond
  } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0,
    validMinute = integerBetween(minute, 0, 59),
    validSecond = integerBetween(second, 0, 59),
    validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/util.js
/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won't worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/





/**
 * @private
 */

// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}

// CAPABILITIES

function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}

// OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function util_pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function util_hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some(v => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}

// NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}

// x % n but takes the sign of n instead of x
function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}
function padStart(input) {
  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n, "0");
  } else {
    padded = ("" + input).padStart(n, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    const f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}
function roundTo(number, digits) {
  let towardZero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const factor = 10 ** digits,
    rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}

// DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1,
    modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}

// convert a calendar object to a local timestamp (epoch, but with the offset baked in)
function objToLocalTS(obj) {
  let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);

  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not
    // so if obj.year is in 99, but obj.day makes it roll over into year 100,
    // the calculations done by Date.UTC are using year 2000 - which is incorrect
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}

// adapted from moment.js: https://github.com/moment/moment/blob/000ac1800e620f770f4eb31b5ae908f6167b0ab2/src/lib/units/week-calendar-utils.js
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear) {
  let minDaysInFirstWeek = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  let startOfWeek = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
}

// PARSING

function parseZoneInfo(ts, offsetFormat, locale) {
  let timeZone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  const date = new Date(ts),
    intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = {
    timeZoneName: offsetFormat,
    ...intlOpts
  };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(m => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}

// signedOffset('-5', '30') -> -330
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);

  // don't || this because we want to preserve -0
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0,
    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}

// COERCION

function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError("Invalid unit value ".concat(value));
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (util_hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset, format) {
  const hours = Math.trunc(Math.abs(offset / 60)),
    minutes = Math.trunc(Math.abs(offset % 60)),
    sign = offset >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return "".concat(sign).concat(padStart(hours, 2), ":").concat(padStart(minutes, 2));
    case "narrow":
      return "".concat(sign).concat(hours).concat(minutes > 0 ? ":".concat(minutes) : "");
    case "techie":
      return "".concat(sign).concat(padStart(hours, 2)).concat(padStart(minutes, 2));
    default:
      throw new RangeError("Value format ".concat(format, " is out of range for property format"));
  }
}
function timeObject(obj) {
  return util_pick(obj, ["hour", "minute", "second", "millisecond"]);
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/english.js


function stringify(obj) {
  return JSON.stringify(obj, Object.keys(obj).sort());
}

/**
 * @private
 */

const monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
const monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count) {
  let numeric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "always";
  let narrow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : "next ".concat(units[unit][0]);
      case -1:
        return isDay ? "yesterday" : "last ".concat(units[unit][0]);
      case 0:
        return isDay ? "today" : "this ".concat(units[unit][0]);
      default: // fall through
    }
  }

  const isInPast = Object.is(count, -0) || count < 0,
    fmtValue = Math.abs(count),
    singular = fmtValue === 1,
    lilUnits = units[unit],
    fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? "".concat(fmtValue, " ").concat(fmtUnit, " ago") : "in ".concat(fmtValue, " ").concat(fmtUnit);
}
function formatString(knownFormat) {
  // these all have the offsets removed because we don't have access to them
  // without all the intl stuff this is backfilling
  const filtered = pick(knownFormat, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hourCycle"]),
    key = stringify(filtered),
    dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a";
  switch (key) {
    case stringify(Formats.DATE_SHORT):
      return "M/d/yyyy";
    case stringify(Formats.DATE_MED):
      return "LLL d, yyyy";
    case stringify(Formats.DATE_MED_WITH_WEEKDAY):
      return "EEE, LLL d, yyyy";
    case stringify(Formats.DATE_FULL):
      return "LLLL d, yyyy";
    case stringify(Formats.DATE_HUGE):
      return "EEEE, LLLL d, yyyy";
    case stringify(Formats.TIME_SIMPLE):
      return "h:mm a";
    case stringify(Formats.TIME_WITH_SECONDS):
      return "h:mm:ss a";
    case stringify(Formats.TIME_WITH_SHORT_OFFSET):
      return "h:mm a";
    case stringify(Formats.TIME_WITH_LONG_OFFSET):
      return "h:mm a";
    case stringify(Formats.TIME_24_SIMPLE):
      return "HH:mm";
    case stringify(Formats.TIME_24_WITH_SECONDS):
      return "HH:mm:ss";
    case stringify(Formats.TIME_24_WITH_SHORT_OFFSET):
      return "HH:mm";
    case stringify(Formats.TIME_24_WITH_LONG_OFFSET):
      return "HH:mm";
    case stringify(Formats.DATETIME_SHORT):
      return "M/d/yyyy, h:mm a";
    case stringify(Formats.DATETIME_MED):
      return "LLL d, yyyy, h:mm a";
    case stringify(Formats.DATETIME_FULL):
      return "LLLL d, yyyy, h:mm a";
    case stringify(Formats.DATETIME_HUGE):
      return dateTimeHuge;
    case stringify(Formats.DATETIME_SHORT_WITH_SECONDS):
      return "M/d/yyyy, h:mm:ss a";
    case stringify(Formats.DATETIME_MED_WITH_SECONDS):
      return "LLL d, yyyy, h:mm:ss a";
    case stringify(Formats.DATETIME_MED_WITH_WEEKDAY):
      return "EEE, d LLL yyyy, h:mm a";
    case stringify(Formats.DATETIME_FULL_WITH_SECONDS):
      return "LLLL d, yyyy, h:mm:ss a";
    case stringify(Formats.DATETIME_HUGE_WITH_SECONDS):
      return "EEEE, LLLL d, yyyy, h:mm:ss a";
    default:
      return dateTimeHuge;
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/formatter.js



function stringifyTokens(splits, tokenToString) {
  let s = "";
  for (const token of splits) {
    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }
  return s;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};

/**
 * @private
 */

class Formatter {
  static create(locale) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    // white-space is always considered a literal in user-provided formats
    // the " " token has a special meaning (see unitForToken)

    let current = null,
      currentFull = "",
      bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed || /^\s+$/.test(currentFull),
            val: currentFull
          });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({
            literal: /^\s+$/.test(currentFull),
            val: currentFull
          });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({
        literal: bracketed || /^\s+$/.test(currentFull),
        val: currentFull
      });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.format();
  }
  dtFormatter(dt) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.loc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n) {
    let p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }
    const opts = {
      ...this.opts
    };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en",
      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      string = (opts, extract) => this.loc.extract(dt, opts, extract),
      formatOffset = opts => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      },
      meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({
        hour: "numeric",
        hourCycle: "h12"
      }, "dayperiod"),
      month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month"),
      weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday"),
      maybeMacro = token => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      },
      era = length => knownEnglish ? eraForDateTime(dt, length) : string({
        era: length
      }, "era"),
      tokenToString = token => {
        // Where possible: https://cldr.unicode.org/translation/date-time/date-time-symbols
        switch (token) {
          // ms
          case "S":
            return this.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          // hours
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          // offset
          case "Z":
            // like +6
            return formatOffset({
              format: "narrow",
              allowZ: this.opts.allowZ
            });
          case "ZZ":
            // like +06:00
            return formatOffset({
              format: "short",
              allowZ: this.opts.allowZ
            });
          case "ZZZ":
            // like +0600
            return formatOffset({
              format: "techie",
              allowZ: this.opts.allowZ
            });
          case "ZZZZ":
            // like EST
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale
            });
          case "ZZZZZ":
            // like Eastern Standard Time
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale
            });
          // zone
          case "z":
            // like America/New_York
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return useDateTimeFormatter ? string({
              day: "numeric"
            }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({
              day: "2-digit"
            }, "day") : this.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            // like 1
            return this.num(dt.weekday);
          case "ccc":
            // like 'Tues'
            return weekday("short", true);
          case "cccc":
            // like 'Tuesday'
            return weekday("long", true);
          case "ccccc":
            // like 'T'
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            // like 1
            return this.num(dt.weekday);
          case "EEE":
            // like 'Tues'
            return weekday("short", false);
          case "EEEE":
            // like 'Tuesday'
            return weekday("long", false);
          case "EEEEE":
            // like 'T'
            return weekday("narrow", false);
          // months - standalone
          case "L":
            // like 1
            return useDateTimeFormatter ? string({
              month: "numeric",
              day: "numeric"
            }, "month") : this.num(dt.month);
          case "LL":
            // like 01, doesn't seem to work
            return useDateTimeFormatter ? string({
              month: "2-digit",
              day: "numeric"
            }, "month") : this.num(dt.month, 2);
          case "LLL":
            // like Jan
            return month("short", true);
          case "LLLL":
            // like January
            return month("long", true);
          case "LLLLL":
            // like J
            return month("narrow", true);
          // months - format
          case "M":
            // like 1
            return useDateTimeFormatter ? string({
              month: "numeric"
            }, "month") : this.num(dt.month);
          case "MM":
            // like 01
            return useDateTimeFormatter ? string({
              month: "2-digit"
            }, "month") : this.num(dt.month, 2);
          case "MMM":
            // like Jan
            return month("short", false);
          case "MMMM":
            // like January
            return month("long", false);
          case "MMMMM":
            // like J
            return month("narrow", false);
          // years
          case "y":
            // like 2014
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year);
          case "yy":
            // like 14
            return useDateTimeFormatter ? string({
              year: "2-digit"
            }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            // like 0012
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            // like 000012
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 6);
          // eras
          case "G":
            // like AD
            return era("short");
          case "GG":
            // like Anno Domini
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "n":
            return this.num(dt.localWeekNumber);
          case "nn":
            return this.num(dt.localWeekNumber, 2);
          case "ii":
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(dt.localWeekYear, 4);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            // like 1
            return this.num(dt.quarter);
          case "qq":
            // like 01
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = token => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = lildur => token => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      },
      tokens = Formatter.parseFormat(fmt),
      realTokens = tokens.reduce((found, _ref) => {
        let {
          literal,
          val
        } = _ref;
        return literal ? found : found.concat(val);
      }, []),
      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter(t => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/regexParser.js





/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes() {
  for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
    regexes[_key] = arguments[_key];
  }
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp("^".concat(full, "$"));
}
function combineExtractors() {
  for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    extractors[_key2] = arguments[_key2];
  }
  return m => extractors.reduce((_ref, ex) => {
    let [mergedVals, mergedZone, cursor] = _ref;
    const [val, zone, next] = ex(m, cursor);
    return [{
      ...mergedVals,
      ...val
    }, zone || mergedZone, next];
  }, [{}, null, 1]).slice(0, 2);
}
function parse(s) {
  if (s == null) {
    return [null, null];
  }
  for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    patterns[_key3 - 1] = arguments[_key3];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse() {
  for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    keys[_key4] = arguments[_key4];
  }
  return (match, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}

// ISO and SQL parsing
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = "(?:".concat(offsetRegex.source, "?(?:\\[(").concat(ianaRegex.source, ")\\])?)?");
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp("".concat(isoTimeBaseRegex.source).concat(isoExtendedZone));
const isoTimeExtensionRegex = RegExp("(?:T".concat(isoTimeRegex.source, ")?"));
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/; // dumbed-down version of the ISO one
const sqlTimeRegex = RegExp("".concat(isoTimeBaseRegex.source, " ?(?:").concat(offsetRegex.source, "|(").concat(ianaRegex.source, "))?"));
const sqlTimeExtensionRegex = RegExp("(?: ".concat(sqlTimeRegex.source, ")?"));
function regexParser_int(match, pos, fallback) {
  const m = match[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match, cursor) {
  const item = {
    year: regexParser_int(match, cursor),
    month: regexParser_int(match, cursor + 1, 1),
    day: regexParser_int(match, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match, cursor) {
  const item = {
    hours: regexParser_int(match, cursor, 0),
    minutes: regexParser_int(match, cursor + 1, 0),
    seconds: regexParser_int(match, cursor + 2, 0),
    milliseconds: parseMillis(match[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match, cursor) {
  const local = !match[cursor] && !match[cursor + 1],
    fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
    zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match, cursor) {
  const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
}

// ISO time parsing

const isoTimeOnly = RegExp("^T?".concat(isoTimeBaseRegex.source, "$"));

// ISO duration parsing

const isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match) {
  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match;
  const hasNegativePrefix = s[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = function (num) {
    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
  };
  return [{
    years: maybeNegate(parseFloating(yearStr)),
    months: maybeNegate(parseFloating(monthStr)),
    weeks: maybeNegate(parseFloating(weekStr)),
    days: maybeNegate(parseFloating(dayStr)),
    hours: maybeNegate(parseFloating(hourStr)),
    minutes: maybeNegate(parseFloating(minuteStr)),
    seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
    milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
  }];
}

// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}

// RFC 2822/5322
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset;
  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset)];
}
function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}

// http date

const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
  rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
  ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);

/*
 * @private
 */

function parseISODate(s) {
  return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s) {
  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s) {
  return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s) {
  return parse(s, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s) {
  return parse(s, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s) {
  return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/duration.js








const INVALID = "Invalid Duration";

// unit conversion constants
const lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000
    },
    hours: {
      minutes: 60,
      seconds: 60 * 60,
      milliseconds: 60 * 60 * 1000
    },
    minutes: {
      seconds: 60,
      milliseconds: 60 * 1000
    },
    seconds: {
      milliseconds: 1000
    }
  },
  casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  },
  daysInYearAccurate = 146097.0 / 400,
  daysInMonthAccurate = 146097.0 / 4800,
  accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };

// units ordered by size
const orderedUnits = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
const reverseUnits = orderedUnits.slice(0).reverse();

// clone really means "create another instance just like this one, but with these changes"
function clone(dur, alts) {
  let clear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // deep merge for vals
  const conf = {
    values: clear ? alts.values : {
      ...dur.values,
      ...(alts.values || {})
    },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  var _vals$milliseconds;
  let sum = (_vals$milliseconds = vals.milliseconds) !== null && _vals$milliseconds !== void 0 ? _vals$milliseconds : 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}

// NB: mutates parameters
function normalizeValues(matrix, vals) {
  // the logic below assumes the overall value of the duration is positive
  // if this is not the case, factor is used to make it so
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];

        // if (previousVal < 0):
        // lower order unit is negative (e.g. { years: 2, days: -2 })
        // normalize this by reducing the higher order unit by the appropriate amount
        // and increasing the lower order unit
        // this can never make the higher order unit negative, because this function only operates
        // on positive durations, so the amount of time represented by the lower order unit cannot
        // be larger than the higher order unit
        // else:
        // lower order unit is positive (e.g. { years: 2, days: 450 } or { years: -2, days: 450 })
        // in this case we attempt to convert as much as possible from the lower order unit into
        // the higher order one
        //
        // Math.floor takes care of both of these cases, rounding away from 0
        // if previousVal < 0 it makes the absolute value larger
        // if previousVal >= it makes the absolute value smaller
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);

  // try to convert any decimals into smaller units if possible
  // for example for { years: 2.5, days: 0, seconds: 0 } we want to get { years: 2, days: 182, hours: 12 }
  orderedUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}

// Remove all properties with a value of 0 from an object
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}

/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
 * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.
 * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */
class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }

    /**
     * @access private
     */
    this.values = config.values;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.matrix = matrix;
    /**
     * @access private
     */
    this.isLuxonDuration = true;
  }

  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({
      milliseconds: count
    }, opts);
  }

  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got ".concat(obj === null ? "null" : typeof obj));
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }

  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError("Unknown duration argument ".concat(durationLike, " of type ").concat(typeof durationLike));
    }
  }

  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", "the input \"".concat(text, "\" can't be parsed as ISO 8601"));
    }
  }

  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", "the input \"".concat(text, "\" can't be parsed as ISO 8601"));
    }
  }

  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason) {
    let explanation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({
        invalid
      });
    }
  }

  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }

  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }

  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }

  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) return INVALID;
    const l = orderedUnits.map(unit => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({
        style: "unit",
        unitDisplay: "long",
        ...opts,
        unit: unit.slice(0, -1)
      }).format(val);
    }).filter(n => n);
    return this.loc.listFormatter({
      type: "conjunction",
      style: opts.listStyle || "narrow",
      ...opts
    }).format(l);
  }

  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return {
      ...this.values
    };
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;
    let s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      // this will handle "floating point madness" by removing extra decimal places
      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
      s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s === "P") s += "T0S";
    return s;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 86400000) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, {
      zone: "UTC"
    });
    return dateTime.toISOTime(opts);
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }

  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return "Duration { values: ".concat(JSON.stringify(this.values), " }");
    } else {
      return "Duration { Invalid, reason: ".concat(this.invalidReason, " }");
    }
  }

  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid) return NaN;
    return durationToMillis(this.matrix, this.values);
  }

  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration),
      result = {};
    for (const k of orderedUnits) {
      if (util_hasOwnProperty(dur.values, k) || util_hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, {
      values: result
    }, true);
  }

  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }

  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, {
      values: result
    }, true);
  }

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }

  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;
    const mixed = {
      ...this.values,
      ...normalizeObject(values, Duration.normalizeUnit)
    };
    return clone(this, {
      values: mixed
    });
  }

  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure() {
    let {
      locale,
      numberingSystem,
      conversionAccuracy,
      matrix
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const loc = this.loc.clone({
      locale,
      numberingSystem
    });
    const opts = {
      loc,
      matrix,
      conversionAccuracy
    };
    return clone(this, opts);
  }

  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }

  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, {
      values: vals
    }, true);
  }

  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, {
      values: vals
    }, true);
  }

  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo() {
    for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
      units[_key] = arguments[_key];
    }
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map(u => Duration.normalizeUnit(u));
    const built = {},
      accumulated = {},
      vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;

        // anything we haven't boiled down yet should get boiled to this unit
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }

        // plus anything that's already in this unit
        if (isNumber(vals[k])) {
          own += vals[k];
        }

        // only keep the integer part for now in the hopes of putting any decimal part
        // into a smaller unit later
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1000 - i * 1000) / 1000;

        // otherwise, keep it in the wings to boil it later
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }

    // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone(this, {
      values: built
    }, true);
  }

  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
  }

  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, {
      values: negated
    }, true);
  }

  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }

  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }

  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }

  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }

  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }

  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }

  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }

  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }

  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }

  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      // Consider 0 and undefined as equal
      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/interval.js







const interval_INVALID = "Invalid Interval";

// checks if the start is equal to or before the end
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=".concat(start.toISO(), " and end=").concat(end.toISO()));
  } else {
    return null;
  }
}

/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.
 * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.
 * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}
 * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toLocaleString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.
 */
class Interval {
  /**
   * @private
   */
  constructor(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */
    this.e = config.end;
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.isLuxonInterval = true;
  }

  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason) {
    let explanation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({
        invalid
      });
    }
  }

  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start),
      builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }

  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }

  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }

  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s, e] = (text || "").split("/", 2);
    if (s && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s, opts);
        startIsValid = start.isValid;
      } catch (e) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", "the input \"".concat(text, "\" can't be parsed as ISO 8601"));
  }

  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }

  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }

  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }

  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }

  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length() {
    let unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "milliseconds";
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }

  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count() {
    let unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "milliseconds";
    let opts = arguments.length > 1 ? arguments[1] : undefined;
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts !== null && opts !== void 0 && opts.useLocaleWeeks) {
      end = this.end.reconfigure({
        locale: start.locale
      });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }

  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }

  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }

  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }

  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }

  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }

  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set() {
    let {
      start,
      end
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }

  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt() {
    if (!this.isValid) return [];
    for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
      dateTimes[_key] = arguments[_key];
    }
    const sorted = dateTimes.map(friendlyDateTime).filter(d => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()),
      results = [];
    let {
        s
      } = this,
      i = 0;
    while (s < this.e) {
      const added = sorted[i] || this.e,
        next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }
    return results;
  }

  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let {
        s
      } = this,
      idx = 1,
      next;
    const results = [];
    while (s < this.e) {
      const added = this.start.plus(dur.mapUnits(x => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      idx += 1;
    }
    return results;
  }

  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }

  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }

  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }

  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }

  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }

  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }

  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s = this.s > other.s ? this.s : other.s,
      e = this.e < other.e ? this.e : other.e;
    if (s >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }

  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s = this.s < other.s ? this.s : other.s,
      e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }

  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce((_ref, item) => {
      let [sofar, current] = _ref;
      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]);
    if (final) {
      found.push(final);
    }
    return found;
  }

  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null,
      currentCount = 0;
    const results = [],
      ends = intervals.map(i => [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }]),
      flattened = Array.prototype.concat(...ends),
      arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }

  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference() {
    for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      intervals[_key2] = arguments[_key2];
    }
    return Interval.xor([this].concat(intervals)).map(i => this.intersection(i)).filter(i => i && !i.isEmpty());
  }

  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return interval_INVALID;
    return "[".concat(this.s.toISO(), " \u2013 ").concat(this.e.toISO(), ")");
  }

  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return "Interval { start: ".concat(this.s.toISO(), ", end: ").concat(this.e.toISO(), " }");
    } else {
      return "Interval { Invalid, reason: ".concat(this.invalidReason, " }");
    }
  }

  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString() {
    let formatOpts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DATE_SHORT;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : interval_INVALID;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return interval_INVALID;
    return "".concat(this.s.toISO(opts), "/").concat(this.e.toISO(opts));
  }

  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return interval_INVALID;
    return "".concat(this.s.toISODate(), "/").concat(this.e.toISODate());
  }

  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return interval_INVALID;
    return "".concat(this.s.toISOTime(opts), "/").concat(this.e.toISOTime(opts));
  }

  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat) {
    let {
      separator = " – "
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!this.isValid) return interval_INVALID;
    return "".concat(this.s.toFormat(dateFormat)).concat(separator).concat(this.e.toFormat(dateFormat));
  }

  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }

  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/info.js







/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST() {
    let zone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Settings.defaultZone;
    const proto = DateTime.now().setZone(zone).set({
      month: 12
    });
    return !zone.isUniversal && proto.offset !== proto.set({
      month: 6
    }).offset;
  }

  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }

  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }

  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek() {
    let {
      locale = null,
      locObj = null
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }

  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek() {
    let {
      locale = null,
      locObj = null
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }

  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays() {
    let {
      locale = null,
      locObj = null
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // copy the array, because we cache it internally
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }

  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "long";
    let {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }

  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "long";
    let {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }

  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "long";
    let {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }

  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "long";
    let {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }

  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems() {
    let {
      locale = null
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return Locale.create(locale).meridiems();
  }

  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "short";
    let {
      locale = null
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Locale.create(locale, null, "gregory").eras(length);
  }

  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return {
      relative: hasRelative(),
      localeWeek: hasLocaleWeekInfo()
    };
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/diff.js

function dayDiff(earlier, later) {
  const utcDayStart = dt => dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf(),
    ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [["years", (a, b) => b.year - a.year], ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4], ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12], ["weeks", (a, b) => {
    const days = dayDiff(a, b);
    return (days - days % 7) / 7;
  }], ["days", dayDiff]];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;

  /* This loop tries to diff using larger units first.
     If we overshoot, we backtrack and try the next smaller unit.
     "cursor" starts out at the earlier timestamp and moves closer and closer to "later"
     as we use smaller and smaller units.
     highWater keeps track of where we would be if we added one more of the smallest unit,
     this is used later to potentially convert any difference smaller than the smallest higher order unit
     into a fraction of that smallest higher order unit
  */
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        // we overshot the end point, backtrack cursor by 1
        results[unit]--;
        cursor = earlier.plus(results);

        // if we are still overshooting now, we need to backtrack again
        // this happens in certain situations when diffing times in different zones,
        // because this calculation ignores time zones
        if (cursor > later) {
          // keep the "overshot by 1" around as highWater
          highWater = cursor;
          // backtrack cursor by 1
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
/* harmony default export */ function diff(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(u => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({
        [lowestOrder]: 1
      });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/digits.js
const numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex(_ref) {
  let {
    numberingSystem
  } = _ref;
  let append = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  return new RegExp("".concat(numberingSystems[numberingSystem || "latn"]).concat(append));
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/impl/tokenParser.js







const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex) {
  let post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : i => i;
  return {
    regex,
    deser: _ref => {
      let [s] = _ref;
      return post(parseDigits(s));
    }
  };
}
const NBSP = String.fromCharCode(160);
const spaceOrNBSP = "[ ".concat(NBSP, "]");
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s) {
  return s.replace(/\./g, "") // ignore dots that were made optional
  .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
  .toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: _ref2 => {
        let [s] = _ref2;
        return strings.findIndex(i => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex;
      }
    };
  }
}
function offset(regex, groups) {
  return {
    regex,
    deser: _ref3 => {
      let [, h, m] = _ref3;
      return signedOffset(h, m);
    },
    groups
  };
}
function simple(regex) {
  return {
    regex,
    deser: _ref4 => {
      let [s] = _ref4;
      return s;
    }
  };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}

/**
 * @param token
 * @param {Locale} loc
 */
function unitForToken(token, loc) {
  const one = digitRegex(loc),
    two = digitRegex(loc, "{2}"),
    three = digitRegex(loc, "{3}"),
    four = digitRegex(loc, "{4}"),
    six = digitRegex(loc, "{6}"),
    oneOrTwo = digitRegex(loc, "{1,2}"),
    oneToThree = digitRegex(loc, "{1,3}"),
    oneToSix = digitRegex(loc, "{1,6}"),
    oneToNine = digitRegex(loc, "{1,9}"),
    twoToFour = digitRegex(loc, "{2,4}"),
    fourToSix = digitRegex(loc, "{4,6}"),
    literal = t => ({
      regex: RegExp(escapeToken(t.val)),
      deser: _ref5 => {
        let [s] = _ref5;
        return s;
      },
      literal: true
    }),
    unitate = t => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        // era
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        // years
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        // months
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        // dates
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        // ordinals
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        // time
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        // meridiem
        case "a":
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        // weekNumber (W)
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        // weekdays
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return offset(new RegExp("([+-]".concat(oneOrTwo.source, ")(?::(").concat(two.source, "))?")), 2);
        case "ZZZ":
          return offset(new RegExp("([+-]".concat(oneOrTwo.source, ")(").concat(two.source, ")?")), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        // this special-case "token" represents a place where a macro-token expanded into a white-space literal
        // in this case we accept any non-newline white-space
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal(t);
      }
    };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const {
    type,
    value
  } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type];

  // The user might have explicitly specified hour12 or hourCycle
  // if so, respect their decision
  // if not, refer back to the resolvedOpts, which are based on the locale
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      // tokens only differentiate between 24 hours or not,
      // so we do not need to check hourCycle here, which is less supported anyways
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return undefined;
}
function buildRegex(units) {
  const re = units.map(u => u.regex).reduce((f, r) => "".concat(f, "(").concat(r.source, ")"), "");
  return ["^".concat(re, "$"), units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (util_hasOwnProperty(handlers, i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = token => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(undefined)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map(t => maybeExpandMacroToken(t, locale)));
}

/**
 * @private
 */

function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
    units = tokens.map(t => unitForToken(t, locale)),
    disqualifyingUnit = units.find(t => t.invalidReason);
  if (disqualifyingUnit) {
    return {
      input,
      tokens,
      invalidReason: disqualifyingUnit.invalidReason
    };
  } else {
    const [regexString, handlers] = buildRegex(units),
      regex = RegExp(regexString, "i"),
      [rawMatches, matches] = match(input, regex, handlers),
      [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
    if (util_hasOwnProperty(matches, "a") && util_hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }
    return {
      input,
      tokens,
      regex,
      rawMatches,
      matches,
      result,
      zone,
      specificOffset
    };
  }
}
function parseFromTokens(locale, input, format) {
  const {
    result,
    zone,
    specificOffset,
    invalidReason
  } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map(p => tokenForPart(p, formatOpts, resolvedOpts));
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/datetime.js
















const datetime_INVALID = "Invalid DateTime";
const MAX_DATE = 8.64e15;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", "the zone \"".concat(zone.name, "\" is not supported"));
}

// we cache week data on the DT object and this intermediates the cache
/**
 * @param {DateTime} dt
 */
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}

/**
 * @param {DateTime} dt
 */
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(dt.c, dt.loc.getMinDaysInFirstWeek(), dt.loc.getStartOfWeek());
  }
  return dt.localWeekData;
}

// clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties
function datetime_clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({
    ...current,
    ...alts,
    old: current
  });
}

// find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  let utcGuess = localTS - o * 60 * 1000;

  // Test whether the zone matches the offset for this ts
  const o2 = tz.offset(utcGuess);

  // If so, offset didn't change and we're done
  if (o === o2) {
    return [utcGuess, o];
  }

  // If not, change the ts by the difference in the offset
  utcGuess -= (o2 - o) * 60 * 1000;

  // If that gives us the local time we want, we're done
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }

  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
}

// convert an epoch timestamp into a calendar object with the given offset
function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}

// convert a calendar object to a epoch timestamp
function objToTS(obj, offset, zone) {
  return fixOffset(objToLocalTS(obj), offset, zone);
}

// create a new DT instance by adding a duration, adjusting for DSTs
function adjustTime(inst, dur) {
  const oPre = inst.o,
    year = inst.c.year + Math.trunc(dur.years),
    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
    c = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    },
    millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"),
    localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    // that could have changed the offset by going over a DST, but we want to keep the ts the same
    o = inst.zone.offset(ts);
  }
  return {
    ts,
    o
  };
}

// helper useful in turning the results of parsing into real dates
// by handling the zone options
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const {
    setZone,
    zone
  } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone,
      inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", "the input \"".concat(text, "\" can't be parsed as ").concat(format)));
  }
}

// if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details
function toTechFormat(dt, format) {
  let allowZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}

// defaults for unspecified units in the supported calendars
const defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  },
  defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  },
  defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };

// Units in the supported calendars, sorted by bigness
const datetime_orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
  orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
  orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

// standardize case and plurality in units
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}

// this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone),
    loc = Locale.fromObject(opts),
    tsNow = Settings.now();
  let ts, o;

  // assume we have the higher-order units
  if (!isUndefined(obj.year)) {
    for (const u of datetime_orderedUnits) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({
    ts,
    zone,
    loc,
    o
  });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round,
    format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    },
    differ = unit => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {},
    args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}

/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},
 * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.
 * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */
class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null,
      o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }

    /**
     * @access private
     */
    this._zone = zone;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.invalid = invalid;
    /**
     * @access private
     */
    this.weekData = null;
    /**
     * @access private
     */
    this.localWeekData = null;
    /**
     * @access private
     */
    this.c = c;
    /**
     * @access private
     */
    this.o = o;
    /**
     * @access private
     */
    this.isLuxonDateTime = true;
  }

  // CONSTRUCT

  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }

  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond
    }, opts);
  }

  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond
    }, opts);
  }

  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }

  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError("fromMillis requires a numerical input, but received a ".concat(typeof milliseconds, " with value ").concat(milliseconds));
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }

  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }

  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const {
      minDaysInFirstWeek,
      startOfWeek
    } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(),
      offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber;

    // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;

    // configure ourselves to deal with gregorian dates or week stuff
    let units,
      defaultValues,
      objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = datetime_orderedUnits;
      defaultValues = defaultUnitValues;
    }

    // set default values for missing stuff
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }

    // make sure the values we have are in range
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized),
      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }

    // compute the actual time
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized,
      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
      inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });

    // gregorian data + weekday serves only to validate
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", "you can't specify both a weekday of ".concat(normalized.weekday, " and a date of ").concat(inst.toISO()));
    }
    return inst;
  }

  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }

  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }

  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }

  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const {
        locale = null,
        numberingSystem = null
      } = opts,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }),
      [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, "format ".concat(fmt), text, specificOffset);
    }
  }

  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return DateTime.fromFormat(text, fmt, opts);
  }

  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }

  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason) {
    let explanation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({
        invalid
      });
    }
  }

  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }

  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts) {
    let localeOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map(t => t ? t.val : null).join("");
  }

  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt) {
    let localeOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map(t => t.val).join("");
  }

  // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }

  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }

  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }

  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }

  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }

  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }

  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }

  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }

  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }

  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }

  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }

  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }

  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }

  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }

  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }

  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }

  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }

  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }

  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }

  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }

  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", {
      locObj: this.loc
    })[this.month - 1] : null;
  }

  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", {
      locObj: this.loc
    })[this.month - 1] : null;
  }

  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", {
      locObj: this.loc
    })[this.weekday - 1] : null;
  }

  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", {
      locObj: this.loc
    })[this.weekday - 1] : null;
  }

  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }

  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }

  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }

  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }

  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({
        month: 1,
        day: 1
      }).offset || this.offset > this.set({
        month: 5
      }).offset;
    }
  }

  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 86400000;
    const minuteMs = 60000;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [datetime_clone(this, {
        ts: ts1
      }), datetime_clone(this, {
        ts: ts2
      })];
    }
    return [this];
  }

  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }

  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }

  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }

  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }

  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
  }

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      locale,
      numberingSystem,
      calendar
    } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
    return {
      locale,
      numberingSystem,
      outputCalendar: calendar
    };
  }

  // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC() {
    let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.setZone(FixedOffsetZone.instance(offset), opts);
  }

  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }

  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone) {
    let {
      keepLocalTime = false,
      keepCalendarTime = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return datetime_clone(this, {
        ts: newTS,
        zone
      });
    }
  }

  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure() {
    let {
      locale,
      numberingSystem,
      outputCalendar
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const loc = this.loc.clone({
      locale,
      numberingSystem,
      outputCalendar
    });
    return datetime_clone(this, {
      loc
    });
  }

  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({
      locale
    });
  }

  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const {
      minDaysInFirstWeek,
      startOfWeek
    } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({
        ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek),
        ...normalized
      }, minDaysInFirstWeek, startOfWeek);
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({
        ...gregorianToOrdinal(this.c),
        ...normalized
      });
    } else {
      mixed = {
        ...this.toObject(),
        ...normalized
      };

      // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return datetime_clone(this, {
      ts,
      o
    });
  }

  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return datetime_clone(this, adjustTime(this, dur));
  }

  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return datetime_clone(this, adjustTime(this, dur));
  }

  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    let {
      useLocaleWeeks = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!this.isValid) return this;
    const o = {},
      normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through
      case "quarters":
      case "months":
        o.day = 1;
      // falls through
      case "weeks":
      case "days":
        o.hour = 0;
      // falls through
      case "hours":
        o.minute = 0;
      // falls through
      case "minutes":
        o.second = 0;
      // falls through
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const {
          weekday
        } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }

  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({
      [unit]: 1
    }).startOf(unit, opts).minus(1) : this;
  }

  // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : datetime_INVALID;
  }

  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString() {
    let formatOpts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DATE_SHORT;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : datetime_INVALID;
  }

  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO() {
    let {
      format = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate() {
    let {
      format = "extended"
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime() {
    let {
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format = "extended"
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
  }

  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime() {
    let {
      includeOffset = true,
      includeZone = false,
      includeOffsetSpace = true
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) {
      return null;
    }
    return "".concat(this.toSQLDate(), " ").concat(this.toSQLTime(opts));
  }

  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : datetime_INVALID;
  }

  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return "DateTime { ts: ".concat(this.toISO(), ", zone: ").concat(this.zone.name, ", locale: ").concat(this.locale, " }");
    } else {
      return "DateTime { Invalid, reason: ".concat(this.invalidReason, " }");
    }
  }

  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }

  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }

  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1000) : NaN;
  }

  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }

  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) return {};
    const base = {
      ...this.c
    };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }

  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }

  // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime) {
    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "milliseconds";
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = {
      locale: this.locale,
      numberingSystem: this.numberingSystem,
      ...opts
    };
    const units = maybeArray(unit).map(Duration.normalizeUnit),
      otherIsLater = otherDateTime.valueOf() > this.valueOf(),
      earlier = otherIsLater ? this : otherDateTime,
      later = otherIsLater ? otherDateTime : this,
      diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }

  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow() {
    let unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "milliseconds";
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.diff(DateTime.now(), unit, opts);
  }

  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }

  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, {
      keepLocalTime: true
    });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }

  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }

  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({}, {
        zone: this.zone
      }),
      padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = undefined;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }

  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!this.isValid) return null;
    return diffRelative(options.base || DateTime.fromObject({}, {
      zone: this.zone
    }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }

  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min() {
    for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
      dateTimes[_key] = arguments[_key];
    }
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, i => i.valueOf(), Math.min);
  }

  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max() {
    for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      dateTimes[_key2] = arguments[_key2];
    }
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, i => i.valueOf(), Math.max);
  }

  // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
        locale = null,
        numberingSystem = null
      } = options,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
    return explainFromTokens(localeToUse, text, fmt);
  }

  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return DateTime.fromFormatExplain(text, fmt, options);
  }

  // FORMAT PRESETS

  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}

/**
 * @private
 */
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError("Unknown datetime argument: ".concat(dateTimeish, ", of type ").concat(typeof dateTimeish));
  }
}
;// CONCATENATED MODULE: ./node_modules/luxon/src/luxon.js










const VERSION = "3.4.4";


/***/ }),

/***/ 4420:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I0: () => (/* binding */ useDispatch),
/* harmony export */   oR: () => (/* binding */ useStore),
/* harmony export */   v9: () => (/* binding */ useSelector),
/* harmony export */   zt: () => (/* binding */ Provider_default)
/* harmony export */ });
/* unused harmony exports ReactReduxContext, batch, connect, createDispatchHook, createSelectorHook, createStoreHook, shallowEqual */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2791);
/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7995);
// src/index.ts



// src/utils/react.ts

var React =
// prettier-ignore
// @ts-ignore
 true ? react__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));

// src/components/Context.ts
var ContextKey = Symbol.for("react-redux-context");
var gT = typeof globalThis !== "undefined" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
{};
function getContext() {
  var _gT$ContextKey;
  if (!React.createContext) return {};
  const contextMap = (_gT$ContextKey = gT[ContextKey]) !== null && _gT$ContextKey !== void 0 ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */new Map();
  let realContext = contextMap.get(React.createContext);
  if (!realContext) {
    realContext = React.createContext(null);
    if (false) {}
    contextMap.set(React.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = /* @__PURE__ */getContext();

// src/utils/useSyncExternalStore.ts
var notInitialized = () => {
  throw new Error("uSES not initialized!");
};

// src/hooks/useReduxContext.ts
function createReduxContextHook() {
  let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;
  return function useReduxContext2() {
    const contextValue = React.useContext(context);
    if (false) {}
    return contextValue;
  };
}
var useReduxContext = /* @__PURE__ */createReduxContextHook();

// src/hooks/useSelector.ts
var useSyncExternalStoreWithSelector = notInitialized;
var initializeUseSelector = fn => {
  useSyncExternalStoreWithSelector = fn;
};
var refEquality = (a, b) => a === b;
function createSelectorHook() {
  let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  const useSelector2 = function (selector) {
    let equalityFnOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      equalityFn = refEquality,
      devModeChecks = {}
    } = typeof equalityFnOrOptions === "function" ? {
      equalityFn: equalityFnOrOptions
    } : equalityFnOrOptions;
    if (false) {}
    const {
      store,
      subscription,
      getServerState,
      stabilityCheck,
      identityFunctionCheck
    } = useReduxContext2();
    const firstRun = React.useRef(true);
    const wrappedSelector = React.useCallback({
      [selector.name](state) {
        const selected = selector(state);
        if (false) {}
        return selected;
      }
    }[selector.name], [selector, stabilityCheck, devModeChecks.stabilityCheck]);
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
    React.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
var useSelector = /* @__PURE__ */createSelectorHook();

// src/utils/react-is.ts
var REACT_ELEMENT_TYPE = Symbol.for("react.element");
var REACT_PORTAL_TYPE = Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
var REACT_CONTEXT_TYPE = Symbol.for("react.context");
var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
var REACT_MEMO_TYPE = Symbol.for("react.memo");
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function isValidElementType(type) {
  if (typeof type === "string" || typeof type === "function") {
    return true;
  }
  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {
    return true;
  }
  if (typeof type === "object" && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
    // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {
      return true;
    }
  }
  return false;
}
function typeOf(object) {
  if (typeof object === "object" && object !== null) {
    const $$typeof = object.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        {
          const type = object.type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
              return type;
            default:
              {
                const $$typeofType = type && type.$$typeof;
                switch ($$typeofType) {
                  case REACT_SERVER_CONTEXT_TYPE:
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
              }
          }
        }
      case REACT_PORTAL_TYPE:
        {
          return $$typeof;
        }
    }
  }
  return void 0;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}

// src/utils/warning.ts
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e) {}
}

// src/connect/verifySubselectors.ts
function verify(selector, methodName) {
  if (!selector) {
    throw new Error("Unexpected value for ".concat(methodName, " in connect."));
  } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
    if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
      warning("The selector for ".concat(methodName, " of connect did not specify a value for dependsOnOwnProps."));
    }
  }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {
  verify(mapStateToProps, "mapStateToProps");
  verify(mapDispatchToProps, "mapDispatchToProps");
  verify(mergeProps, "mergeProps");
}

// src/connect/selectorFactory.ts
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  let {
    areStatesEqual,
    areOwnPropsEqual,
    areStatePropsEqual
  } = _ref;
  let hasRunAtLeastOnce = false;
  let state;
  let ownProps;
  let stateProps;
  let dispatchProps;
  let mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, _ref2) {
  let {
    initMapStateToProps,
    initMapDispatchToProps,
    initMergeProps,
    ...options
  } = _ref2;
  const mapStateToProps = initMapStateToProps(dispatch, options);
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  const mergeProps = initMergeProps(dispatch, options);
  if (false) {}
  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}

// src/utils/bindActionCreators.ts
function bindActionCreators(actionCreators, dispatch) {
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = function () {
        return dispatch(actionCreator(...arguments));
      };
    }
  }
  return boundActionCreators;
}

// src/utils/isPlainObject.ts
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  const proto = Object.getPrototypeOf(obj);
  if (proto === null) return true;
  let baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}

// src/utils/verifyPlainObject.ts
function verifyPlainObject(value, displayName, methodName) {
  if (!isPlainObject(value)) {
    warning("".concat(methodName, "() in ").concat(displayName, " must return a plain object. Instead received ").concat(value, "."));
  }
}

// src/connect/wrapMapToProps.ts
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch) {
    const constant = getConstant(dispatch);
    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref3) {
    let {
      displayName
    } = _ref3;
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      let props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      if (false) {}
      return props;
    };
    return proxy;
  };
}

// src/connect/invalidArgFactory.ts
function createInvalidArgFactory(arg, name) {
  return (dispatch, options) => {
    throw new Error("Invalid value of type ".concat(typeof arg, " for ").concat(name, " argument when connecting component ").concat(options.wrappedComponentName, "."));
  };
}

// src/connect/mapDispatchToProps.ts
function mapDispatchToPropsFactory(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(dispatch =>
  // @ts-ignore
  bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant(dispatch => ({
    dispatch
  })) : typeof mapDispatchToProps === "function" ?
  // @ts-ignore
  wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps") : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
}

// src/connect/mapStateToProps.ts
function mapStateToPropsFactory(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ?
  // @ts-ignore
  wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}

// src/connect/mergeProps.ts
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return {
    ...ownProps,
    ...stateProps,
    ...dispatchProps
  };
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref4) {
    let {
      displayName,
      areMergedPropsEqual
    } = _ref4;
    let hasRunOnce = false;
    let mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (false) {}
      }
      return mergedProps;
    };
  };
}
function mergePropsFactory(mergeProps) {
  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
}

// src/utils/batch.ts
function defaultNoopBatch(callback) {
  callback();
}

// src/utils/Subscription.ts
function createListenerCollection() {
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {},
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}

// src/utils/useIsomorphicLayoutEffect.ts
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;

// src/utils/shallowEqual.ts
function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

// src/utils/hoistStatics.ts
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
function getStatics(component) {
  if (isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      const inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent);
      }
    }
    let keys = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }
    const targetStatics = getStatics(targetComponent);
    const sourceStatics = getStatics(sourceComponent);
    for (let i = 0; i < keys.length; ++i) {
      const key = keys[i];
      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }
  return targetComponent;
}

// src/components/connect.tsx
var useSyncExternalStore = (/* unused pure expression or super */ null && (notInitialized));
var initializeConnect = fn => {
  useSyncExternalStore = fn;
};
var NO_SUBSCRIPTION_ARRAY = (/* unused pure expression or super */ null && ([null, null]));
var stringifyComponent = Comp => {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
  if (!shouldHandleStateChanges) return () => {};
  let didUnsubscribe = false;
  let lastThrownError = null;
  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      return;
    }
    const latestStoreState = store.getState();
    let newChildProps, error;
    try {
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e) {
      error = e;
      lastThrownError = e;
    }
    if (!error) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      additionalSubscribeListener();
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
function strictEqual(a, b) {
  return a === b;
}
var hasWarnedAboutDeprecatedPureOption = false;
function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
  let {
    // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
    // @ts-ignore
    pure,
    areStatesEqual = strictEqual,
    areOwnPropsEqual = shallowEqual,
    areStatePropsEqual = shallowEqual,
    areMergedPropsEqual = shallowEqual,
    // use React's forwardRef to expose a ref of the wrapped component
    forwardRef = false,
    // the context consumer to use
    context = ReactReduxContext
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (false) {}
  const Context = context;
  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
  const initMergeProps = mergePropsFactory(mergeProps);
  const shouldHandleStateChanges = Boolean(mapStateToProps);
  const wrapWithConnect = WrappedComponent => {
    if (false) {}
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    const displayName = "Connect(".concat(wrappedComponentName, ")");
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      // @ts-ignore
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(() => {
        const {
          reactReduxForwardedRef: reactReduxForwardedRef2,
          ...wrapperProps2
        } = props;
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]);
      const ContextToUse = React.useMemo(() => {
        let ResultContext = Context;
        if (propsContext !== null && propsContext !== void 0 && propsContext.Consumer) {
          if (false) {}
        }
        return ResultContext;
      }, [propsContext, Context]);
      const contextValue = React.useContext(ContextToUse);
      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      if (false) {}
      const store = didStoreComeFromProps ? props.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
      const childPropsSelector = React.useMemo(() => {
        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
      }, [store]);
      const [subscription, notifyNestedSubs] = React.useMemo(() => {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
        const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);
        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]);
      const overriddenContextValue = React.useMemo(() => {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return {
          ...contextValue,
          subscription
        };
      }, [didStoreComeFromProps, contextValue, subscription]);
      const lastChildProps = React.useRef();
      const lastWrapperProps = React.useRef(wrapperProps);
      const childPropsFromStoreUpdate = React.useRef();
      const renderIsScheduled = React.useRef(false);
      const isProcessingDispatch = React.useRef(false);
      const isMounted = React.useRef(false);
      const latestSubscriptionCallbackError = React.useRef();
      useIsomorphicLayoutEffect(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector = React.useMemo(() => {
        const selector = () => {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store.getState(), wrapperProps);
        };
        return selector;
      }, [store, wrapperProps]);
      const subscribeForReact = React.useMemo(() => {
        const subscribe = reactListener => {
          if (!subscription) {
            return () => {};
          }
          return subscribeUpdates(shouldHandleStateChanges, store, subscription,
          // @ts-ignore
          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);
        };
        return subscribe;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      let actualChildProps;
      try {
        actualChildProps = useSyncExternalStore(
        // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
        subscribeForReact,
        // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
        actualChildPropsSelector, getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);
      } catch (err) {
        if (latestSubscriptionCallbackError.current) {
          ;
          err.message += "\nThe error may be correlated with this previous error:\n".concat(latestSubscriptionCallbackError.current.stack, "\n\n");
        }
        throw err;
      }
      useIsomorphicLayoutEffect(() => {
        latestSubscriptionCallbackError.current = void 0;
        childPropsFromStoreUpdate.current = void 0;
        lastChildProps.current = actualChildProps;
      });
      const renderedWrappedComponent = React.useMemo(() => {
        return (
          // @ts-ignore
          /* @__PURE__ */
          React.createElement(WrappedComponent, {
            ...actualChildProps,
            ref: reactReduxForwardedRef
          })
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      const renderedChild = React.useMemo(() => {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */React.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = React.memo(ConnectFunction);
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef) {
      const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {
        return /* @__PURE__ */React.createElement(Connect, {
          ...props,
          reactReduxForwardedRef: ref
        });
      });
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return /* @__PURE__ */hoistNonReactStatics(forwarded, WrappedComponent);
    }
    return /* @__PURE__ */hoistNonReactStatics(Connect, WrappedComponent);
  };
  return wrapWithConnect;
}
var connect_default = (/* unused pure expression or super */ null && (connect));

// src/components/Provider.tsx
function Provider(_ref5) {
  let {
    store,
    context,
    children,
    serverState,
    stabilityCheck = "once",
    identityFunctionCheck = "once"
  } = _ref5;
  const contextValue = React.useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0,
      stabilityCheck,
      identityFunctionCheck
    };
  }, [store, serverState, stabilityCheck, identityFunctionCheck]);
  const previousState = React.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return /* @__PURE__ */React.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
var Provider_default = Provider;

// src/hooks/useStore.ts
function createStoreHook() {
  let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext :
  // @ts-ignore
  createReduxContextHook(context);
  const useStore2 = () => {
    const {
      store
    } = useReduxContext2();
    return store;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = /* @__PURE__ */createStoreHook();

// src/hooks/useDispatch.ts
function createDispatchHook() {
  let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ReactReduxContext;
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store = useStore2();
    return store.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = /* @__PURE__ */createDispatchHook();

// src/exports.ts
var batch = (/* unused pure expression or super */ null && (defaultNoopBatch));

// src/index.ts
initializeUseSelector(use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);
initializeConnect(react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore);


/***/ }),

/***/ 1154:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LG: () => (/* binding */ isAction),
/* harmony export */   MT: () => (/* binding */ createStore),
/* harmony export */   PO: () => (/* binding */ isPlainObject),
/* harmony export */   UY: () => (/* binding */ combineReducers),
/* harmony export */   md: () => (/* binding */ applyMiddleware),
/* harmony export */   qC: () => (/* binding */ compose)
/* harmony export */ });
/* unused harmony exports __DO_NOT_USE__ActionTypes, bindActionCreators, legacy_createStore */
// src/utils/formatProdErrorMessage.ts
function formatProdErrorMessage(code) {
  return "Minified Redux error #".concat(code, "; visit https://redux.js.org/Errors?code=").concat(code, " for the full message or use the non-minified dev environment for full errors. ");
}

// src/utils/symbol-observable.ts
var $$observable = /* @__PURE__ */(() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;

// src/utils/actionTypes.ts
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: "@@redux/INIT".concat( /* @__PURE__ */randomString()),
  REPLACE: "@@redux/REPLACE".concat( /* @__PURE__ */randomString()),
  PROBE_UNKNOWN_ACTION: () => "@@redux/PROBE_UNKNOWN_ACTION".concat(randomString())
};
var actionTypes_default = ActionTypes;

// src/utils/isPlainObject.ts
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}

// src/utils/kindOf.ts
function miniKindOf(val) {
  if (val === void 0) return "undefined";
  if (val === null) return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      {
        return type;
      }
  }
  if (Array.isArray(val)) return "array";
  if (isDate(val)) return "date";
  if (isError(val)) return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (false) {}
  return typeOfVal;
}

// src/createStore.ts
function createStore(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error( true ? formatProdErrorMessage(2) : 0);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error( true ? formatProdErrorMessage(0) : 0);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error( true ? formatProdErrorMessage(1) : 0);
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(3) : 0);
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error( true ? formatProdErrorMessage(4) : 0);
    }
    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(5) : 0);
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error( true ? formatProdErrorMessage(6) : 0);
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error( true ? formatProdErrorMessage(7) : 0);
    }
    if (typeof action.type === "undefined") {
      throw new Error( true ? formatProdErrorMessage(8) : 0);
    }
    if (typeof action.type !== "string") {
      throw new Error( true ? formatProdErrorMessage(17) : 0);
    }
    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(9) : 0);
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach(listener => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error( true ? formatProdErrorMessage(10) : 0);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error( true ? formatProdErrorMessage(11) : 0);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function legacy_createStore(reducer, preloadedState, enhancer) {
  return createStore(reducer, preloadedState, enhancer);
}

// src/utils/warning.ts
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e) {}
}

// src/combineReducers.ts
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  const reducerKeys = Object.keys(reducers);
  const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject(inputState)) {
    return "The ".concat(argumentName, " has unexpected type of \"").concat(kindOf(inputState), "\". Expected argument to be an object with the following keys: \"").concat(reducerKeys.join('", "'), "\"");
  }
  const unexpectedKeys = Object.keys(inputState).filter(key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
  unexpectedKeys.forEach(key => {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === actionTypes_default.REPLACE) return;
  if (unexpectedKeys.length > 0) {
    return "Unexpected ".concat(unexpectedKeys.length > 1 ? "keys" : "key", " \"").concat(unexpectedKeys.join('", "'), "\" found in ").concat(argumentName, ". Expected to find one of the known reducer keys instead: \"").concat(reducerKeys.join('", "'), "\". Unexpected keys will be ignored.");
  }
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(key => {
    const reducer = reducers[key];
    const initialState = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState === "undefined") {
      throw new Error( true ? formatProdErrorMessage(12) : 0);
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error( true ? formatProdErrorMessage(13) : 0);
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i];
    if (false) {}
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let unexpectedKeyCache;
  if (false) {}
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }
  return function combination() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : undefined;
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (false) {}
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        const actionType = action && action.type;
        throw new Error( true ? formatProdErrorMessage(14) : 0);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

// src/bindActionCreators.ts
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return dispatch(actionCreator.apply(this, args));
  };
}
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error( true ? formatProdErrorMessage(16) : 0);
  }
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

// src/compose.ts
function compose() {
  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    funcs[_key2] = arguments[_key2];
  }
  if (funcs.length === 0) {
    return arg => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a, b) => function () {
    return a(b(...arguments));
  });
}

// src/applyMiddleware.ts
function applyMiddleware() {
  for (var _len3 = arguments.length, middlewares = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    middlewares[_key3] = arguments[_key3];
  }
  return createStore2 => (reducer, preloadedState) => {
    const store = createStore2(reducer, preloadedState);
    let dispatch = () => {
      throw new Error( true ? formatProdErrorMessage(15) : 0);
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: function (action) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        return dispatch(action, ...args);
      }
    };
    const chain = middlewares.map(middleware => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}

// src/utils/isAction.ts
function isAction(action) {
  return isPlainObject(action) && "type" in action && typeof action.type === "string";
}


/***/ }),

/***/ 3553:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P1: () => (/* binding */ createSelector),
/* harmony export */   kO: () => (/* binding */ weakMapMemoize),
/* harmony export */   wN: () => (/* binding */ createSelectorCreator)
/* harmony export */ });
/* unused harmony exports createStructuredSelector, lruMemoize, referenceEqualityCheck, setGlobalDevModeChecks, unstable_autotrackMemoize */
/* harmony import */ var _home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4572);

// src/devModeChecks/identityFunctionCheck.ts
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;
    } catch {}
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e) {
        ;
        ({
          stack
        } = e);
      }
      console.warn("The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.", {
        stack
      });
    }
  }
};

// src/devModeChecks/inputStabilityCheck.ts
var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {
  const {
    memoize,
    memoizeOptions
  } = options;
  const {
    inputSelectorResults,
    inputSelectorResultsCopy
  } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e) {
      ;
      ({
        stack
      } = e);
    }
    console.warn("An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`", {
      arguments: inputSelectorArgs,
      firstInputs: inputSelectorResults,
      secondInputs: inputSelectorResultsCopy,
      stack
    });
  }
};

// src/devModeChecks/setGlobalDevModeChecks.ts
var globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
var setGlobalDevModeChecks = devModeChecks => {
  Object.assign(globalDevModeChecks, devModeChecks);
};

// src/utils.ts
var NOT_FOUND = "NOT_FOUND";
function assertIsFunction(func) {
  let errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "expected a function, instead received ".concat(typeof func);
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object) {
  let errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "expected an object, instead received ".concat(typeof object);
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array) {
  let errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "expected all items to be functions, instead received the following types: ";
  if (!array.every(item => typeof item === "function")) {
    const itemTypes = array.map(item => typeof item === "function" ? "function ".concat(item.name || "unnamed", "()") : typeof item).join(", ");
    throw new TypeError("".concat(errorMessage, "[").concat(itemTypes, "]"));
  }
}
var ensureIsArray = item => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(dependencies, "createSelector expects all input-selectors to be functions, but received the following types: ");
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const {
    length
  } = dependencies;
  for (let i = 0; i < length; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const {
    identityFunctionCheck,
    inputStabilityCheck
  } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};

// src/autotrackMemoize/autotracking.ts
var $REVISION = 0;
var CURRENT_TRACKER = null;
var Cell = class Cell {
  constructor(initialValue) {
    let isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "revision", $REVISION);
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "_value", void 0);
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "_lastValue", void 0);
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "_isEqual", tripleEq);
    this._value = this._lastValue = initialValue;
    this._isEqual = isEqual;
  }
  // Whenever a storage value is read, it'll add itself to the current tracker if
  // one exists, entangling its state with that cache.
  get value() {
    var _CURRENT_TRACKER;
    (_CURRENT_TRACKER = CURRENT_TRACKER) === null || _CURRENT_TRACKER === void 0 ? void 0 : _CURRENT_TRACKER.add(this);
    return this._value;
  }
  // Whenever a storage value is updated, we bump the global revision clock,
  // assign the revision for this storage to the new value, _and_ we schedule a
  // rerender. This is important, and it's what makes autotracking  _pull_
  // based. We don't actively tell the caches which depend on the storage that
  // anything has happened. Instead, we recompute the caches when needed.
  set value(newValue) {
    if (this.value === newValue) return;
    this._value = newValue;
    this.revision = ++$REVISION;
  }
};
function tripleEq(a, b) {
  return a === b;
}
var TrackingCache = class TrackingCache {
  constructor(fn) {
    _defineProperty(this, "_cachedValue", void 0);
    _defineProperty(this, "_cachedRevision", -1);
    _defineProperty(this, "_deps", []);
    _defineProperty(this, "hits", 0);
    _defineProperty(this, "fn", void 0);
    this.fn = fn;
  }
  clear() {
    this._cachedValue = void 0;
    this._cachedRevision = -1;
    this._deps = [];
    this.hits = 0;
  }
  get value() {
    var _CURRENT_TRACKER2;
    if (this.revision > this._cachedRevision) {
      const {
        fn
      } = this;
      const currentTracker = /* @__PURE__ */new Set();
      const prevTracker = CURRENT_TRACKER;
      CURRENT_TRACKER = currentTracker;
      this._cachedValue = fn();
      CURRENT_TRACKER = prevTracker;
      this.hits++;
      this._deps = Array.from(currentTracker);
      this._cachedRevision = this.revision;
    }
    (_CURRENT_TRACKER2 = CURRENT_TRACKER) === null || _CURRENT_TRACKER2 === void 0 ? void 0 : _CURRENT_TRACKER2.add(this);
    return this._cachedValue;
  }
  get revision() {
    return Math.max(...this._deps.map(d => d.revision), 0);
  }
};
function getValue(cell) {
  if (!(cell instanceof Cell)) {
    console.warn("Not a valid cell! ", cell);
  }
  return cell.value;
}
function setValue(storage, value) {
  if (!(storage instanceof Cell)) {
    throw new TypeError("setValue must be passed a tracked store created with `createStorage`.");
  }
  storage.value = storage._lastValue = value;
}
function createCell(initialValue) {
  let isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;
  return new Cell(initialValue, isEqual);
}
function createCache(fn) {
  assertIsFunction(fn, "the first parameter to `createCache` must be a function");
  return new TrackingCache(fn);
}

// src/autotrackMemoize/tracking.ts
var neverEq = (a, b) => false;
function createTag() {
  return createCell(null, neverEq);
}
function dirtyTag(tag, value) {
  setValue(tag, value);
}
var consumeCollection = node => {
  let tag = node.collectionTag;
  if (tag === null) {
    tag = node.collectionTag = createTag();
  }
  getValue(tag);
};
var dirtyCollection = node => {
  const tag = node.collectionTag;
  if (tag !== null) {
    dirtyTag(tag, null);
  }
};

// src/autotrackMemoize/proxy.ts
var REDUX_PROXY_LABEL = Symbol();
var nextId = 0;
var proto = Object.getPrototypeOf({});
var ObjectTreeNode = class ObjectTreeNode {
  constructor(value) {
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "proxy", new Proxy(this, objectProxyHandler));
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "tag", createTag());
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "tags", {});
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "children", {});
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "collectionTag", null);
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "id", nextId++);
    this.value = value;
    this.value = value;
    this.tag.value = value;
  }
};
var objectProxyHandler = {
  get(node, key) {
    function calculateResult() {
      const {
        value
      } = node;
      const childValue = Reflect.get(value, key);
      if (typeof key === "symbol") {
        return childValue;
      }
      if (key in proto) {
        return childValue;
      }
      if (typeof childValue === "object" && childValue !== null) {
        let childNode = node.children[key];
        if (childNode === void 0) {
          childNode = node.children[key] = createNode(childValue);
        }
        if (childNode.tag) {
          getValue(childNode.tag);
        }
        return childNode.proxy;
      } else {
        let tag = node.tags[key];
        if (tag === void 0) {
          tag = node.tags[key] = createTag();
          tag.value = childValue;
        }
        getValue(tag);
        return childValue;
      }
    }
    const res = calculateResult();
    return res;
  },
  ownKeys(node) {
    consumeCollection(node);
    return Reflect.ownKeys(node.value);
  },
  getOwnPropertyDescriptor(node, prop) {
    return Reflect.getOwnPropertyDescriptor(node.value, prop);
  },
  has(node, prop) {
    return Reflect.has(node.value, prop);
  }
};
var ArrayTreeNode = class ArrayTreeNode {
  constructor(value) {
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "proxy", new Proxy([this], arrayProxyHandler));
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "tag", createTag());
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "tags", {});
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "children", {});
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "collectionTag", null);
    (0,_home_runner_work_elterngeldrechner_elterngeldrechner_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "id", nextId++);
    this.value = value;
    this.value = value;
    this.tag.value = value;
  }
};
var arrayProxyHandler = {
  get(_ref, key) {
    let [node] = _ref;
    if (key === "length") {
      consumeCollection(node);
    }
    return objectProxyHandler.get(node, key);
  },
  ownKeys(_ref2) {
    let [node] = _ref2;
    return objectProxyHandler.ownKeys(node);
  },
  getOwnPropertyDescriptor(_ref3, prop) {
    let [node] = _ref3;
    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);
  },
  has(_ref4, prop) {
    let [node] = _ref4;
    return objectProxyHandler.has(node, prop);
  }
};
function createNode(value) {
  if (Array.isArray(value)) {
    return new ArrayTreeNode(value);
  }
  return new ObjectTreeNode(value);
}
function updateNode(node, newValue) {
  const {
    value,
    tags,
    children
  } = node;
  node.value = newValue;
  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {
    dirtyCollection(node);
  } else {
    if (value !== newValue) {
      let oldKeysSize = 0;
      let newKeysSize = 0;
      let anyKeysAdded = false;
      for (const _key in value) {
        oldKeysSize++;
      }
      for (const key in newValue) {
        newKeysSize++;
        if (!(key in value)) {
          anyKeysAdded = true;
          break;
        }
      }
      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;
      if (isDifferent) {
        dirtyCollection(node);
      }
    }
  }
  for (const key in tags) {
    const childValue = value[key];
    const newChildValue = newValue[key];
    if (childValue !== newChildValue) {
      dirtyCollection(node);
      dirtyTag(tags[key], newChildValue);
    }
    if (typeof newChildValue === "object" && newChildValue !== null) {
      delete tags[key];
    }
  }
  for (const key in children) {
    const childNode = children[key];
    const newChildValue = newValue[key];
    const childValue = childNode.value;
    if (childValue === newChildValue) {
      continue;
    } else if (typeof newChildValue === "object" && newChildValue !== null) {
      updateNode(childNode, newChildValue);
    } else {
      deleteNode(childNode);
      delete children[key];
    }
  }
}
function deleteNode(node) {
  if (node.tag) {
    dirtyTag(node.tag, null);
  }
  dirtyCollection(node);
  for (const key in node.tags) {
    dirtyTag(node.tags[key], null);
  }
  for (const key in node.children) {
    deleteNode(node.children[key]);
  }
}

// src/lruMemoize.ts
function createSingletonCache(equals) {
  let entry;
  return {
    get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put(key, value) {
      entry = {
        key,
        value
      };
    },
    getEntries() {
      return entry ? [entry] : [];
    },
    clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  let entries = [];
  function get(key) {
    const cacheIndex = entries.findIndex(entry => equals(key, entry.key));
    if (cacheIndex > -1) {
      const entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({
        key,
        value
      });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return {
    get,
    put,
    getEntries,
    clear
  };
}
var referenceEqualityCheck = (a, b) => a === b;
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    }
    const {
      length
    } = prev;
    for (let i = 0; i < length; i++) {
      if (!equalityCheck(prev[i], next[i])) {
        return false;
      }
    }
    return true;
  };
}
function lruMemoize(func, equalityCheckOrOptions) {
  const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  const {
    equalityCheck = referenceEqualityCheck,
    maxSize = 1,
    resultEqualityCheck
  } = providedOptions;
  const comparator = createCacheKeyComparator(equalityCheck);
  let resultsCount = 0;
  const cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    let value = cache.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const entries = cache.getEntries();
        const matchingEntry = entries.find(entry => resultEqualityCheck(entry.value, value));
        if (matchingEntry) {
          value = matchingEntry.value;
          resultsCount !== 0 && resultsCount--;
        }
      }
      cache.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = () => {
    cache.clear();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}

// src/autotrackMemoize/autotrackMemoize.ts
function autotrackMemoize(func) {
  const node = createNode([]);
  let lastArgs = null;
  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);
  const cache = createCache(() => {
    const res = func.apply(null, node.proxy);
    return res;
  });
  function memoized() {
    if (!shallowEqual(lastArgs, arguments)) {
      updateNode(node, arguments);
      lastArgs = arguments;
    }
    return cache.value;
  }
  memoized.clearCache = () => {
    return cache.clear();
  };
  return memoized;
}

// src/weakMapMemoize.ts
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let fnNode = createCacheNode();
  const {
    resultEqualityCheck
  } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    let cacheNode = fnNode;
    const {
      length
    } = arguments;
    for (let i = 0, l = length; i < l; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
    }
    terminatedNode.s = TERMINATED;
    if (resultEqualityCheck) {
      var _lastResult$deref, _lastResult, _lastResult$deref2;
      const lastResultValue = (_lastResult$deref = (_lastResult = lastResult) === null || _lastResult === void 0 ? void 0 : (_lastResult$deref2 = _lastResult.deref) === null || _lastResult$deref2 === void 0 ? void 0 : _lastResult$deref2.call(_lastResult)) !== null && _lastResult$deref !== void 0 ? _lastResult$deref : lastResult;
      if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
        result = lastResultValue;
        resultsCount !== 0 && resultsCount--;
      }
      const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
      lastResult = needsWeakRef ? new Ref(result) : result;
    }
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}

// src/createSelectorCreator.ts
function createSelectorCreator(memoizeOrOptions) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
    memoizeOptionsFromArgs[_key2 - 1] = arguments[_key2];
  }
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = function () {
    for (var _len2 = arguments.length, createSelectorArgs = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      createSelectorArgs[_key3] = arguments[_key3];
    }
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(resultFunc, "createSelector expects an output function after the inputs, but received: [".concat(typeof resultFunc, "]"));
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(null, arguments);
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      if (false) {}
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = /* @__PURE__ */createSelectorCreator(weakMapMemoize);

// src/createStructuredSelector.ts
var createStructuredSelector = Object.assign(function (inputSelectorsObject) {
  let selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;
  assertIsObject(inputSelectorsObject, "createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ".concat(typeof inputSelectorsObject));
  const inputSelectorKeys = Object.keys(inputSelectorsObject);
  const dependencies = inputSelectorKeys.map(key => inputSelectorsObject[key]);
  const structuredSelector = selectorCreator(dependencies, function () {
    for (var _len3 = arguments.length, inputSelectorResults = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
      inputSelectorResults[_key4] = arguments[_key4];
    }
    return inputSelectorResults.reduce((composition, value, index) => {
      composition[inputSelectorKeys[index]] = value;
      return composition;
    }, {});
  });
  return structuredSelector;
}, {
  withTypes: () => createStructuredSelector
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/js/" + chunkId + "." + {"1":"f872e96d","81":"8971803a","205":"8831e4f3","323":"16c6572e","496":"66c63145","521":"7033e7a5","597":"7fd4d88a","623":"a49d7536","678":"2a6b4e4d"}[chunkId] + ".chunk.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "@egr/egr-app:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "./";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			179: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_egr_egr_app"] = self["webpackChunk_egr_egr_app"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(2791);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(1250);
// EXTERNAL MODULE: ./node_modules/react-redux/dist/react-redux.mjs
var react_redux = __webpack_require__(4420);
// EXTERNAL MODULE: ./node_modules/react-router/dist/index.js
var dist = __webpack_require__(7689);
// EXTERNAL MODULE: ./src/components/atoms/index.ts + 35 modules
var atoms = __webpack_require__(2932);
;// CONCATENATED MODULE: ./src/styles/tailwind.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const tailwind = ({});
;// CONCATENATED MODULE: ./src/styles/axioms.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const axioms = ({});
;// CONCATENATED MODULE: ./src/styles/themes.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const themes = ({});
;// CONCATENATED MODULE: ./src/styles/typo.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const typo = ({});
;// CONCATENATED MODULE: ./src/applications/index.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const applications = ({});
// EXTERNAL MODULE: ./src/utils/formSteps.ts
var formSteps = __webpack_require__(8137);
// EXTERNAL MODULE: ./src/redux/hooks.ts
var hooks = __webpack_require__(3153);
// EXTERNAL MODULE: ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs + 2 modules
var redux_toolkit_modern = __webpack_require__(7291);
;// CONCATENATED MODULE: ./src/redux/configurationSlice.ts
const initialStepConfigurationState={elternGeldDigitalWizardUrl:""};const configurationSlice=(0,redux_toolkit_modern/* createSlice */.oM)({name:"configuration",initialState:initialStepConfigurationState,reducers:{configure:(_,action)=>{return action.payload;}}});const configurationActions=configurationSlice.actions;/* harmony default export */ const redux_configurationSlice = (configurationSlice.reducer);
// EXTERNAL MODULE: ./src/components/organisms/page/index.ts + 4 modules
var page = __webpack_require__(2995);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(1418);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/@digitalservicebund/icons/ExpandLess.js
var ExpandLess = __webpack_require__(8096);
var ExpandLess_default = /*#__PURE__*/__webpack_require__.n(ExpandLess);
// EXTERNAL MODULE: ./node_modules/@digitalservicebund/icons/ExpandMore.js
var ExpandMore = __webpack_require__(9068);
var ExpandMore_default = /*#__PURE__*/__webpack_require__.n(ExpandMore);
// EXTERNAL MODULE: ./node_modules/@digitalservicebund/icons/PermIdentity.js
var PermIdentity = __webpack_require__(8056);
var PermIdentity_default = /*#__PURE__*/__webpack_require__.n(PermIdentity);
// EXTERNAL MODULE: ./src/utils/locale-formatting.ts
var locale_formatting = __webpack_require__(3227);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(184);
;// CONCATENATED MODULE: ./src/components/organisms/elterngeldvarianten/PayoutInformation.tsx
function PayoutInformation(_ref){let{name,amount}=_ref;const formattedAmount=(0,locale_formatting/* formatAsCurrency */.c)(amount);return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{children:[/*#__PURE__*/(0,jsx_runtime.jsx)((PermIdentity_default()),{})," ",!!name&&"".concat(name," | "),/*#__PURE__*/(0,jsx_runtime.jsx)("strong",{children:formattedAmount})," pro Monat"]});}
;// CONCATENATED MODULE: ./src/components/organisms/elterngeldvarianten/DetailsElterngeldvariante.tsx
function DetailsElterngeldvariante(_ref){let{summaryTitle,summaryClassName,monthsAvailable,payoutAmounts,children}=_ref;const isSingleParent=payoutAmounts.length===1;return/*#__PURE__*/(0,jsx_runtime.jsxs)("details",{className:"group overflow-hidden rounded bg-grey",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("summary",{className:classnames_default()("flex justify-between list-none items-center cursor-pointer px-24 py-16",summaryClassName),children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"flex flex-wrap gap-y-10",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("h4",{className:"flex basis-full flex-wrap items-center gap-x-8 text-24",children:[summaryTitle,/*#__PURE__*/(0,jsx_runtime.jsxs)("span",{className:"text-base font-regular",children:["(",monthsAvailable," Monate verf\xFCgbar)"]})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"flex flex-wrap gap-x-24 gap-y-8",children:payoutAmounts.map(_ref2=>{let{name,amount}=_ref2;return/*#__PURE__*/(0,jsx_runtime.jsx)(PayoutInformation,{name:isSingleParent?undefined:name,amount:amount},name);})})]}),/*#__PURE__*/(0,jsx_runtime.jsx)((ExpandMore_default()),{className:"min-h-40 min-w-40 group-open:hidden"}),/*#__PURE__*/(0,jsx_runtime.jsx)((ExpandLess_default()),{className:"hidden min-h-40 min-w-40 group-open:block"})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"bg-off-white p-32 pb-56",children:children})]});}
// EXTERNAL MODULE: ./node_modules/@digitalservicebund/icons/PersonOutline.js
var PersonOutline = __webpack_require__(1539);
var PersonOutline_default = /*#__PURE__*/__webpack_require__.n(PersonOutline);
;// CONCATENATED MODULE: ./src/components/organisms/elterngeldvarianten/Example.tsx
function Example(_ref){let{title,months}=_ref;const monthClassName=month=>{return classnames_default()("rounded w-[1.75rem] aspect-square flex items-center justify-center leading-none pb-4",{"egr-elterngeld-basis":month==="Basis","egr-elterngeld-plus":month==="Plus","egr-elterngeld-bonus":month==="Bonus","egr-elterngeld-none":month===null});};return/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"flex gap-20 md:pl-56",role:"presentation",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"shrink-0 content-center",children:[/*#__PURE__*/(0,jsx_runtime.jsx)((PersonOutline_default()),{}),title]}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"flex flex-wrap gap-8",children:months.map((month,index)=>/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:monthClassName(month),children:index+1},index))})]});}
;// CONCATENATED MODULE: ./src/components/organisms/elterngeldvarianten/FurtherInformation.tsx
function FurtherInformation(){return/*#__PURE__*/(0,jsx_runtime.jsxs)("p",{className:"p-0",children:["Weitere Informationen finden Sie auf der"," ",/*#__PURE__*/(0,jsx_runtime.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://www.bmfsfj.de/bmfsfj/themen/familie/familienleistungen/elterngeld/elterngeld-73752",className:"underline",children:"Webseite des Familienministeriums"})]});}
// EXTERNAL MODULE: ./src/redux/stepRechnerSlice.ts + 25 modules
var stepRechnerSlice = __webpack_require__(2760);
// EXTERNAL MODULE: ./src/redux/stepAllgemeineAngabenSlice.ts
var stepAllgemeineAngabenSlice = __webpack_require__(177);
;// CONCATENATED MODULE: ./src/components/organisms/elterngeldvarianten/usePayoutAmounts.ts
/**
 * Wrapper around the currently messy approach to use the calculation of the
 * payout amounts defined in the Redux store. As the whole calculation is very
 * tangled and hard to use independently of the stores, this hook should
 * simplify the usage.
 * The hook is fully optimized and typed for its specific usage and context
 * within the component tree.
 */function usePayoutAmounts(){const store=(0,hooks/* useAppStore */.qr)();const[payoutAmounts,setPayoutAmounts]=(0,react.useState)();const applicant=(0,hooks/* useAppSelector */.CG)(state=>state.stepAllgemeineAngaben.antragstellende);const isSingleParent=applicant==="EinenElternteil";const parentNames=(0,hooks/* useAppSelector */.CG)(stepAllgemeineAngabenSlice/* stepAllgemeineAngabenSelectors */.cI.getElternteilNames);(0,react.useEffect)(()=>{const promises=[determinePayoutAmountForParent(store,"ET1",parentNames.ET1)];if(!isSingleParent){promises.push(determinePayoutAmountForParent(store,"ET2",parentNames.ET2));}Promise.all(promises).then(setPayoutAmounts);},[store,isSingleParent,parentNames]);return payoutAmounts;}async function determinePayoutAmountForParent(store,parent,name){const state=store.getState();const rows=await (0,stepRechnerSlice/* calculateElterngeld */.al)(state,parent,EMPTY_FUTURE_INCOME);const{basisElternGeld,elternGeldPlus}=findFristRepresentativeMonth(rows);return{name,basiselterngeld:basisElternGeld,elterngeldplus:elternGeldPlus,partnerschaftsbonus:elternGeldPlus};}/**
 * The goal is to find a single amount per variant that is representative and
 * give the user an idea how much the payout would be. But the calculated result
 * provides a list with amounts per month. As there is no better evaluation,
 * just the first month is taken.
 * But as there can be scenarios like maternity protection, the first months are
 * skipped, till the first month with a non zero payout amount. This might
 * differ between both parents, especially in the maternity protection scenario.
 */function findFristRepresentativeMonth(rows){var _rows$find;return(_rows$find=rows.find(row=>row.basisElternGeld>0))!==null&&_rows$find!==void 0?_rows$find:rows[0];}/**
 * The actual calculation (at the used level) includes the values of some
 * potential additional income while receiving parental allowance. To "just" get
 * some payout amounts as an initial overview, there is no income to calculate
 * with.
 */const EMPTY_FUTURE_INCOME=[];
;// CONCATENATED MODULE: ./src/components/organisms/elterngeldvarianten/ElterngeldvariantenDescriptions.tsx
function ElterngeldvariantenDescriptions(){const payoutAmounts=usePayoutAmounts();if(payoutAmounts===undefined){return/*#__PURE__*/(0,jsx_runtime.jsx)(atoms/* Spinner */.$j,{});}else{return/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsxs)(DetailsElterngeldvariante,{summaryTitle:"Basiselterngeld",summaryClassName:"bg-Basis text-white",monthsAvailable:14,payoutAmounts:pickAmountsOfVariant(payoutAmounts,"basiselterngeld"),children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("ul",{className:"mb-24 list-disc pl-24",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Als Basiselterngeld bekommen Sie normalerweise 65 Prozent des Nettoeinkommens, dass Sie vor der Geburt Ihres Kindes hatten und das nach der Geburt wegf\xE4llt"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Basiselterngeld betr\xE4gt mindestens 300 Euro und h\xF6chstens 1.800 Euro monatlich"})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"F\xFCr Paare und getrennt Erziehende gilt:"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("ul",{className:"mb-24 list-disc pl-24",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"die 14 Basiselterngeldmonate k\xF6nnen Sie untereinander aufteilen"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Voraussetzung: mindestens einer von Ihnen hat in 2 Lebensmonaten nach der Geburt weniger Einkommen als davor"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("li",{children:["zwei Einschr\xE4nkungen gibt es:",/*#__PURE__*/(0,jsx_runtime.jsxs)("ul",{className:"list-disc pl-24",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Jeder Elternteil kann maximal 12 Monate Basiselterngeld bekommen"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Gleichzeitiger Bezug von Basiselterngeld mit Ihrem Partner oder Ihrer Partnerin ist nur maximal einen Monat in den ersten 12 Lebensmonaten Ihres Kindes m\xF6glich"})]})]})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"F\xFCr Alleinerziehende gilt:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("ul",{className:"mb-24 list-disc pl-24",children:/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"14 Monate Basiselterngeld k\xF6nnen beantragt werden"})}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"Ausnahmen:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{className:"p-0",children:"Basiselterngeld kann f\xFCr mehr als einen Monat gleichzeitig bezogen werden, wenn einer der folgenden Sachverhalte auf Sie zutrifft:"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("ul",{className:"mb-32 list-disc pl-24",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Sie sind Eltern von besonders fr\xFCh geborenen Kindern, die mindestens sechs Wochen vor dem errechneten Geburtstermin geboren wurden"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Sie sind Eltern von Zwillingen, Drillingen und weiteren Mehrlingen"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Sie haben ein neugeborenes Kind mit Behinderung oder ein Geschwisterkind mit Behinderung"})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"Beispiele f\xFCr Paare und getrennt Erziehende:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{className:"mb-20 p-0",children:"Elternteil 1 beantragt in den Lebensmonaten 1 bis 7 Basiselterngeld und Elternteil 2 in den Lebensmonaten 7 bis 13. Im Lebensmonat 7 planen Sie einen Monat parallel."}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-16",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 1",months:["Basis","Basis","Basis","Basis","Basis","Basis","Basis",null,null,null,null,null,null,null]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-32",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 2",months:[null,null,null,null,null,null,"Basis","Basis","Basis","Basis","Basis","Basis","Basis",null]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{className:"mb-20 p-0",children:"Elternteil 1 beantragt in den Lebensmonaten 1 bis 10 Basiselterngeld. Elternteil 2 beantragt in den Lebensmonaten 11 bis 14 Basiselterngeld. Damit haben die Eltern ihren Anspruch auf 14 Monate Basiselterngeld ausgesch\xF6pft."}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-16",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 1",months:["Basis","Basis","Basis","Basis","Basis","Basis","Basis","Basis","Basis","Basis",null,null,null,null]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-32",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 2",months:[null,null,null,null,null,null,null,null,null,null,"Basis","Basis","Basis","Basis"]})}),/*#__PURE__*/(0,jsx_runtime.jsx)(FurtherInformation,{})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)(DetailsElterngeldvariante,{summaryTitle:"ElterngeldPlus",summaryClassName:"bg-Plus text-black",monthsAvailable:28,payoutAmounts:pickAmountsOfVariant(payoutAmounts,"elterngeldplus"),children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("ul",{className:"mb-24 list-disc pl-24",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Statt eines Lebensmonats Basiselterngeld k\xF6nnen Sie 2 Lebensmonate ElterngeldPlus bekommen \u2013 das hei\xDFt, halb so hoch wie Basiselterngeld, aber doppelter Zeitraum"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"ElterngeldPlus kann auch nach dem 14. Lebensmonat bezogen werden, ab dann darf der Elterngeldbezug nicht mehr unterbrochen werden"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Besonders lohnend, wenn Eltern nach der Geburt in Teilzeit arbeiten"})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"F\xFCr Paare und getrennt Erziehende gilt:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("ul",{className:"mb-24 list-disc pl-24",children:/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Basiselterngeld und ElterngeldPlus k\xF6nnen Sie miteinander kombinieren und abwechseln"})}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"F\xFCr Alleinerziehende gilt:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("ul",{className:"mb-32 list-disc pl-24",children:/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"28 Monate ElterngeldPlus k\xF6nnen beantragt werden"})}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"Beispiele f\xFCr Paare und getrennt Erziehende:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{className:"mb-20 p-0",children:"Elternteil 1 bekommt Basiselterngeld in den ersten 4 Lebensmonaten, Elternteil 2 in den Lebensmonaten 5 und 6. Beide Eltern bekommen ElterngeldPlus in den Lebensmonaten 7 bis 14. Damit haben die Eltern 6 Monate Basiselterngeld und 16 Monate ElterngeldPlus (8 Monate ElterngeldPlus pro Elternteil) verbraucht; das entspricht 14 Monaten Basiselterngeld."}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-16",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 1",months:["Basis","Basis","Basis","Basis",null,null,"Plus","Plus","Plus","Plus","Plus","Plus","Plus","Plus"]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-32",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 2",months:[null,null,null,null,"Basis","Basis","Plus","Plus","Plus","Plus","Plus","Plus","Plus","Plus"]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{className:"mb-20 p-0",children:"Elternteil 1 bekommt Basiselterngeld in den Lebensmonaten 1 bis 6. Parallel bezieht der Elternteil 2 in Lebensmonat 1 Basiselterngeld und in den Lebensmonaten 2 und 3 ElterngeldPlus. In den Lebensmonaten 7 bis 10 beziehen beide Elternteile ElterngeldPlus. Elternteil 2 bekommt in den Lebensmonaten 11 und 12 ElterngeldPlus und in Lebensmonat 13 Basiselterngeld. Damit haben die Eltern ihren Anspruch auf 14 Monate Basiselterngeld ausgesch\xF6pft."}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-16",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 1",months:["Basis","Basis","Basis","Basis","Basis","Basis","Plus","Plus","Plus","Plus",null,null,null,null]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-32",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 2",months:["Basis","Plus","Plus",null,null,null,"Plus","Plus","Plus","Plus","Plus","Plus","Basis",null]})}),/*#__PURE__*/(0,jsx_runtime.jsx)(FurtherInformation,{})]}),/*#__PURE__*/(0,jsx_runtime.jsxs)(DetailsElterngeldvariante,{summaryTitle:"+ Partnerschaftsbonus",summaryClassName:"bg-Bonus text-black",monthsAvailable:4,payoutAmounts:pickAmountsOfVariant(payoutAmounts,"partnerschaftsbonus"),children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("ul",{className:"mb-24 list-disc pl-24",children:[/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Zus\xE4tzliche 2, 3 oder 4 Monate ElterngeldPlus \u2013 direkt aufeinander folgend"}),/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"F\xFCr den Partnerschaftsbonus muss man 24 bis 32 Stunden pro Woche in Teilzeit arbeiten"})]}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"F\xFCr Paare und getrennt Erziehende gilt:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("ul",{className:"mb-24 list-disc pl-24",children:/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Beide Elternteile nutzen den Partnerschaftsbonus gleichzeitig"})}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"F\xFCr Alleinerziehende gilt:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("ul",{className:"mb-32 list-disc pl-24",children:/*#__PURE__*/(0,jsx_runtime.jsx)("li",{children:"Der Partnerschaftsbonus kann auch allein beantragt werden"})}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"Beispiele f\xFCr Paare und getrennt Erziehende:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{className:"mb-20 p-0",children:"Das Elternteil 1 bezieht in den ersten 6 Lebensmonaten Basiselterngeld. Vom Lebensmonat 7 bis 10 bezieht der Elternteil 2 Basiselterngeld. Die Elternteile beziehen parallel ElterngeldPlus in den Lebensmonaten 11 bis 14. In den Lebensmonaten 15 bis 18 nutzen die Elternteile den Partnerschaftsbonus."}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-16",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 1",months:["Basis","Basis","Basis","Basis","Basis","Basis",null,null,null,null,"Plus","Plus","Plus","Plus","Bonus","Bonus","Bonus","Bonus"]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-32",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil 2",months:[null,null,null,null,null,null,"Basis","Basis","Basis","Basis","Plus","Plus","Plus","Plus","Bonus","Bonus","Bonus","Bonus"]})}),/*#__PURE__*/(0,jsx_runtime.jsx)("h5",{className:"text-base",children:"Ein Beispiel f\xFCr Alleinerziehende:"}),/*#__PURE__*/(0,jsx_runtime.jsx)("p",{className:"mb-20 p-0",children:"Das alleinerziehende Elternteil bezieht in den ersten 8 Lebensmonaten Basiselterngeld. Danach bezieht es f\xFCr 2 Monate kein Elterngeld. Im Lebensmonat 11 bis 16 bezieht es ElterngeldPlus, vom Lebensmonat 17 bis 20 den Partnerschaftsbonus und vom Lebensmonat 21 bis 26 nochmals ElterngeldPlus."}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{className:"mb-32",children:/*#__PURE__*/(0,jsx_runtime.jsx)(Example,{title:"Elternteil",months:["Basis","Basis","Basis","Basis","Basis","Basis","Basis","Basis",null,null,"Plus","Plus","Plus","Plus","Plus","Plus","Bonus","Bonus","Bonus","Bonus","Plus","Plus","Plus","Plus","Plus","Plus"]})}),/*#__PURE__*/(0,jsx_runtime.jsx)(FurtherInformation,{})]})]});}}function pickAmountsOfVariant(payoutAmounts,variant){return payoutAmounts.map(entry=>({name:entry.name,amount:entry[variant]}));}
;// CONCATENATED MODULE: ./src/components/organisms/elterngeldvarianten/index.ts

;// CONCATENATED MODULE: ./src/components/pages/ElterngeldvariantenPage.tsx
function ElterngeldvariantenPage(){const descriptionIdentifier=(0,react.useId)();const navigate=(0,dist/* useNavigate */.s0)();const navigateToPreviousStep=()=>navigate(formSteps/* formSteps */.w.einkommen.route);const navigateToNextStep=()=>navigate(formSteps/* formSteps */.w.rechnerUndPlaner.route);return/*#__PURE__*/(0,jsx_runtime.jsx)(page/* Page */.T,{step:formSteps/* formSteps */.w.elterngeldvarianten,children:/*#__PURE__*/(0,jsx_runtime.jsxs)("div",{className:"flex flex-wrap justify-between gap-y-80",children:[/*#__PURE__*/(0,jsx_runtime.jsxs)("section",{className:"flex basis-full flex-col gap-24","aria-describedby":descriptionIdentifier,children:[/*#__PURE__*/(0,jsx_runtime.jsx)("h3",{children:"Elterngeldvarianten"}),/*#__PURE__*/(0,jsx_runtime.jsxs)("p",{id:descriptionIdentifier,children:["Elterngeld gibt es in 3 Varianten.",/*#__PURE__*/(0,jsx_runtime.jsx)("br",{}),"Hier finden Sie eine \xDCbersicht \xFCber die einzelnen Elterngeldvarianten. Diese k\xF6nnen Sie im n\xE4chsten Schritt miteinander kombinieren."]}),/*#__PURE__*/(0,jsx_runtime.jsx)(ElterngeldvariantenDescriptions,{})]}),/*#__PURE__*/(0,jsx_runtime.jsx)(atoms/* Button */.zx,{buttonStyle:"secondary",label:"Zur\xFCck",onClick:navigateToPreviousStep}),/*#__PURE__*/(0,jsx_runtime.jsx)(atoms/* Button */.zx,{label:"Zum Monatsplaner",onClick:navigateToNextStep})]})});}
;// CONCATENATED MODULE: ./src/applications/App.tsx
const AllgemeineAngabenPage=/*#__PURE__*/(0,react.lazy)(()=>Promise.all(/* import() */[__webpack_require__.e(323), __webpack_require__.e(597), __webpack_require__.e(623)]).then(__webpack_require__.bind(__webpack_require__, 4623)));const NachwuchsPage=/*#__PURE__*/(0,react.lazy)(()=>Promise.all(/* import() */[__webpack_require__.e(323), __webpack_require__.e(597), __webpack_require__.e(521)]).then(__webpack_require__.bind(__webpack_require__, 6521)));const ErwerbstaetigkeitPage=/*#__PURE__*/(0,react.lazy)(()=>Promise.all(/* import() */[__webpack_require__.e(323), __webpack_require__.e(597), __webpack_require__.e(1)]).then(__webpack_require__.bind(__webpack_require__, 3001)));const EinkommenPage=/*#__PURE__*/(0,react.lazy)(()=>Promise.all(/* import() */[__webpack_require__.e(323), __webpack_require__.e(597), __webpack_require__.e(678)]).then(__webpack_require__.bind(__webpack_require__, 5678)));const RechnerPlanerPage=/*#__PURE__*/(0,react.lazy)(()=>Promise.all(/* import() */[__webpack_require__.e(323), __webpack_require__.e(597), __webpack_require__.e(81)]).then(__webpack_require__.bind(__webpack_require__, 8081)));const ZusammenfassungUndDatenPage=/*#__PURE__*/(0,react.lazy)(()=>__webpack_require__.e(/* import() */ 205).then(__webpack_require__.bind(__webpack_require__, 7205)));function App(_ref){let{elternGeldDigitalWizardUrl}=_ref;const dispatch=(0,hooks/* useAppDispatch */.TL)();dispatch(configurationActions.configure({elternGeldDigitalWizardUrl:elternGeldDigitalWizardUrl}));/* for development: show all pages at once */const url=new URL(window.location.href);const showAllPagesAtOnce=url.searchParams.get("allpages")==="1";const allPages=/*#__PURE__*/(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)(AllgemeineAngabenPage,{}),/*#__PURE__*/(0,jsx_runtime.jsx)(NachwuchsPage,{}),/*#__PURE__*/(0,jsx_runtime.jsx)(ErwerbstaetigkeitPage,{}),/*#__PURE__*/(0,jsx_runtime.jsx)(EinkommenPage,{}),/*#__PURE__*/(0,jsx_runtime.jsx)(ElterngeldvariantenPage,{}),/*#__PURE__*/(0,jsx_runtime.jsx)(RechnerPlanerPage,{}),/*#__PURE__*/(0,jsx_runtime.jsx)(ZusammenfassungUndDatenPage,{})]});return/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* MemoryRouter */.VA,{children:/*#__PURE__*/(0,jsx_runtime.jsx)(atoms/* AriaLogProvider */.gM,{children:/*#__PURE__*/(0,jsx_runtime.jsx)(react.Suspense,{fallback:/*#__PURE__*/(0,jsx_runtime.jsx)(atoms/* Spinner */.$j,{}),children:/*#__PURE__*/(0,jsx_runtime.jsxs)(dist/* Routes */.Z5,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Route */.AW,{index:true,element:/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Navigate */.Fg,{to:formSteps/* formSteps */.w.allgemeinAngaben.route,replace:true})}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Route */.AW,{path:formSteps/* formSteps */.w.allgemeinAngaben.route,element:/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:showAllPagesAtOnce?allPages:/*#__PURE__*/(0,jsx_runtime.jsx)(AllgemeineAngabenPage,{})})}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Route */.AW,{path:formSteps/* formSteps */.w.nachwuchs.route,element:/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:showAllPagesAtOnce?allPages:/*#__PURE__*/(0,jsx_runtime.jsx)(NachwuchsPage,{})})}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Route */.AW,{path:formSteps/* formSteps */.w.erwerbstaetigkeit.route,element:/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:showAllPagesAtOnce?allPages:/*#__PURE__*/(0,jsx_runtime.jsx)(ErwerbstaetigkeitPage,{})})}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Route */.AW,{path:formSteps/* formSteps */.w.einkommen.route,element:/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:showAllPagesAtOnce?allPages:/*#__PURE__*/(0,jsx_runtime.jsx)(EinkommenPage,{})})}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Route */.AW,{path:formSteps/* formSteps */.w.elterngeldvarianten.route,element:/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:showAllPagesAtOnce?allPages:/*#__PURE__*/(0,jsx_runtime.jsx)(ElterngeldvariantenPage,{})})}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Route */.AW,{path:formSteps/* formSteps */.w.rechnerUndPlaner.route,element:/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:showAllPagesAtOnce?allPages:/*#__PURE__*/(0,jsx_runtime.jsx)(RechnerPlanerPage,{})})}),/*#__PURE__*/(0,jsx_runtime.jsx)(dist/* Route */.AW,{path:formSteps/* formSteps */.w.zusammenfassungUndDaten.route,element:/*#__PURE__*/(0,jsx_runtime.jsx)(jsx_runtime.Fragment,{children:showAllPagesAtOnce?allPages:/*#__PURE__*/(0,jsx_runtime.jsx)(ZusammenfassungUndDatenPage,{})})})]})})})});}
// EXTERNAL MODULE: ./node_modules/redux/dist/redux.mjs
var redux = __webpack_require__(1154);
// EXTERNAL MODULE: ./src/redux/monatsplanerSlice.ts
var monatsplanerSlice = __webpack_require__(8772);
// EXTERNAL MODULE: ./src/redux/stepNachwuchsSlice.ts
var stepNachwuchsSlice = __webpack_require__(8632);
// EXTERNAL MODULE: ./src/redux/stepErwerbstaetigkeitSlice.ts
var stepErwerbstaetigkeitSlice = __webpack_require__(8049);
// EXTERNAL MODULE: ./src/redux/stepEinkommenSlice.ts
var stepEinkommenSlice = __webpack_require__(5353);
// EXTERNAL MODULE: ./src/globals/js/calculations/model/index.ts + 15 modules
var model = __webpack_require__(3444);
;// CONCATENATED MODULE: ./src/redux/preloadedState.ts
const preloadedState={stepAllgemeineAngaben:{antragstellende:"FuerBeide",pseudonym:{ET1:"Jasper Darwin Artus",ET2:"Salomé Loreley Zoe"},alleinerziehend:null,mutterschaftssleistungen:"NO"},stepNachwuchs:{anzahlKuenftigerKinder:1,wahrscheinlichesGeburtsDatum:"01.04.2024",geschwisterkinder:[{geburtsdatum:"24.10.2019",istBehindert:false}]},stepErwerbstaetigkeit:{ET1:{vorGeburt:"YES",isNichtSelbststaendig:true,isSelbststaendig:true,sozialVersicherungsPflichtig:"YES",monatlichesBrutto:"MehrAlsMiniJob"},ET2:{vorGeburt:"YES",isNichtSelbststaendig:true,isSelbststaendig:false,sozialVersicherungsPflichtig:"YES",monatlichesBrutto:"MehrAlsMiniJob",mehrereTaetigkeiten:"NO"}},stepEinkommen:{limitEinkommenUeberschritten:"NO",ET1:{bruttoEinkommenNichtSelbstaendig:{type:"average",average:null,perMonth:[null,null,null,null,null,null,null,null,null,null,null,null]},steuerKlasse:model/* SteuerKlasse */.nf.SKL3,splittingFaktor:null,kinderFreiBetrag:"1",gewinnSelbstaendig:{type:"average",average:null,perMonth:[null,null,null,null,null,null,null,null,null,null,null,null]},rentenVersicherung:null,zahlenSieKirchenSteuer:"YES",kassenArt:"GESETZLICH_PFLICHTVERSICHERT",taetigkeitenNichtSelbstaendigUndSelbstaendig:[{artTaetigkeit:"NichtSelbststaendig",bruttoEinkommenDurchschnitt:1000,isMinijob:"YES",zeitraum:[{from:"1",to:"3"},{from:"6",to:"9"}],versicherungen:{hasRentenversicherung:true,hasArbeitslosenversicherung:false,hasKrankenversicherung:true,none:false}},{artTaetigkeit:"Selbststaendig",bruttoEinkommenDurchschnitt:2000,isMinijob:"NO",zeitraum:[{from:"1",to:"5"},{from:"10",to:"12"}],versicherungen:{hasRentenversicherung:true,hasArbeitslosenversicherung:false,hasKrankenversicherung:true,none:false}}]},ET2:{bruttoEinkommenNichtSelbstaendig:{type:"monthly",average:null,perMonth:[800,900,1000,800,2000,1200,1500,1300,1000,1800,1600,2500]},steuerKlasse:"1",splittingFaktor:null,kinderFreiBetrag:"1",gewinnSelbstaendig:{type:"average",average:null,perMonth:[null,null,null,null,null,null,null,null,null,null,null,null]},rentenVersicherung:null,zahlenSieKirchenSteuer:"NO",kassenArt:"GESETZLICH_PFLICHTVERSICHERT",taetigkeitenNichtSelbstaendigUndSelbstaendig:[]}}};
;// CONCATENATED MODULE: ./src/redux/index.ts
const reducers=(0,redux/* combineReducers */.UY)({monatsplaner:monatsplanerSlice/* default */.ZP,stepAllgemeineAngaben:stepAllgemeineAngabenSlice/* default */.ZP,stepNachwuchs:stepNachwuchsSlice/* default */.ZP,stepErwerbstaetigkeit:stepErwerbstaetigkeitSlice/* default */.ZP,stepEinkommen:stepEinkommenSlice/* default */.ZP,stepRechner:stepRechnerSlice/* default */.ZP,configuration:redux_configurationSlice});const store=(0,redux_toolkit_modern/* configureStore */.xC)({reducer:reducers,preloadedState: false?0:undefined});/* harmony default export */ const src_redux = (store);
// EXTERNAL MODULE: ./src/globals/js/namespace.js + 1 modules
var namespace = __webpack_require__(9242);
;// CONCATENATED MODULE: ./src/reportWebVitals.ts
const reportWebVitals=onPerfEntry=>{if(onPerfEntry&&onPerfEntry instanceof Function){__webpack_require__.e(/* import() */ 496).then(__webpack_require__.bind(__webpack_require__, 1496)).then(_ref=>{let{getCLS,getFID,getFCP,getLCP,getTTFB}=_ref;getCLS(onPerfEntry);getFID(onPerfEntry);getFCP(onPerfEntry);getLCP(onPerfEntry);getTTFB(onPerfEntry);});}};/* harmony default export */ const src_reportWebVitals = (reportWebVitals);
// EXTERNAL MODULE: ./node_modules/big.js/big.mjs
var big = __webpack_require__(8113);
;// CONCATENATED MODULE: ./src/globals/js/calculations/setup-calculation.ts
/**
 * Preferences for calculations.
 */function setupCalculation(){/**
   * Default number of decimal places of the results of operations involving division are 20.
   *
   * We use 34 and round half even because:
   *
   * Java Implementation division parameter are MathContext.DECIMAL128.
   *
   * DECIMAL128: A object with a precision setting matching the IEEE 754R Decimal128 format, 34 digits, and a
   * rounding mode of HALF_EVEN, the IEEE 754R default.
   */big/* default */.Z.DP=34;big/* default */.Z.RM=big/* default */.Z.roundHalfEven;}
// EXTERNAL MODULE: ./src/user-tracking/index.ts + 5 modules
var user_tracking = __webpack_require__(5467);
;// CONCATENATED MODULE: ./src/index.tsx
document.addEventListener("DOMContentLoaded",function(){const rootDiv=document.getElementById((0,namespace/* default */.Z)("root"));if(!rootDiv)return;const elternGeldDigitalWizardUrl=rootDiv.dataset.elternGeldDigitalWizardUrl;(0,client/* createRoot */.s)(rootDiv).render(/*#__PURE__*/(0,jsx_runtime.jsxs)(react.StrictMode,{children:[/*#__PURE__*/(0,jsx_runtime.jsx)(react_redux/* Provider */.zt,{store:src_redux,children:/*#__PURE__*/(0,jsx_runtime.jsx)(App,{elternGeldDigitalWizardUrl:elternGeldDigitalWizardUrl})}),/*#__PURE__*/(0,jsx_runtime.jsx)("div",{id:(0,namespace/* default */.Z)("toast")})]}));(0,user_tracking/* setupUserTracking */.Lh)();});// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
src_reportWebVitals();// Preferences for calculations.
setupCalculation();
})();

/******/ })()
;
//# sourceMappingURL=main.281d9443.js.map